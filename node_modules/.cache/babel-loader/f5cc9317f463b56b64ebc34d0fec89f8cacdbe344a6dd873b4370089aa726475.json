{"ast":null,"code":"var _dec, _class, _VehicleModel;\nimport { ASerializable, ASVGModel, Mat3 } from \"../../../anigraph\";\nimport { Mat2DH } from \"../../math\";\nexport let VehicleDriveMode = /*#__PURE__*/function (VehicleDriveMode) {\n  VehicleDriveMode[\"Linear\"] = \"Linear\";\n  VehicleDriveMode[\"BezierSpline\"] = \"BezierSpline\";\n  return VehicleDriveMode;\n}({});\nexport let VehicleModel = (_dec = ASerializable(\"VehicleModel\"), _dec(_class = (_VehicleModel = class VehicleModel extends ASVGModel {\n  get matrix2DH() {\n    return this._matrix2DH;\n  }\n  set matrix2DH(m) {\n    this._matrix2DH = m;\n    this.signalGeometryUpdate();\n  }\n  /** Get set color */\n  set color(value) {\n    this._color = value;\n  }\n  get color() {\n    return this._color;\n  }\n  get track() {\n    return this.parent;\n  }\n  constructor(svgAsset, startTime, driveMode, speed) {\n    super(svgAsset);\n    this.driveMode = void 0;\n    /**\n     * We will measure speed in bezier segments traveled per second.\n     */\n    this.speed = 1;\n    /**\n     * Here we declare a an attribute `matrix2DH` that is a 3x3 matrix representing a 2D homogeneous transformation\n     * (\"2D Homogeneous\"). `matrix2DH` itself is comprised of a getter and setter that wrap access to the underlying\n     * protected attribute, `_matrix2DH`. This pattern of writing a getter and setter for a protected attribute lets us\n     * implement specific code to be called whenever the attribute is read or written. In this case, we will signal a\n     * geometry update any time the setter is called.\n     */\n    this._matrix2DH = void 0;\n    this.startTime = void 0;\n    this._color = void 0;\n    this.scale = 0.7;\n    this._matrix2DH = new Mat3();\n    this.startTime = startTime !== null && startTime !== void 0 ? startTime : 0;\n    this.driveMode = driveMode !== null && driveMode !== void 0 ? driveMode : VehicleModel.DriveModes.Linear;\n    ;\n    this.speed = speed !== null && speed !== void 0 ? speed : 1.0;\n  }\n  setColor(color) {\n    this._color = color;\n    this.signalGeometryUpdate();\n  }\n  getPositionForTime(t) {\n    let progress = this.getLapProgressForTime(t);\n    switch (this.driveMode) {\n      case VehicleModel.DriveModes.Linear:\n        return this.track.getLinearInterpolationPoint(progress);\n      case VehicleModel.DriveModes.BezierSpline:\n        return this.track.getCubicBezierInterpolationPoint(progress);\n      default:\n        throw new Error(`Unrecognized drive mode ${this.driveMode}`);\n    }\n  }\n  getVelocityForTime(t) {\n    let progress = this.getLapProgressForTime(t);\n    switch (this.driveMode) {\n      case VehicleModel.DriveModes.Linear:\n        return this.track.getLinearInterpolationVelocity(progress + 0.001);\n      case VehicleModel.DriveModes.BezierSpline:\n        return this.track.getCubicBezierVelocityVector(progress);\n      default:\n        throw new Error(`Unrecognized drive mode ${this.driveMode}`);\n    }\n  }\n  getLapProgressForTime(t) {\n    let age = t - this.startTime;\n    let timePerLap = this.track.nBezierSegments / this.speed;\n    let timeOnCurrentLap = age % timePerLap;\n    return timeOnCurrentLap / timePerLap;\n  }\n\n  /**\n   * You should set the `this.matrix2DH` property of the vehicle model to position, scale, and orient the vehicle\n   * correctly in space. Its position should be the value returned by\n   * returned from `this.getPositionForTime(currentTime)` and oriented so that the front of the car is facing toward\n   * the vector returned by `this.getDirectionForTime(currentTime)`.\n   * @param time\n   */\n  update(currentTime) {\n    /**\n     * Possibly useful debugging task:\n     * Think about what the behavior of each of these should be, and compare it to what you see on screen\n     */\n    this.matrix2DH = new Mat3();\n    // this.matrix2DH = Mat2DH.Rotation2D(currentTime);\n    // this.matrix2DH = Mat2DH.Translation2D(V2(Math.cos(currentTime), Math.sin(currentTime)));\n    // this.matrix2DH = Mat2DH.Scale2D(1+0.2*Math.cos(currentTime),1+0.2*Math.sin(currentTime));\n    let angle = Math.atan2(this.getVelocityForTime(currentTime).y, this.getVelocityForTime(currentTime).x);\n    this.matrix2DH = Mat2DH.Translation2D(this.getPositionForTime(currentTime)).times(Mat2DH.Rotation2D(angle).times(Mat2DH.Scale2D(this.scale, this.scale)));\n    // TODO:(Replace with your code when not debugging)\n\n    this.signalGeometryUpdate();\n  }\n}, _VehicleModel.DriveModes = VehicleDriveMode, _VehicleModel)) || _class);","map":{"version":3,"names":["ASerializable","ASVGModel","Mat3","Mat2DH","VehicleDriveMode","VehicleModel","_dec","_class","_VehicleModel","matrix2DH","_matrix2DH","m","signalGeometryUpdate","color","value","_color","track","parent","constructor","svgAsset","startTime","driveMode","speed","scale","DriveModes","Linear","setColor","getPositionForTime","t","progress","getLapProgressForTime","getLinearInterpolationPoint","BezierSpline","getCubicBezierInterpolationPoint","Error","getVelocityForTime","getLinearInterpolationVelocity","getCubicBezierVelocityVector","age","timePerLap","nBezierSegments","timeOnCurrentLap","update","currentTime","angle","Math","atan2","y","x","Translation2D","times","Rotation2D","Scale2D"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/A1/nodes/Vehicle/VehicleModel.ts"],"sourcesContent":["import {\n    AObject, AObjectState,\n    ASerializable,\n    ASVGModel,\n    Color,\n    Mat3,\n    Mat4,\n    NodeTransform3D,\n    SVGAsset, V2,\n    Vec2, Vec3\n} from \"../../../anigraph\";\nimport {Mat2DH, Point2DH, Vec2DH} from \"../../math\";\nimport {TrackModel} from \"../Track/TrackModel\";\n\nexport enum VehicleDriveMode{\n    Linear=\"Linear\",\n    BezierSpline=\"BezierSpline\",\n}\n\n@ASerializable(\"VehicleModel\")\nexport class VehicleModel extends ASVGModel{\n    static DriveModes=VehicleDriveMode;\n    driveMode!:VehicleDriveMode;\n\n    /**\n     * We will measure speed in bezier segments traveled per second.\n     */\n    speed:number=1;\n\n    /**\n     * Here we declare a an attribute `matrix2DH` that is a 3x3 matrix representing a 2D homogeneous transformation\n     * (\"2D Homogeneous\"). `matrix2DH` itself is comprised of a getter and setter that wrap access to the underlying\n     * protected attribute, `_matrix2DH`. This pattern of writing a getter and setter for a protected attribute lets us\n     * implement specific code to be called whenever the attribute is read or written. In this case, we will signal a\n     * geometry update any time the setter is called.\n     */\n    protected _matrix2DH:Mat3;\n    get matrix2DH(){\n        return this._matrix2DH;\n    }\n    set matrix2DH(m:Mat3){\n        this._matrix2DH = m;\n        this.signalGeometryUpdate();\n    }\n\n    startTime!:number;\n    _color!:Color;\n    scale:number=0.7;\n\n\n    /** Get set color */\n    set color(value){this._color = value;}\n    get color(){return this._color;}\n\n\n    get track():TrackModel{\n        return this.parent as TrackModel;\n    }\n\n    constructor(svgAsset?:SVGAsset, startTime?:number, driveMode?:VehicleDriveMode, speed?:number) {\n        super(svgAsset);\n        this._matrix2DH = new Mat3();\n        this.startTime = startTime??0;\n        this.driveMode=driveMode??VehicleModel.DriveModes.Linear;;\n        this.speed = speed??1.0;\n    }\n\n\n    setColor(color:Color){\n        this._color = color;\n        this.signalGeometryUpdate();\n    }\n\n\n    getPositionForTime(t:number){\n        let progress = this.getLapProgressForTime(t);\n        switch (this.driveMode){\n            case VehicleModel.DriveModes.Linear:\n                return this.track.getLinearInterpolationPoint(progress);\n            case VehicleModel.DriveModes.BezierSpline:\n                return this.track.getCubicBezierInterpolationPoint(progress);\n            default:\n                throw new Error(`Unrecognized drive mode ${this.driveMode}`);\n        }\n    }\n\n    getVelocityForTime(t:number){\n        let progress = this.getLapProgressForTime(t);\n        switch (this.driveMode){\n            case VehicleModel.DriveModes.Linear:\n                return this.track.getLinearInterpolationVelocity(progress+0.001);\n            case VehicleModel.DriveModes.BezierSpline:\n                return this.track.getCubicBezierVelocityVector(progress);\n            default:\n                throw new Error(`Unrecognized drive mode ${this.driveMode}`);\n        }\n    }\n\n    getLapProgressForTime(t:number){\n        let age = t-this.startTime;\n        let timePerLap = (this.track.nBezierSegments/this.speed);\n        let timeOnCurrentLap = age%timePerLap;\n        return timeOnCurrentLap/timePerLap;\n    }\n\n    /**\n     * You should set the `this.matrix2DH` property of the vehicle model to position, scale, and orient the vehicle\n     * correctly in space. Its position should be the value returned by\n     * returned from `this.getPositionForTime(currentTime)` and oriented so that the front of the car is facing toward\n     * the vector returned by `this.getDirectionForTime(currentTime)`.\n     * @param time\n     */\n    update(currentTime:number){\n\n\n        /**\n         * Possibly useful debugging task:\n         * Think about what the behavior of each of these should be, and compare it to what you see on screen\n         */\n        this.matrix2DH = new Mat3();\n        // this.matrix2DH = Mat2DH.Rotation2D(currentTime);\n        // this.matrix2DH = Mat2DH.Translation2D(V2(Math.cos(currentTime), Math.sin(currentTime)));\n        // this.matrix2DH = Mat2DH.Scale2D(1+0.2*Math.cos(currentTime),1+0.2*Math.sin(currentTime));\n        let angle = Math.atan2(this.getVelocityForTime(currentTime).y, this.getVelocityForTime(currentTime).x);\n        this.matrix2DH = Mat2DH.Translation2D(this.getPositionForTime(currentTime)).times(Mat2DH.Rotation2D(angle).times(Mat2DH.Scale2D(this.scale,this.scale)));\n        // TODO:(Replace with your code when not debugging)\n\n\n        this.signalGeometryUpdate()\n\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}