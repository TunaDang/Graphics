{"ast":null,"code":"import { Precision } from \"../index\";\nexport class BoundingBox {\n  constructor(...points) {\n    this.minPoint = void 0;\n    this.maxPoint = void 0;\n    this.transform = void 0;\n    if (points !== undefined) {\n      for (let p of points) {\n        this.boundPoint(p);\n      }\n    }\n  }\n  reset() {\n    this.minPoint = undefined;\n    this.maxPoint = undefined;\n  }\n  pointInBounds(p, epsilon) {\n    if (!this.minPoint || !this.maxPoint) {\n      return false;\n    }\n    if (epsilon === undefined) {\n      epsilon = Precision.epsilon;\n    }\n    let ndim = p.nDimensions;\n    for (let c = 0; c < ndim; c++) {\n      if (p.elements[c] < this.minPoint.elements[c] || p.elements[c] > this.maxPoint.elements[c]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * BoundPoint should adapt our bounds to include a new point should that point be outside of the current bounds.\n   * @param p\n   */\n  boundPoint(p) {\n    if (!this.minPoint || !this.maxPoint) {\n      this.minPoint = p.clone();\n      this.maxPoint = p.clone();\n      return;\n    }\n    let ndim = this.minPoint.nDimensions;\n    for (let c = 0; c < ndim; c++) {\n      if (p.elements[c] < this.minPoint.elements[c]) {\n        this.minPoint.elements[c] = p.elements[c];\n      }\n      if (p.elements[c] > this.maxPoint.elements[c]) {\n        this.maxPoint.elements[c] = p.elements[c];\n      }\n    }\n  }\n}","map":{"version":3,"names":["Precision","BoundingBox","constructor","points","minPoint","maxPoint","transform","undefined","p","boundPoint","reset","pointInBounds","epsilon","ndim","nDimensions","c","elements","clone"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/geometry/BoundingBox.ts"],"sourcesContent":["import { Precision } from \"../index\";\nimport { VectorBase} from \"../index\";\nimport { TransformationInterface} from \"../index\";\n\nexport abstract class BoundingBox<\n  VertexType extends VectorBase,\n  TransformType extends TransformationInterface\n> {\n  public minPoint!: VertexType | undefined;\n  public maxPoint!: VertexType | undefined;\n  public transform!: TransformType;\n  abstract get center(): VertexType | undefined;\n  abstract get corners(): VertexType[];\n  abstract clone(): this;\n\n  abstract randomTransformedPoint(): VertexType;\n\n  constructor(...points: Array<VertexType>) {\n    if (points !== undefined) {\n      for (let p of points) {\n        this.boundPoint(p);\n      }\n    }\n  }\n\n  reset() {\n    this.minPoint = undefined;\n    this.maxPoint = undefined;\n  }\n\n  pointInBounds(p: VertexType, epsilon?: number): boolean {\n    if (!this.minPoint || !this.maxPoint) {\n      return false;\n    }\n    if (epsilon === undefined) {\n      epsilon = Precision.epsilon;\n    }\n\n    let ndim: number = p.nDimensions;\n    for (let c = 0; c < ndim; c++) {\n      if (\n        p.elements[c] < this.minPoint.elements[c] ||\n        p.elements[c] > this.maxPoint.elements[c]\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * BoundPoint should adapt our bounds to include a new point should that point be outside of the current bounds.\n   * @param p\n   */\n  public boundPoint(p: VertexType): void {\n    if (!this.minPoint || !this.maxPoint) {\n      this.minPoint = p.clone();\n      this.maxPoint = p.clone();\n      return;\n    }\n    let ndim: number = this.minPoint.nDimensions;\n    for (let c = 0; c < ndim; c++) {\n      if (p.elements[c] < this.minPoint.elements[c]) {\n        this.minPoint.elements[c] = p.elements[c];\n      }\n      if (p.elements[c] > this.maxPoint.elements[c]) {\n        this.maxPoint.elements[c] = p.elements[c];\n      }\n    }\n  }\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,UAAU;AAIpC,OAAO,MAAeC,WAAW,CAG/B;EAUAC,WAAWA,CAAC,GAAGC,MAAyB,EAAE;IAAA,KATnCC,QAAQ;IAAA,KACRC,QAAQ;IAAA,KACRC,SAAS;IAQd,IAAIH,MAAM,KAAKI,SAAS,EAAE;MACxB,KAAK,IAAIC,CAAC,IAAIL,MAAM,EAAE;QACpB,IAAI,CAACM,UAAU,CAACD,CAAC,CAAC;MACpB;IACF;EACF;EAEAE,KAAKA,CAAA,EAAG;IACN,IAAI,CAACN,QAAQ,GAAGG,SAAS;IACzB,IAAI,CAACF,QAAQ,GAAGE,SAAS;EAC3B;EAEAI,aAAaA,CAACH,CAAa,EAAEI,OAAgB,EAAW;IACtD,IAAI,CAAC,IAAI,CAACR,QAAQ,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;MACpC,OAAO,KAAK;IACd;IACA,IAAIO,OAAO,KAAKL,SAAS,EAAE;MACzBK,OAAO,GAAGZ,SAAS,CAACY,OAAO;IAC7B;IAEA,IAAIC,IAAY,GAAGL,CAAC,CAACM,WAAW;IAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,EAAEE,CAAC,EAAE,EAAE;MAC7B,IACEP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC,GAAG,IAAI,CAACX,QAAQ,CAACY,QAAQ,CAACD,CAAC,CAAC,IACzCP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC,GAAG,IAAI,CAACV,QAAQ,CAACW,QAAQ,CAACD,CAAC,CAAC,EACzC;QACA,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACSN,UAAUA,CAACD,CAAa,EAAQ;IACrC,IAAI,CAAC,IAAI,CAACJ,QAAQ,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;MACpC,IAAI,CAACD,QAAQ,GAAGI,CAAC,CAACS,KAAK,CAAC,CAAC;MACzB,IAAI,CAACZ,QAAQ,GAAGG,CAAC,CAACS,KAAK,CAAC,CAAC;MACzB;IACF;IACA,IAAIJ,IAAY,GAAG,IAAI,CAACT,QAAQ,CAACU,WAAW;IAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,EAAEE,CAAC,EAAE,EAAE;MAC7B,IAAIP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC,GAAG,IAAI,CAACX,QAAQ,CAACY,QAAQ,CAACD,CAAC,CAAC,EAAE;QAC7C,IAAI,CAACX,QAAQ,CAACY,QAAQ,CAACD,CAAC,CAAC,GAAGP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC;MAC3C;MACA,IAAIP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC,GAAG,IAAI,CAACV,QAAQ,CAACW,QAAQ,CAACD,CAAC,CAAC,EAAE;QAC7C,IAAI,CAACV,QAAQ,CAACW,QAAQ,CAACD,CAAC,CAAC,GAAGP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC;MAC3C;IACF;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}