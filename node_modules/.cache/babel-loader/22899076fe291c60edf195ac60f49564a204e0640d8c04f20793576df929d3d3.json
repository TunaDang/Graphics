{"ast":null,"code":"import _initializerDefineProperty from \"/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js\";\nimport _applyDecoratedDescriptor from \"/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js\";\nimport _initializerWarningHelper from \"/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js\";\nvar _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _ACameraClass;\nimport { AObject, AObjectState } from \"../../base\";\nimport { AniGraphDefines } from \"../../defines\";\nimport { NodeTransform3D } from \"../nodetransforms\";\nimport { Mat4, V2, V4, Vec4 } from \"../linalg\";\nimport * as THREE from \"three\";\n// export const ZNEAR:number = AniGraphDefines.DefaultZNear;\n// export const ZFAR:number = AniGraphDefines.DefaultZFar;\nvar CamUpdateEvents = /*#__PURE__*/function (CamUpdateEvents) {\n  CamUpdateEvents[\"POSE_UPDATED\"] = \"CAMERA_POSE_UPDATED\";\n  CamUpdateEvents[\"PROJECTION_UPDATED\"] = \"CAMERA_PROJECTION_UPDATED\";\n  return CamUpdateEvents;\n}(CamUpdateEvents || {});\nvar CAMERA_PROJECTION_TYPES = /*#__PURE__*/function (CAMERA_PROJECTION_TYPES) {\n  CAMERA_PROJECTION_TYPES[\"PERSPECTIVE\"] = \"PERSPECTIVE\";\n  CAMERA_PROJECTION_TYPES[\"ORTHOGRAPHIC\"] = \"ORTHOGRAPHIC\";\n  return CAMERA_PROJECTION_TYPES;\n}(CAMERA_PROJECTION_TYPES || {});\nexport let ACameraClass = (_class = (_ACameraClass = class ACameraClass extends AObject {\n  // abstract setTransform(transform:T):void;\n\n  get projectionType() {\n    return this._projectionType;\n  }\n\n  // @AObjectState _pose:T;\n  // protected _projection:Mat4;\n  // zoom!:number;\n  // lrbt:number[];\n  // zNear!:number;\n  // zFar!:number;\n\n  /**\n   * This is so that we can define an initializer in the parent abstract class\n   * @private\n   */\n\n  get position() {\n    return this.pose.getPosition();\n  }\n  get pose() {\n    return this._pose;\n  }\n  set pose(p) {\n    this._pose = p;\n  }\n  get projection() {\n    return this._projection;\n  }\n  set projection(p) {\n    this._projection = p;\n  }\n  get frustumLeft() {\n    return this.lrbt[0];\n  }\n  get frustumRight() {\n    return this.lrbt[1];\n  }\n  get frustumBottom() {\n    return this.lrbt[2];\n  }\n  get frustumTop() {\n    return this.lrbt[3];\n  }\n  getPose() {\n    return this.pose;\n  }\n  getProjection() {\n    return this.projection;\n  }\n  getProjectionInverse() {\n    return this.projection.getInverse();\n  }\n  get modelMatrix() {\n    return this.pose.getMatrix();\n  }\n  get viewMatrix() {\n    return this.pose.getMat4().getInverse();\n  }\n  get PV() {\n    return this.projection.times(this.viewMatrix);\n  }\n  get right() {\n    return this.pose._getQuaternionRotation().getLocalX();\n  }\n  get up() {\n    return this.pose._getQuaternionRotation().getLocalY();\n  }\n  get backward() {\n    return this.pose._getQuaternionRotation().getLocalZ();\n  }\n  get forward() {\n    return this.backward.times(-1);\n  }\n\n  // abstract onCanvasResize(width:number, height:number):void;\n\n  get aspect() {\n    let wh = this._nearPlaneWH;\n    return wh.x / wh.y;\n  }\n\n  /**\n   * update projection when lrtb, zoom, or near/far have changed\n   */\n  // abstract updateProjection():void;\n  updateProjection() {\n    switch (this.projectionType) {\n      case ACameraClass.PROJECTION_TYPE.PERSPECTIVE:\n        this._setProjection(Mat4.PerspectiveFromNearPlane(this.lrbt[0], this.lrbt[1], this.lrbt[2], this.lrbt[3], this.zNear, this.zFar));\n        break;\n      case ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC:\n        let center = this._nearPlaneCenter;\n        let wh = this._nearPlaneWH.times(0.5);\n        this._setProjection(Mat4.ProjectionOrtho(center.x - wh.x, center.x + wh.x, center.y - wh.y, center.y + wh.y, this.zNear, this.zFar));\n        break;\n      default:\n        throw new Error(\"Unknown projection type: \" + this.projectionType);\n        break;\n    }\n  }\n  _setProjection(projection, signalEvent = true) {\n    this.projection = projection;\n    if (signalEvent) {\n      this.signalEvent(ACameraClass.CameraUpdateEvents.PROJECTION_UPDATED);\n    }\n  }\n  constructor(...args) {\n    super();\n    this._projectionType = void 0;\n    this.fixedImagePlaneWidth = void 0;\n    _initializerDefineProperty(this, \"_pose\", _descriptor, this);\n    _initializerDefineProperty(this, \"_projection\", _descriptor2, this);\n    _initializerDefineProperty(this, \"zoom\", _descriptor3, this);\n    _initializerDefineProperty(this, \"lrbt\", _descriptor4, this);\n    _initializerDefineProperty(this, \"zNear\", _descriptor5, this);\n    _initializerDefineProperty(this, \"zFar\", _descriptor6, this);\n    this._pose = this._DefaultPose();\n    this._projection = new Mat4();\n    this.zoom = 1;\n    this.lrbt = [];\n    this.zNear = ACamera.DEFAULT_NEAR;\n    this.zFar = ACamera.DEFAULT_FAR;\n    if (args.length) {\n      if (args[0] instanceof THREE.Camera) {\n        this.setWithThreeJSCamera(args[0]);\n      } else {\n        this.setPose(args[0]);\n        // this.pose = args[0];\n      }\n      if (args[1] && args[1] instanceof Mat4) {\n        this.projection = args[1];\n      }\n    } else {\n      this._projectionType = ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC;\n    }\n    const self = this;\n    this.addStateKeyListener('zoom', () => {\n      self.onZoomUpdate();\n    });\n  }\n  CreateThreeJSCamera() {\n    switch (this.projectionType) {\n      case ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC:\n        return new THREE.OrthographicCamera(this.lrbt[0], this.lrbt[1], this.lrbt[3], this.lrbt[2], this.zNear, this.zFar);\n        break;\n      case ACamera.PROJECTION_TYPE.PERSPECTIVE:\n        let fov = Math.atan(this.frustumTop / this.zNear) * 180;\n        let perspective = new THREE.PerspectiveCamera();\n        this.getProjection().assignTo(perspective.projectionMatrix);\n        this.getProjectionInverse().assignTo(perspective.projectionMatrixInverse);\n        this.transform.getMat4().assignTo(perspective.matrix);\n        this.transform.getMat4().assignTo(perspective.matrixWorld);\n        perspective.matrixWorldInverse.copy(perspective.matrixWorld).invert();\n        return perspective;\n        break;\n      default:\n        throw new Error(\"Unrecognized camera projection type: \" + this.projectionType);\n    }\n  }\n  addPoseListener(callback, handle, synchronous = true) {\n    return this.addStateKeyListener('_pose', callback, handle, synchronous);\n  }\n  addProjectionListener(callback, handle, synchronous = true) {\n    return this.addStateKeyListener('_projection', callback, handle, synchronous);\n  }\n  setProjection(projection) {\n    this._setProjection(projection);\n    let pinv = this.projection.getInverse();\n    let min = pinv.times(V4(-1.0, -1.0, -1.0, 1.0)).getHomogenized();\n    let max = pinv.times(V4(1.0, 1.0, -1.0, 1.0)).getHomogenized();\n    let farpoint = pinv.times(V4(0.0, 0.0, 1.0, 1.0)).getHomogenized();\n    this.lrbt = [min.x, max.x, min.y, max.y];\n    this.zNear = -min.z;\n    this.zFar = -farpoint.z;\n  }\n\n  // setPose(pose:T){\n  //     this.pose = pose;\n  // }\n\n  setPosition(position) {\n    this.pose.setPosition(position);\n  }\n  onZoomUpdate() {\n    this.updateProjection();\n  }\n  get _nearPlaneCenter() {\n    return V2(this.frustumLeft, this.frustumBottom).plus(V2(this.frustumRight, this.frustumTop)).times(0.5);\n  }\n  get _nearPlaneWH() {\n    return V2(this.frustumRight, this.frustumTop).minus(V2(this.frustumLeft, this.frustumBottom)).times(1.0 / this.zoom);\n  }\n  getProjectedPoint(p) {\n    let pointIn = p instanceof Vec4 ? p : p.Point3DH;\n    return this.getWorldToNDC().times(pointIn).Point3D;\n  }\n  getWorldSpaceProjectionOnNearPlane(p, offset = 0.001) {\n    let pointIn = p instanceof Vec4 ? p : p.Point3DH;\n    let proj = this.getWorldToNDC().times(pointIn).getHomogenized();\n    proj.z = -1 + offset;\n    let npointh = this.getWorldToNDC().getInverse().times(proj);\n    return npointh.Point3D;\n  }\n  getWorldToNDC() {\n    return this.PV;\n  }\n\n  /**\n   * gets a matrix with:\n   * x column: the vector from the left of the near plane to the right of the near plane in world coords\n   * y column: the vector from the bottom of the near plane to the top of the near plane in world coords\n   * z column: the vector from the near to the far plane in world coords\n   * w column: the location of the middle of the near plane\n   */\n  _getNearPlaneMatrix(camera) {\n    let camPVMI = this.getWorldToNDC().getInverse();\n    let maxMat = Mat4.Identity();\n    // set depth of x and y columns to near plane\n    maxMat.r2 = new Vec4(-1, -1, 1, 0);\n    // set homogeneous coords of columns to 1\n    maxMat.r3 = new Vec4(1, 1, 1, 1);\n    maxMat = camPVMI.times(maxMat);\n    let minMat = Mat4.Scale3D(-1);\n    // set depth of x y and z to near plane\n    minMat.r2 = new Vec4(-1, -1, -1, -1);\n    // set homogeneous coords of columns to 1\n    minMat.r3 = new Vec4(1, 1, 1, 1);\n    minMat = camPVMI.times(minMat);\n    let rmat = new Mat4();\n    rmat.c0 = maxMat.c0.getHomogenized().minus(minMat.c0.getHomogenized());\n    rmat.c1 = maxMat.c1.getHomogenized().minus(minMat.c1.getHomogenized());\n    rmat.c2 = maxMat.c2.getHomogenized().minus(minMat.c2.getHomogenized());\n    rmat.c3 = minMat.c3.getHomogenized();\n    return rmat;\n  }\n\n  /**\n   * gets a matrix with:\n   * x column: the vector from the left of the far plane to the right of the far plane in world coords\n   * y column: the vector from the bottom of the far plane to the top of the far plane in world coords\n   * z column: the vector from the near to the far plane in world coords\n   * w column: the location of the middle of the far plane\n   */\n  _getFarPlaneMatrix(camera) {\n    let camPVMI = this.getWorldToNDC().getInverse();\n    let maxMat = Mat4.Identity();\n    // set depth of x and y columns to far plane\n    maxMat.r2 = new Vec4(1, 1, 1, 0);\n    // set homogeneous coords of columns to 1\n    maxMat.r3 = new Vec4(1, 1, 1, 1);\n    maxMat = camPVMI.times(maxMat);\n    let minMat = Mat4.Scale3D(-1);\n    // set depth of x y and z to far plane\n    minMat.r2 = new Vec4(1, 1, -1, 1);\n    // set homogeneous coords of columns to 1\n    minMat.r3 = new Vec4(1, 1, 1, 1);\n    minMat = camPVMI.times(minMat);\n    let rmat = new Mat4();\n    rmat.c0 = maxMat.c0.getHomogenized().minus(minMat.c0.getHomogenized());\n    rmat.c1 = maxMat.c1.getHomogenized().minus(minMat.c1.getHomogenized());\n    rmat.c2 = maxMat.c2.getHomogenized().minus(minMat.c2.getHomogenized());\n    rmat.c3 = minMat.c3.getHomogenized();\n    return rmat;\n  }\n  onCanvasResize(width, height) {\n    let oldAspect = this.aspect;\n    let newAspect = width / height;\n    // let newAspect = height/width;\n    let ratio = newAspect / oldAspect;\n    let newL = this.lrbt[0] * ratio;\n    let newR = this.lrbt[1] * ratio;\n    this.lrbt = [newL, newR, this.lrbt[2], this.lrbt[3]];\n    this.updateProjection();\n  }\n}, _ACameraClass.CameraUpdateEvents = CamUpdateEvents, _ACameraClass.DEFAULT_NEAR = AniGraphDefines.DefaultZNear, _ACameraClass.DEFAULT_FAR = AniGraphDefines.DefaultZFar, _ACameraClass.PROJECTION_TYPE = CAMERA_PROJECTION_TYPES, _ACameraClass), _descriptor = _applyDecoratedDescriptor(_class.prototype, \"_pose\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"_projection\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"zoom\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"lrbt\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"zNear\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"zFar\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class);\nexport class AMatrixCamera extends ACameraClass {\n  _DefaultPose() {\n    return new Mat4();\n  }\n  // setTransform(transform: Mat4): void {\n  //     this.pose=transform;\n  // }\n\n  setPose(pose) {\n    this.pose = pose.getMat4();\n  }\n  setWithThreeJSCamera(camera) {\n    this.setProjection(Mat4.FromThreeJS(camera.projectionMatrix));\n    if (camera.matrixAutoUpdate) {\n      this.setPose(NodeTransform3D.FromThreeJSObject(camera).getMat4());\n    } else {\n      // this.setPose(Mat4.FromThreeJS(camera.matrix));\n      this.setPose(Mat4.FromThreeJS(camera.matrix));\n    }\n    if (camera instanceof THREE.PerspectiveCamera) {\n      this._projectionType = ACameraClass.PROJECTION_TYPE.PERSPECTIVE;\n    } else if (camera instanceof THREE.OrthographicCamera) {\n      this._projectionType = ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC;\n    }\n  }\n  get transform() {\n    return this.pose;\n  }\n}\nexport class ACamera extends ACameraClass {\n  _DefaultPose() {\n    return new NodeTransform3D();\n  }\n  setPose(pose) {\n    if (pose instanceof NodeTransform3D) {\n      this.pose = pose.clone();\n    } else {\n      this.pose = NodeTransform3D.FromPoseMatrix(pose.getMat4());\n    }\n  }\n  static CopyOf(camera) {\n    let newCamera = new this();\n    newCamera._projectionType = camera._projectionType;\n    newCamera.setProjection(camera.projection);\n    newCamera.setPose(camera.pose);\n    return newCamera;\n  }\n  setWithThreeJSCamera(camera) {\n    this.setProjection(Mat4.FromThreeJS(camera.projectionMatrix));\n    if (camera.matrixAutoUpdate) {\n      this.setPose(NodeTransform3D.FromThreeJSObject(camera));\n    } else {\n      // this.setPose(Mat4.FromThreeJS(camera.matrix));\n      this.setPose(NodeTransform3D.FromPoseMatrix(Mat4.FromThreeJS(camera.matrix)));\n    }\n    if (camera instanceof THREE.PerspectiveCamera) {\n      this._projectionType = ACameraClass.PROJECTION_TYPE.PERSPECTIVE;\n    } else if (camera instanceof THREE.OrthographicCamera) {\n      this._projectionType = ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC;\n    }\n  }\n  get transform() {\n    return this.pose;\n  }\n\n  /**\n   * Creates a perspective camera based on vertical fov, aspect, near, and far\n   * @param fovy\n   * @param aspect\n   * @param near\n   * @param far\n   * @returns {ACamera}\n   * @constructor\n   */\n  static CreatePerspectiveFOV(fovy, aspect, near, far) {\n    let camera = new this();\n    camera.setProjection(Mat4.PerspectiveFromFOV(fovy, aspect, near, far));\n    camera._projectionType = ACameraClass.PROJECTION_TYPE.PERSPECTIVE;\n    return camera;\n  }\n  static CreatePerspectiveNearPlane(left, right, bottom, top, near, far) {\n    let camera = new this();\n    camera.setProjection(Mat4.PerspectiveFromNearPlane(left, right, bottom, top, near, far));\n    camera._projectionType = ACameraClass.PROJECTION_TYPE.PERSPECTIVE;\n    return camera;\n  }\n  static CreateOrthographic(left, right, bottom, top, near, far) {\n    let camera = new this();\n    camera.setProjection(Mat4.ProjectionOrtho(left, right, bottom, top, near !== null && near !== void 0 ? near : AniGraphDefines.DefaultZNear, far !== null && far !== void 0 ? far : AniGraphDefines.DefaultZFar));\n    camera._projectionType = ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC;\n    return camera;\n  }\n}","map":{"version":3,"names":["AObject","AObjectState","AniGraphDefines","NodeTransform3D","Mat4","V2","V4","Vec4","THREE","CamUpdateEvents","CAMERA_PROJECTION_TYPES","ACameraClass","_class","_ACameraClass","projectionType","_projectionType","position","pose","getPosition","_pose","p","projection","_projection","frustumLeft","lrbt","frustumRight","frustumBottom","frustumTop","getPose","getProjection","getProjectionInverse","getInverse","modelMatrix","getMatrix","viewMatrix","getMat4","PV","times","right","_getQuaternionRotation","getLocalX","up","getLocalY","backward","getLocalZ","forward","aspect","wh","_nearPlaneWH","x","y","updateProjection","PROJECTION_TYPE","PERSPECTIVE","_setProjection","PerspectiveFromNearPlane","zNear","zFar","ORTHOGRAPHIC","center","_nearPlaneCenter","ProjectionOrtho","Error","signalEvent","CameraUpdateEvents","PROJECTION_UPDATED","constructor","args","fixedImagePlaneWidth","_initializerDefineProperty","_descriptor","_descriptor2","_descriptor3","_descriptor4","_descriptor5","_descriptor6","_DefaultPose","zoom","ACamera","DEFAULT_NEAR","DEFAULT_FAR","length","Camera","setWithThreeJSCamera","setPose","self","addStateKeyListener","onZoomUpdate","CreateThreeJSCamera","OrthographicCamera","fov","Math","atan","perspective","PerspectiveCamera","assignTo","projectionMatrix","projectionMatrixInverse","transform","matrix","matrixWorld","matrixWorldInverse","copy","invert","addPoseListener","callback","handle","synchronous","addProjectionListener","setProjection","pinv","min","getHomogenized","max","farpoint","z","setPosition","plus","minus","getProjectedPoint","pointIn","Point3DH","getWorldToNDC","Point3D","getWorldSpaceProjectionOnNearPlane","offset","proj","npointh","_getNearPlaneMatrix","camera","camPVMI","maxMat","Identity","r2","r3","minMat","Scale3D","rmat","c0","c1","c2","c3","_getFarPlaneMatrix","onCanvasResize","width","height","oldAspect","newAspect","ratio","newL","newR","DefaultZNear","DefaultZFar","_applyDecoratedDescriptor","prototype","configurable","enumerable","writable","initializer","AMatrixCamera","FromThreeJS","matrixAutoUpdate","FromThreeJSObject","clone","FromPoseMatrix","CopyOf","newCamera","CreatePerspectiveFOV","fovy","near","far","PerspectiveFromFOV","CreatePerspectiveNearPlane","left","bottom","top","CreateOrthographic"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/math/camera/ACamera.ts"],"sourcesContent":["import {AObject, AObjectState} from \"../../base\";\nimport {AniGraphDefines} from \"../../defines\";\nimport {NodeTransform3D} from \"../nodetransforms\";\nimport {Mat4, V2, V4, Vec3, Vec4} from \"../linalg\";\nimport * as THREE from \"three\";\nimport {TransformationInterface} from \"../TrasnformationInterface\";\nimport {Camera} from \"three\";\n\n\n// export const ZNEAR:number = AniGraphDefines.DefaultZNear;\n// export const ZFAR:number = AniGraphDefines.DefaultZFar;\n\nenum CamUpdateEvents{\n    POSE_UPDATED='CAMERA_POSE_UPDATED',\n    PROJECTION_UPDATED='CAMERA_PROJECTION_UPDATED',\n}\n\n\nenum CAMERA_PROJECTION_TYPES{\n    PERSPECTIVE = 'PERSPECTIVE',\n    ORTHOGRAPHIC = 'ORTHOGRAPHIC'\n}\n\n\nexport abstract class ACameraClass<T extends TransformationInterface> extends AObject{\n    static CameraUpdateEvents = CamUpdateEvents;\n    static DEFAULT_NEAR = AniGraphDefines.DefaultZNear;\n    static DEFAULT_FAR = AniGraphDefines.DefaultZFar;\n    abstract get transform():T;\n    // abstract setTransform(transform:T):void;\n    static PROJECTION_TYPE = CAMERA_PROJECTION_TYPES;\n\n    _projectionType!:CAMERA_PROJECTION_TYPES;\n\n    get projectionType(){\n        return this._projectionType;\n    }\n\n    fixedImagePlaneWidth!:number;\n\n    @AObjectState _pose:T;\n    @AObjectState protected _projection:Mat4;\n    @AObjectState zoom!:number;\n    @AObjectState lrbt:number[];\n    @AObjectState zNear!:number;\n    @AObjectState zFar!:number;\n\n\n\n    // @AObjectState _pose:T;\n    // protected _projection:Mat4;\n    // zoom!:number;\n    // lrbt:number[];\n    // zNear!:number;\n    // zFar!:number;\n\n    /**\n     * This is so that we can define an initializer in the parent abstract class\n     * @private\n     */\n    abstract _DefaultPose():T;\n    abstract setWithThreeJSCamera(camera:THREE.Camera):void;\n\n    get position(){\n        return this.pose.getPosition();\n    }\n\n    get pose(){return this._pose;}\n    set pose(p:T){\n        this._pose = p;\n    }\n    get projection(){return this._projection;}\n    set projection(p:Mat4){\n        this._projection = p;\n    }\n\n    get frustumLeft(){return this.lrbt[0];}\n    get frustumRight(){return this.lrbt[1];}\n    get frustumBottom(){return this.lrbt[2];}\n    get frustumTop(){return this.lrbt[3];}\n\n\n\n    getPose(){return this.pose;}\n    getProjection(){return this.projection;}\n    getProjectionInverse(){return this.projection.getInverse();}\n    get modelMatrix(){return this.pose.getMatrix();}\n    get viewMatrix(){return this.pose.getMat4().getInverse();}\n    get PV(){return this.projection.times(this.viewMatrix);}\n\n    get right(){return this.pose._getQuaternionRotation().getLocalX();}\n    get up(){return this.pose._getQuaternionRotation().getLocalY();}\n    get backward(){return this.pose._getQuaternionRotation().getLocalZ();}\n    get forward(){return this.backward.times(-1);}\n\n\n    // abstract onCanvasResize(width:number, height:number):void;\n\n    get aspect(){\n        let wh = this._nearPlaneWH;\n        return wh.x/wh.y;\n    }\n\n    /**\n     * update projection when lrtb, zoom, or near/far have changed\n     */\n    // abstract updateProjection():void;\n    updateProjection(): void {\n        switch (this.projectionType){\n            case ACameraClass.PROJECTION_TYPE.PERSPECTIVE:\n                this._setProjection(Mat4.PerspectiveFromNearPlane(this.lrbt[0], this.lrbt[1], this.lrbt[2], this.lrbt[3], this.zNear, this.zFar));\n                break;\n            case ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC:\n                let center = this._nearPlaneCenter;\n                let wh = this._nearPlaneWH.times(0.5);\n                this._setProjection(Mat4.ProjectionOrtho(center.x-wh.x, center.x+wh.x, center.y-wh.y, center.y+wh.y, this.zNear, this.zFar));\n                break;\n            default:\n                throw new Error(\"Unknown projection type: \"+this.projectionType);\n                break;\n\n        }\n    }\n\n    _setProjection(projection:Mat4, signalEvent:boolean=true){\n        this.projection = projection;\n        if(signalEvent) {\n            this.signalEvent(ACameraClass.CameraUpdateEvents.PROJECTION_UPDATED);\n        }\n    }\n\n    constructor(threeCamera?:THREE.Camera);\n    constructor(pose?:TransformationInterface, projection?:Mat4);\n    constructor(...args:any[])\n    {\n        super();\n        this._pose = this._DefaultPose();\n        this._projection = new Mat4()\n        this.zoom = 1;\n        this.lrbt=[];\n        this.zNear=ACamera.DEFAULT_NEAR;\n        this.zFar=ACamera.DEFAULT_FAR;\n\n        if(args.length) {\n            if (args[0] instanceof THREE.Camera) {\n                this.setWithThreeJSCamera(args[0]);\n            } else {\n                this.setPose(args[0]);\n                // this.pose = args[0];\n            }\n            if (args[1] && args[1] instanceof Mat4) {\n                this.projection = args[1];\n            }\n        }else{\n            this._projectionType = ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC;\n        }\n        const self = this;\n        this.addStateKeyListener('zoom', ()=>{\n            self.onZoomUpdate();\n        })\n    }\n\n    CreateThreeJSCamera(): Camera {\n        switch(this.projectionType){\n            case ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC:\n                return new THREE.OrthographicCamera(this.lrbt[0], this.lrbt[1], this.lrbt[3], this.lrbt[2], this.zNear, this.zFar);\n                break;\n\n            case ACamera.PROJECTION_TYPE.PERSPECTIVE:\n                let fov = Math.atan(this.frustumTop/this.zNear)*180;\n                let perspective = new THREE.PerspectiveCamera();\n                this.getProjection().assignTo(perspective.projectionMatrix);\n                this.getProjectionInverse().assignTo(perspective.projectionMatrixInverse);\n                this.transform.getMat4().assignTo(perspective.matrix);\n                this.transform.getMat4().assignTo(perspective.matrixWorld);\n                perspective.matrixWorldInverse.copy( perspective.matrixWorld).invert();\n                return perspective;\n                break;\n\n            default:\n                throw new Error(\"Unrecognized camera projection type: \"+this.projectionType);\n        }\n    }\n\n\n\n    addPoseListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true,){\n        return this.addStateKeyListener('_pose', callback, handle, synchronous);\n    }\n    addProjectionListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true){\n        return this.addStateKeyListener('_projection', callback, handle, synchronous);\n    }\n\n    setProjection(projection:Mat4){\n        this._setProjection(projection);\n        let pinv = this.projection.getInverse();\n        let min = pinv.times(V4(-1.0,-1.0,-1.0, 1.0)).getHomogenized()\n        let max = pinv.times(V4(1.0,1.0,-1.0, 1.0)).getHomogenized()\n        let farpoint = pinv.times(V4(0.0,0.0,1.0,1.0)).getHomogenized();\n        this.lrbt = [\n            min.x,\n            max.x,\n            min.y,\n            max.y,\n        ]\n        this.zNear = -min.z;\n        this.zFar = -farpoint.z;\n    }\n\n    // setPose(pose:T){\n    //     this.pose = pose;\n    // }\n\n    abstract setPose(pose:TransformationInterface):void;\n\n\n    setPosition(position:Vec3){\n        this.pose.setPosition(position);\n    }\n\n\n\n    onZoomUpdate() {\n        this.updateProjection();\n    }\n\n\n    get _nearPlaneCenter(){\n        return V2(this.frustumLeft,this.frustumBottom).plus(V2(this.frustumRight, this.frustumTop)).times(0.5);\n    }\n    get _nearPlaneWH(){\n        return V2(this.frustumRight, this.frustumTop).minus(V2(this.frustumLeft,this.frustumBottom)).times(1.0/this.zoom);\n    }\n\n    getProjectedPoint(p:Vec3|Vec4){\n        let pointIn = (p instanceof Vec4)?p:p.Point3DH;\n        return this.getWorldToNDC().times(pointIn).Point3D;\n    }\n\n    getWorldSpaceProjectionOnNearPlane(p:Vec3|Vec4, offset:number=0.001){\n        let pointIn = (p instanceof Vec4)?p:p.Point3DH;\n        let proj = this.getWorldToNDC().times(pointIn).getHomogenized();\n        proj.z=-1+offset;\n        let npointh = this.getWorldToNDC().getInverse().times(proj);\n        return npointh.Point3D;\n    }\n\n\n    getWorldToNDC(){\n        return this.PV;\n    }\n\n    /**\n     * gets a matrix with:\n     * x column: the vector from the left of the near plane to the right of the near plane in world coords\n     * y column: the vector from the bottom of the near plane to the top of the near plane in world coords\n     * z column: the vector from the near to the far plane in world coords\n     * w column: the location of the middle of the near plane\n     */\n    _getNearPlaneMatrix(camera:THREE.Camera){\n        let camPVMI = this.getWorldToNDC().getInverse();\n        let maxMat = Mat4.Identity();\n        // set depth of x and y columns to near plane\n        maxMat.r2=new Vec4(-1,-1,1,0);\n        // set homogeneous coords of columns to 1\n        maxMat.r3=new Vec4(1,1,1,1);\n\n        maxMat = camPVMI.times(maxMat);\n        let minMat = Mat4.Scale3D(-1);\n        // set depth of x y and z to near plane\n        minMat.r2=new Vec4(-1,-1,-1,-1);\n        // set homogeneous coords of columns to 1\n        minMat.r3 = new Vec4(1,1,1,1);\n        minMat = camPVMI.times(minMat);\n\n        let rmat = new Mat4();\n        rmat.c0=maxMat.c0.getHomogenized().minus(minMat.c0.getHomogenized());\n        rmat.c1=maxMat.c1.getHomogenized().minus(minMat.c1.getHomogenized());\n        rmat.c2=maxMat.c2.getHomogenized().minus(minMat.c2.getHomogenized());\n        rmat.c3 = minMat.c3.getHomogenized();\n        return rmat;\n    }\n\n    /**\n     * gets a matrix with:\n     * x column: the vector from the left of the far plane to the right of the far plane in world coords\n     * y column: the vector from the bottom of the far plane to the top of the far plane in world coords\n     * z column: the vector from the near to the far plane in world coords\n     * w column: the location of the middle of the far plane\n     */\n    _getFarPlaneMatrix(camera:THREE.Camera){\n        let camPVMI = this.getWorldToNDC().getInverse();\n        let maxMat = Mat4.Identity();\n        // set depth of x and y columns to far plane\n        maxMat.r2=new Vec4(1,1,1,0);\n        // set homogeneous coords of columns to 1\n        maxMat.r3=new Vec4(1,1,1,1);\n        maxMat = camPVMI.times(maxMat);\n        let minMat = Mat4.Scale3D(-1);\n        // set depth of x y and z to far plane\n        minMat.r2=new Vec4(1,1,-1,1);\n        // set homogeneous coords of columns to 1\n        minMat.r3 = new Vec4(1,1,1,1);\n        minMat = camPVMI.times(minMat);\n        let rmat = new Mat4();\n        rmat.c0=maxMat.c0.getHomogenized().minus(minMat.c0.getHomogenized());\n        rmat.c1=maxMat.c1.getHomogenized().minus(minMat.c1.getHomogenized());\n        rmat.c2=maxMat.c2.getHomogenized().minus(minMat.c2.getHomogenized());\n        rmat.c3 = minMat.c3.getHomogenized();\n        return rmat;\n    }\n\n    onCanvasResize(width: number, height: number) {\n        let oldAspect = this.aspect;\n        let newAspect = width/height;\n        // let newAspect = height/width;\n        let ratio = newAspect/oldAspect;\n        let newL = this.lrbt[0]*ratio;\n        let newR = this.lrbt[1]*ratio;\n        this.lrbt = [newL, newR, this.lrbt[2], this.lrbt[3]];\n        this.updateProjection();\n    }\n\n}\n\n\nexport class AMatrixCamera extends ACameraClass<Mat4> {\n    _DefaultPose(): Mat4 {\n        return new Mat4();\n    }\n    // setTransform(transform: Mat4): void {\n    //     this.pose=transform;\n    // }\n\n    setPose(pose: TransformationInterface) {\n        this.pose = pose.getMat4();\n    }\n\n    setWithThreeJSCamera(camera: Camera): void {\n        this.setProjection(Mat4.FromThreeJS(camera.projectionMatrix));\n        if(camera.matrixAutoUpdate){\n            this.setPose(NodeTransform3D.FromThreeJSObject(camera).getMat4());\n        }else{\n            // this.setPose(Mat4.FromThreeJS(camera.matrix));\n            this.setPose(Mat4.FromThreeJS(camera.matrix));\n        }\n        if(camera instanceof THREE.PerspectiveCamera){\n            this._projectionType = ACameraClass.PROJECTION_TYPE.PERSPECTIVE;\n        }else if(camera instanceof THREE.OrthographicCamera){\n            this._projectionType = ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC;\n        }\n    }\n\n    get transform(): Mat4 {\n        return this.pose;\n    }\n}\n\nexport class ACamera extends ACameraClass<NodeTransform3D>{\n    _DefaultPose(): NodeTransform3D {\n        return new NodeTransform3D();\n    }\n    setPose(pose: TransformationInterface): void {\n        if(pose instanceof NodeTransform3D){\n            this.pose = pose.clone();\n        }else{\n            this.pose = NodeTransform3D.FromPoseMatrix(pose.getMat4());\n        }\n    }\n\n    static CopyOf(camera:ACamera){\n        let newCamera = new this();\n        newCamera._projectionType = camera._projectionType;\n        newCamera.setProjection(camera.projection);\n        newCamera.setPose(camera.pose);\n        return newCamera;\n    }\n\n    setWithThreeJSCamera(camera: Camera): void {\n        this.setProjection(Mat4.FromThreeJS(camera.projectionMatrix));\n        if(camera.matrixAutoUpdate){\n            this.setPose(NodeTransform3D.FromThreeJSObject(camera));\n        }else{\n            // this.setPose(Mat4.FromThreeJS(camera.matrix));\n            this.setPose(NodeTransform3D.FromPoseMatrix(Mat4.FromThreeJS(camera.matrix)));\n        }\n        if(camera instanceof THREE.PerspectiveCamera){\n            this._projectionType = ACameraClass.PROJECTION_TYPE.PERSPECTIVE;\n        }else if(camera instanceof THREE.OrthographicCamera){\n            this._projectionType = ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC;\n        }\n    }\n\n    get transform() {\n        return this.pose;\n    }\n\n    /**\n     * Creates a perspective camera based on vertical fov, aspect, near, and far\n     * @param fovy\n     * @param aspect\n     * @param near\n     * @param far\n     * @returns {ACamera}\n     * @constructor\n     */\n    static CreatePerspectiveFOV(fovy: number, aspect: number, near?: number, far?: number){\n        let camera = new this();\n        camera.setProjection(Mat4.PerspectiveFromFOV(fovy, aspect, near, far));\n        camera._projectionType = ACameraClass.PROJECTION_TYPE.PERSPECTIVE;\n        return camera;\n    }\n\n    static CreatePerspectiveNearPlane(left: number, right: number, bottom: number, top: number, near?: number, far?: number) {\n        let camera = new this();\n        camera.setProjection(Mat4.PerspectiveFromNearPlane(left, right, bottom, top, near, far));\n        camera._projectionType = ACameraClass.PROJECTION_TYPE.PERSPECTIVE;\n        return camera;\n    }\n\n    static CreateOrthographic(left:number, right:number, bottom:number, top:number, near?:number, far?:number){\n        let camera = new this();\n        camera.setProjection(Mat4.ProjectionOrtho(left, right, bottom, top, near??AniGraphDefines.DefaultZNear, far??AniGraphDefines.DefaultZFar));\n        camera._projectionType = ACameraClass.PROJECTION_TYPE.ORTHOGRAPHIC;\n        return camera;\n    }\n\n\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}