{"ast":null,"code":"import { Precision } from \"../Precision\";\nimport { assert } from \"../../basictypes\";\nexport class Matrix {\n  getMatrix() {\n    return this;\n  }\n  constructor(...args) {\n    this.elements = [];\n    // common logic constructor\n    if (args.length === 0) {\n      this.setToIdentity();\n      return;\n    } else {\n      if (Array.isArray(args[0])) {\n        this.elements = args[0].slice();\n      } else {\n        this.elements = args.slice();\n      }\n    }\n  }\n\n  /**\n   * Clones the vector\n   */\n  clone() {\n    let cfunc = this.constructor;\n    var copy = new cfunc(this.elements);\n    return copy;\n  }\n\n  /**\n   * Return true if this.elements are within precision equal to other.elements\n   * @param other\n   */\n  isEqualTo(other, tolerance) {\n    let epsilon = tolerance === undefined ? Precision.epsilon : tolerance;\n    var n = this.elements.length;\n    while (n--) {\n      if (Math.abs(this.elements[n] - other.elements[n]) > epsilon) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  //##################//--Static methods--\\\\##################\n  //<editor-fold desc=\"Static methods\">\n\n  /**\n   * For taking the product of a series of matrices in order. You can feed in matrices as separate arguments or as a single list. E.g., Multiply(a, b, c, d) or Multiply([a,b,c,d]).\n   * @param args\n   * @constructor\n   */\n  static Product(...args) {\n    assert(args.length > 0, \"did not provide arguments to Matrix Multiply\");\n    let mats = args;\n    if (Array.isArray(args[0])) {\n      mats = args[0];\n      assert(args.length === 1, \"first argument to Multiply is an array, so there should be no second argument\");\n    }\n    let M = mats[0];\n    for (let i = 1; i < mats.length; i++) {\n      M = M.times(mats[i]);\n    }\n    return M;\n  }\n\n  //##################//--Arithmetic--\\\\##################\n  //<editor-fold desc=\"Arithmetic\">\n\n  /**\n   * multiplies by another matrix, vector, or scalar\n   * @param other\n   * @returns {VectorBase | this | Matrix}\n   */\n  // times(other:Vector):Vector;\n  // times(other:Vector|this|number):Vector|Matrix{\n  //     if(other instanceof Matrix){\n  //         return this._timesMatrix(other);\n  //     }else if(other instanceof Vector){\n  //         return this._timesVector(other);\n  //     }else if(typeof(other) === 'number'){\n  //         let cfunc:any=(this.constructor as any);\n  //         var m:this = new cfunc();\n  //         for(let i=0;i<m.elements.length;i++){\n  //             m.elements[i]=this.elements[i]*other;\n  //         }\n  //         return m;\n  //     }\n  //     throw new Error(\"Tried to do Matrix.times(other) with other not a matrix, vector, or scalar...\")\n  // }\n\n  plus(other) {\n    let cfunc = this.constructor;\n    var m = new cfunc();\n    for (let i = 0; i < m.elements.length; i++) {\n      m.elements[i] = this.elements[i] + other.elements[i];\n    }\n    return m;\n  }\n  minus(other) {\n    let cfunc = this.constructor;\n    var m = new cfunc();\n    for (let i = 0; i < m.elements.length; i++) {\n      m.elements[i] = this.elements[i] - other.elements[i];\n    }\n    return m;\n  }\n  //</editor-fold>\n  //##################\\\\--Arithmetic--//##################\n\n  /**\n   * Apply the matrix to a list of points.\n   * @param pointList\n   * @returns {*}\n   */\n  applyToPoints(pointList) {\n    const self = this;\n    return pointList.map(v => {\n      return self.times(v);\n    });\n  }\n}","map":{"version":3,"names":["Precision","assert","Matrix","getMatrix","constructor","args","elements","length","setToIdentity","Array","isArray","slice","clone","cfunc","copy","isEqualTo","other","tolerance","epsilon","undefined","n","Math","abs","Product","mats","M","i","times","plus","m","minus","applyToPoints","pointList","self","map","v"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/math/linalg/Matrix.ts"],"sourcesContent":["import { VectorBase } from \"./VectorBase\";\nimport { Precision } from \"../Precision\";\nimport {assert} from \"../../basictypes\";\nimport { TransformationInterface} from \"../TrasnformationInterface\";\n\nexport abstract class Matrix{\n  public elements: number[] = [];\n\n  abstract getElement(row: number, col: number): number;\n  abstract setToIdentity(): void;\n\n  abstract asPrettyString(): string;\n\n  getMatrix() {\n    return this;\n  }\n\n  protected abstract _timesVector(v: VectorBase): VectorBase;\n  protected abstract _timesMatrix(m: Matrix): Matrix;\n\n  public constructor(elements?: Array<number>);\n  public constructor(...args: Array<any>) {\n    // common logic constructor\n    if (args.length === 0) {\n      this.setToIdentity();\n      return;\n    } else {\n      if (Array.isArray(args[0])) {\n        this.elements = args[0].slice();\n      } else {\n        this.elements = args.slice();\n      }\n    }\n  }\n\n  /**\n   * Clones the vector\n   */\n  clone(): this {\n    let cfunc: any = this.constructor as any;\n    var copy: this = new cfunc(this.elements);\n    return copy;\n  }\n\n  /**\n   * Return true if this.elements are within precision equal to other.elements\n   * @param other\n   */\n  isEqualTo(other: this, tolerance?: number) {\n    let epsilon: number =\n      tolerance === undefined ? Precision.epsilon : tolerance;\n    var n: number = this.elements.length;\n    while (n--) {\n      if (Math.abs(this.elements[n] - other.elements[n]) > epsilon) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  //##################//--Static methods--\\\\##################\n  //<editor-fold desc=\"Static methods\">\n\n  /**\n   * For taking the product of a series of matrices in order. You can feed in matrices as separate arguments or as a single list. E.g., Multiply(a, b, c, d) or Multiply([a,b,c,d]).\n   * @param args\n   * @constructor\n   */\n  static Product<T extends Matrix>(...args: Array<any>) {\n    assert(args.length > 0, \"did not provide arguments to Matrix Multiply\");\n    let mats: Array<T> = args;\n    if (Array.isArray(args[0])) {\n      mats = args[0];\n      assert(\n        args.length === 1,\n        \"first argument to Multiply is an array, so there should be no second argument\"\n      );\n    }\n    let M: Matrix = mats[0];\n    for (let i = 1; i < mats.length; i++) {\n      M = M.times(mats[i]) as Matrix;\n    }\n    return M;\n  }\n\n  //##################//--Arithmetic--\\\\##################\n  //<editor-fold desc=\"Arithmetic\">\n\n  abstract times(other: VectorBase | number | Matrix): VectorBase | Matrix;\n\n  /**\n   * multiplies by another matrix, vector, or scalar\n   * @param other\n   * @returns {VectorBase | this | Matrix}\n   */\n  // times(other:Vector):Vector;\n  // times(other:Vector|this|number):Vector|Matrix{\n  //     if(other instanceof Matrix){\n  //         return this._timesMatrix(other);\n  //     }else if(other instanceof Vector){\n  //         return this._timesVector(other);\n  //     }else if(typeof(other) === 'number'){\n  //         let cfunc:any=(this.constructor as any);\n  //         var m:this = new cfunc();\n  //         for(let i=0;i<m.elements.length;i++){\n  //             m.elements[i]=this.elements[i]*other;\n  //         }\n  //         return m;\n  //     }\n  //     throw new Error(\"Tried to do Matrix.times(other) with other not a matrix, vector, or scalar...\")\n  // }\n\n  plus(other: Matrix): this {\n    let cfunc: any = this.constructor as any;\n    var m: this = new cfunc();\n    for (let i = 0; i < m.elements.length; i++) {\n      m.elements[i] = this.elements[i] + other.elements[i];\n    }\n    return m;\n  }\n\n  minus(other: Matrix): this {\n    let cfunc: any = this.constructor as any;\n    var m: this = new cfunc();\n    for (let i = 0; i < m.elements.length; i++) {\n      m.elements[i] = this.elements[i] - other.elements[i];\n    }\n    return m;\n  }\n  //</editor-fold>\n  //##################\\\\--Arithmetic--//##################\n\n  /**\n   * Apply the matrix to a list of points.\n   * @param pointList\n   * @returns {*}\n   */\n  applyToPoints(pointList: Array<VectorBase>) {\n    const self: this = this;\n    return pointList.map((v) => {\n      return self.times(v);\n    });\n  }\n\n  abstract assignTo(threejsMat: THREE.Matrix4): void;\n\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}