{"ast":null,"code":"var _dec, _class;\nimport * as THREE from \"three\";\nimport { AGraphicElement } from \"../graphicobject\";\nimport { Color, V4 } from \"../../math\";\nimport { VertexArray, VertexArray2D } from \"../../geometry\";\nimport { ASerializable } from \"../../base\";\nimport { Float32BufferAttribute } from \"three\";\nexport let APolygon2DGraphic = (_dec = ASerializable(\"APolygon2DGraphic\"), _dec(_class = class APolygon2DGraphic extends AGraphicElement {\n  get mesh() {\n    return this._element;\n  }\n  constructor(verts, material) {\n    super();\n    this.verts = void 0;\n    if (verts) {\n      this.init(verts instanceof VertexArray2D ? verts : new VertexArray2D(verts), material ? material : Color.RandomRGBA());\n    }\n  }\n  init(geometry, material) {\n    super._initIfNotAlready(geometry, material);\n  }\n  setTextureMatrix(mat) {\n    let posattr = this.geometry.getAttribute('position');\n    let vpositions = posattr.array;\n    let uvs = [];\n    let ndim = posattr.itemSize;\n    for (let vi = 0; vi < posattr.count; vi++) {\n      let p4;\n      if (ndim === 3) {\n        p4 = V4(vpositions[vi * ndim], vpositions[vi * ndim + 1], vpositions[vi * ndim + 2], 1);\n      } else if (ndim = 4) {\n        p4 = V4(vpositions[vi * ndim], vpositions[vi * ndim + 1], vpositions[vi * ndim + 2], vpositions[vi * ndim + 2]);\n      } else {\n        p4 = V4(vpositions[vi * ndim], vpositions[vi * ndim + 1], 0, 1);\n      }\n      let p4t = mat.times(p4).getHomogenized();\n      uvs.push(p4t.x);\n      uvs.push(p4t.y);\n    }\n    this.geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  setVerts2D(verts) {\n    let geometry;\n    if (Array.isArray(verts)) {\n      geometry = new VertexArray2D(verts);\n    } else if (verts instanceof VertexArray2D) {\n      geometry = verts;\n    } else {\n      throw new Error(`cannot set verts to unsupported type: ${verts}`);\n    }\n    if (this._geometry) {\n      this._geometry.dispose();\n    }\n    let shape = new THREE.Shape();\n    if (geometry.length) {\n      shape.moveTo(geometry.position.elements[0], geometry.position.elements[1]);\n      for (let v = 1; v < geometry.length; v++) {\n        let vert = geometry.position.getAt(v);\n        shape.lineTo(vert.x, vert.y);\n      }\n    }\n    this._geometry = new THREE.ShapeGeometry(shape);\n    if (verts instanceof VertexArray) {\n      for (let attribute in verts.attributes) {\n        // if (!(attribute in this._geometry.attributes)) {\n        this._geometry.setAttribute(attribute, verts.getAttributeArray(attribute).BufferAttribute());\n        // }\n      }\n    }\n    if (this._element) {\n      this.mesh.geometry = this._geometry;\n    }\n  }\n}) || _class);","map":{"version":3,"names":["THREE","AGraphicElement","Color","V4","VertexArray","VertexArray2D","ASerializable","Float32BufferAttribute","APolygon2DGraphic","_dec","_class","mesh","_element","constructor","verts","material","init","RandomRGBA","geometry","_initIfNotAlready","setTextureMatrix","mat","posattr","getAttribute","vpositions","array","uvs","ndim","itemSize","vi","count","p4","p4t","times","getHomogenized","push","x","y","setAttribute","setVerts2D","Array","isArray","Error","_geometry","dispose","shape","Shape","length","moveTo","position","elements","v","vert","getAt","lineTo","ShapeGeometry","attribute","attributes","getAttributeArray","BufferAttribute"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/rendering/graphicelements/APolygon2DGraphic.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { AGraphicElement } from \"../graphicobject\";\nimport {Color, Mat4, V4, Vec4} from \"../../math\";\nimport {VertexArray, VertexArray2D} from \"../../geometry\";\nimport {ASerializable} from \"../../base\";\nimport {AMaterial} from \"../material\";\nimport {Float32BufferAttribute} from \"three\";\n\n\n\n@ASerializable(\"APolygon2DGraphic\")\nexport class APolygon2DGraphic extends AGraphicElement {\n  protected verts!: VertexArray2D;\n  get mesh():THREE.Mesh{\n    return this._element as THREE.Mesh;\n  }\n\n  constructor(verts?:VertexArray2D|number[], material?:Color|THREE.Color|THREE.Material|THREE.Material[]|AMaterial){\n    super();\n    if(verts){\n      this.init(\n          (verts instanceof VertexArray2D)?verts:new VertexArray2D(verts),\n          material?material:Color.RandomRGBA());\n    }\n  }\n\n  init(geometry?:THREE.BufferGeometry|VertexArray2D, material?:Color|THREE.Color|THREE.Material|THREE.Material[]|AMaterial) {\n    super._initIfNotAlready(geometry, material);\n  }\n\n  setTextureMatrix(mat:Mat4){\n    let posattr = this.geometry.getAttribute('position');\n    let vpositions = posattr.array;\n    let uvs:number[] = [];\n    let ndim = posattr.itemSize;\n    for (let vi = 0; vi < posattr.count; vi++) {\n      let p4:Vec4;\n      if(ndim===3) {\n        p4 = V4(vpositions[vi * ndim], vpositions[vi * ndim + 1], vpositions[vi * ndim + 2], 1);\n      }else if(ndim=4){\n        p4 = V4(vpositions[vi * ndim], vpositions[vi * ndim + 1], vpositions[vi * ndim + 2], vpositions[vi * ndim + 2]);\n      }else{\n        p4 = V4(vpositions[vi * ndim], vpositions[vi * ndim + 1], 0, 1);\n      }\n      let p4t = mat.times(p4).getHomogenized();\n      uvs.push(p4t.x);\n      uvs.push(p4t.y);\n    }\n    this.geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n\n  }\n\n  setVerts2D(verts:VertexArray2D|number[]){\n    let geometry:VertexArray2D;\n    if(Array.isArray(verts)){\n      geometry = new VertexArray2D(verts);\n    }else if (verts instanceof VertexArray2D){\n      geometry = verts;\n    }else{\n      throw new Error(`cannot set verts to unsupported type: ${verts}`);\n    }\n    if(this._geometry){\n      this._geometry.dispose();\n    }\n    let shape = new THREE.Shape();\n    if(geometry.length){\n      shape.moveTo(geometry.position.elements[0], geometry.position.elements[1]);\n      for (let v=1;v<geometry.length;v++){\n        let vert =geometry.position.getAt(v);\n        shape.lineTo(vert.x, vert.y);\n      }\n    }\n    this._geometry = new THREE.ShapeGeometry(shape);\n    if(verts instanceof VertexArray) {\n      for (let attribute in verts.attributes) {\n        // if (!(attribute in this._geometry.attributes)) {\n          this._geometry.setAttribute(attribute, verts.getAttributeArray(attribute).BufferAttribute());\n        // }\n      }\n    }\n    if(this._element){\n      this.mesh.geometry = this._geometry;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}