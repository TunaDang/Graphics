{"ast":null,"code":"var _dec, _class;\nimport { V2, V3, Vec3, V4, V4A } from \"../math/linalg\";\nimport { VertexAttributeArray2D, VertexAttributeArray3D, VertexAttributeArrayFromThreeJS, VertexAttributeColor3DArray, VertexAttributeColorArray } from \"./VertexAttributeArray\";\nimport { ASerializable } from \"../index\";\nimport { VertexArray } from \"./VertexArray\";\nimport { VertexIndexArray } from \"./VertexIndexArray\";\nimport { BoundingBox3D } from \"./BoundingBox3D\";\nimport { Color } from \"../index\";\n\n// import { ATexture } from \"../arender/ATexture\";\n\nexport let VertexArray3D = (_dec = ASerializable(\"VertexArray3D\"), _dec(_class = class VertexArray3D extends VertexArray {\n  constructor() {\n    super();\n    this.position = new VertexAttributeArray3D();\n  }\n  getBounds() {\n    let b = new BoundingBox3D();\n    b.boundVertexPositionArrray(this.position);\n    return b;\n  }\n\n  /** Get set position */\n  set position(value) {\n    this.attributes[\"position\"] = value;\n  }\n  get position() {\n    return this.attributes[\"position\"];\n  }\n  setAttributeArray(name, attributeArray) {\n    this.attributes[name] = attributeArray;\n  }\n  static FromThreeJS(buffergeo) {\n    let varray = new VertexArray3D();\n    varray.indices = VertexIndexArray.FromThreeJS(buffergeo.index);\n    for (let atrname in buffergeo.attributes) {\n      varray.attributes[atrname] = VertexAttributeArrayFromThreeJS(buffergeo.attributes[atrname]);\n    }\n    return varray;\n  }\n\n  // static FromVertexArray2D(v2:VertexArray2D, transform:Mat4){\n  //     let v3=new VertexArray3D();\n  // }\n\n  addTriangleCCW(A, B, C, uv, color) {\n    let i = this.nVerts;\n    let AB = B.minus(A);\n    let AC = C.minus(A);\n    let N = AB.getNormalized().cross(AC.getNormalized());\n    let colorv = color;\n    if (colorv !== undefined) {\n      for (let c = 0; c < (colorv === null || colorv === void 0 ? void 0 : colorv.length); c++) {\n        if (colorv[c] instanceof Color) {\n          colorv[c] = colorv[c].Vec4;\n        }\n      }\n    }\n    this.addVertex(A, N, uv ? uv[0] : undefined, colorv ? colorv[0] : undefined);\n    this.addVertex(B, N, uv ? uv[1] : undefined, colorv ? colorv[1] : undefined);\n    this.addVertex(C, N, uv ? uv[2] : undefined, colorv ? colorv[2] : undefined);\n    this.addTriangleIndices(i, i + 1, i + 2);\n  }\n  addTriangleIndices(a, b, c) {\n    this.indices.push([a, b, c]);\n  }\n  addTriangleWithAttributesCCW(v0, v1, v2, calcNormals = true) {\n    // this.hasAttribute(\"\")\n    let i = this.nVerts;\n    let A = v0[\"position\"];\n    let B = v1[\"position\"];\n    let C = v2[\"position\"];\n    let hasNormal = this.hasNormal;\n    let hasColor = this.hasColor;\n    let hasUV = this.hasUV;\n    let normals = [];\n    if (calcNormals && hasNormal) {\n      var _v0$normal, _v1$normal, _v2$normal;\n      let AB = B.minus(A);\n      let AC = C.minus(A);\n      let N = AB.getNormalized().cross(AC.getNormalized());\n      normals.push((_v0$normal = v0[\"normal\"]) !== null && _v0$normal !== void 0 ? _v0$normal : N);\n      normals.push((_v1$normal = v1[\"normal\"]) !== null && _v1$normal !== void 0 ? _v1$normal : N);\n      normals.push((_v2$normal = v2[\"normal\"]) !== null && _v2$normal !== void 0 ? _v2$normal : N);\n    } else {\n      normals = [undefined, undefined, undefined];\n    }\n    this.addVertex(A, normals[0], v0[\"uv\"], v0[\"color\"]);\n    this.addVertex(B, normals[1], v0[\"uv\"], v1[\"color\"]);\n    this.addVertex(C, normals[2], v0[\"uv\"], v2[\"color\"]);\n    this.indices.push([i, i + 1, i + 2]);\n  }\n\n  // addTriangleCCW(A: Vec3, B: Vec3, C: Vec3, uv?: Vec2[], color?: Vec4[]) {\n  //   let i = this.nVerts;\n  //   let AB = B.minus(A);\n  //   let AC = C.minus(A);\n  //   let N = AB.getNormalized().cross(AC.getNormalized());\n  //\n  //   let colorv=color;\n  //   // if(colorv !== undefined) {\n  //   //   for(let c=0; c<colorv?.length;c++) {\n  //   //     if (colorv[c] instanceof Color) {\n  //   //       colorv[c] = (colorv[c] as Color).Vec4;\n  //   //     }\n  //   //   }\n  //   // }\n  //\n  //   this.addVertex(A, N, uv ? uv[0] : undefined, colorv ? colorv[0] : undefined);\n  //   this.addVertex(B, N, uv ? uv[1] : undefined, colorv ? colorv[1] : undefined);\n  //   this.addVertex(C, N, uv ? uv[2] : undefined, colorv ? colorv[2] : undefined);\n  //\n  //   this.indices.push([i, i + 1, i + 2]);\n  // }\n\n  static Axis(scale = 1) {\n    let o = V3(0, 0, 0);\n    let x = V3(scale, 0, 0);\n    let y = V3(0, scale, 0);\n    let nz = V3(0, 0, -scale);\n    let verts = VertexArray3D.CreateForRendering(false, false, true);\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#ff0000\"));\n    verts.addVertex(x, undefined, undefined, Color.FromString(\"#ff0000\"));\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#00ff00\"));\n    verts.addVertex(y, undefined, undefined, Color.FromString(\"#00ff00\"));\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#0000ff\"));\n    verts.addVertex(nz, undefined, undefined, Color.FromString(\"#0000ff\"));\n    verts.indices = new VertexIndexArray(2);\n    verts.indices.push([0, 1, 2, 3, 4, 5]);\n    return verts;\n  }\n  static FrustumFromProjectionMatrix(P, imagePlaneDepth = 100) {\n    let imagePlaneNDC = 0.0;\n    let baseNDC = [V4(-1, -1, imagePlaneNDC, 1), V4(1, -1, imagePlaneNDC, 1), V4(1, 1, imagePlaneNDC, 1), V4(-1, 1, imagePlaneNDC, 1)];\n    let PInv = P.getInverse();\n    let baseV = baseNDC.map(v => {\n      return PInv.times(v);\n    });\n    let verts = new VertexArray3D();\n    verts.normal = new VertexAttributeArray3D();\n    verts.indices = new VertexIndexArray(3);\n    for (let i = 0; i < 3; i++) {\n      verts.addTriangleCCW(V3(0, 0, 0), baseV[i].Point3D.getHomogenized().times(-imagePlaneDepth), baseV[i + 1].Point3D.getHomogenized().times(-imagePlaneDepth));\n    }\n    verts.addTriangleCCW(V3(0, 0, 0), baseV[3].Point3D.getHomogenized().times(-imagePlaneDepth), baseV[0].Point3D.getHomogenized().times(-imagePlaneDepth));\n    return verts;\n  }\n  initColorAttribute() {\n    this.color = new VertexAttributeColorArray();\n  }\n  initColor3DAttribute() {\n    this.color = new VertexAttributeColor3DArray();\n  }\n  initIndices(vertsPerElement = 3) {\n    this.indices = new VertexIndexArray(vertsPerElement);\n  }\n  initUVAttribute() {\n    this.uv = new VertexAttributeArray2D();\n  }\n  initNormalAttribute() {\n    this.normal = new VertexAttributeArray3D();\n  }\n  static CreateForRendering(hasNormals = true, hasTextureCoords = true, hasColors = false) {\n    let v = new this();\n    // v.indices = new VertexIndexArray(3);\n    v.initIndices();\n    if (hasNormals) {\n      v.initNormalAttribute();\n    }\n    if (hasTextureCoords) {\n      v.initUVAttribute();\n    }\n    if (hasColors) {\n      v.initColorAttribute();\n    }\n    return v;\n  }\n  static SquareXYUV(scale = 1, wraps = 1) {\n    let verts = new VertexArray3D();\n    // verts.position = new VertexAttributeArray3D();\n    verts.position.push(V3(-0.5, -0.5, 0.0).times(scale));\n    verts.position.push(V3(0.5, -0.5, 0.0).times(scale));\n    verts.position.push(V3(0.5, 0.5, 0.0).times(scale));\n    verts.position.push(V3(-0.5, 0.5, 0.0).times(scale));\n    // verts.uv = new VertexAttributeArray2D();\n    verts.initUVAttribute();\n    verts.uv.push(V2(0, 0).times(wraps));\n    verts.uv.push(V2(1, 0).times(wraps));\n    verts.uv.push(V2(1, 1).times(wraps));\n    verts.uv.push(V2(0, 1).times(wraps));\n\n    // verts.normal = new VertexAttributeArray3D();\n    verts.initNormalAttribute();\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n\n    // verts.indices = new VertexIndexArray(3);\n    verts.initIndices();\n    verts.indices.push([0, 1, 2]);\n    verts.indices.push([0, 2, 3]);\n    return verts;\n  }\n  static IndexedGrid(width = 1, height = 1, widthSegments = 1, heightSegments = 1, textureWraps, color) {\n    var _color;\n    // let width:number=1, height:number=1, widthSegments:number=1,heightSegments:number=1;\n\n    color = (_color = color) !== null && _color !== void 0 ? _color : Color.FromString(\"#ffffff\");\n    if (textureWraps === undefined) {\n      textureWraps = V2(1, 1);\n    }\n    let halfW = width * 0.5;\n    let halfH = height * 0.5;\n    // let's use normals, texture coords, and colors...\n    let v = VertexArray3D.CreateForRendering(true, true, true);\n    for (let y = 0; y < heightSegments + 1; y++) {\n      for (let x = 0; x < widthSegments + 1; x++) {\n        v.addVertex(V3(-halfW + x / widthSegments * width, -halfH + y / heightSegments * height, 0), V3(0, 0, 1), V2(x * textureWraps.x / widthSegments, y * textureWraps.y / heightSegments), color);\n      }\n    }\n    for (let y = 0; y < heightSegments; y++) {\n      for (let x = 0; x < widthSegments; x++) {\n        v.indices.push([x + y * (widthSegments + 1), x + 1 + y * (widthSegments + 1), x + 1 + (y + 1) * (widthSegments + 1)]);\n        v.indices.push([x + 1 + (y + 1) * (widthSegments + 1), x + (y + 1) * (widthSegments + 1), x + y * (widthSegments + 1)]);\n      }\n    }\n    return v;\n  }\n\n  // static VertsForBounds2D(bound:BoundingBox3D){\n  //     let verts = new VertexArray3D();\n  //     verts.position= new VertexAttributeArray3D();\n  //     verts.position.push(V3(-0.5*aspect,-0.5,0.0).times(scale))\n  //     verts.position.push(V3(0.5*aspect,-0.5,0.0).times(scale))\n  //     verts.position.push(V3(0.5*aspect,0.5,0.0).times(scale))\n  //     verts.position.push(V3(-0.5*aspect,0.5,0.0).times(scale))\n  //     verts.uv = new VertexAttributeArray2D()\n  //     verts.uv.push(V2(0,0));\n  //     verts.uv.push(V2(1,0));\n  //     verts.uv.push(V2(1,1));\n  //     verts.uv.push(V2(0,1));\n  //\n  //     verts.normal = new VertexAttributeArray3D();\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //\n  //     verts.indices = new VertexIndexArray(3);\n  //     verts.indices.push([0,1,2]);\n  //     verts.indices.push([0,2,3]);\n  //     return verts;\n  // }\n\n  static Box3D(minPoint, maxPoint) {\n    // let va = new VertexArray3D();\n    let va = VertexArray3D.CreateForRendering(true, true);\n    let corners = [minPoint.clone(), V3(maxPoint.x, minPoint.y, minPoint.z), V3(maxPoint.x, maxPoint.y, minPoint.z), V3(minPoint.x, maxPoint.y, minPoint.z), V3(minPoint.x, minPoint.y, maxPoint.z), V3(maxPoint.x, minPoint.y, maxPoint.z), maxPoint.clone(), V3(minPoint.x, maxPoint.y, maxPoint.z)];\n    va.indices = new VertexIndexArray(3);\n    let startIndex = 0;\n    function addSide(verts) {\n      let si = startIndex;\n      // let normal = verts[1].minus(verts[0]).cross(verts[3].minus(verts[0])).getNormalized().times(-1);\n      let normal = V3(0, 0, 1);\n      va.addVertex(verts[0], normal, V2(0, 1));\n      va.addVertex(verts[1], normal, V2(1, 1));\n      va.addVertex(verts[2], normal, V2(1, 0));\n      va.addVertex(verts[3], normal, V2(0, 0));\n      va.indices.push([si, si + 1, si + 2]);\n      va.indices.push([si, si + 2, si + 3]);\n      startIndex = startIndex + 4;\n    }\n    addSide([corners[0], corners[1], corners[2], corners[3]]);\n    addSide([corners[0], corners[1], corners[5], corners[4]]);\n    addSide([corners[0], corners[3], corners[7], corners[4]]);\n    addSide([corners[4], corners[5], corners[6], corners[7]]);\n    addSide([corners[2], corners[3], corners[7], corners[6]]);\n    addSide([corners[1], corners[2], corners[6], corners[5]]);\n    return va;\n  }\n  static MeshVertsForBoundingBox3D(bounds) {\n    return bounds.GetBoxTriangleMeshVerts();\n  }\n  static BoundingBoxMeshVertsForObject3D(obj) {\n    return BoundingBox3D.FromTHREEJSObject(obj).GetBoxTriangleMeshVerts();\n  }\n\n  /**\n   * Slightly modified from ThreeJS\n   * @param radius\n   * @param widthSegments\n   * @param heightSegments\n   * @param phiStart\n   * @param phiLength\n   * @param thetaStart\n   * @param thetaLength\n   * @constructor\n   */\n  static Sphere(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI, ccw = true) {\n    let sphere = VertexArray3D.CreateForRendering(true, true);\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vec3();\n    // const normal = new Vec3();\n    // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n      // special case for the poles\n      let uOffset = 0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n        // vertex\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\n        // uv\n        let uv = V2(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n        sphere.addVertex(vertex, vertex.getNormalized(), uv);\n      }\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) {\n          if (!ccw) {\n            sphere.indices.push([d, b, a]);\n          } else {\n            sphere.indices.push([a, b, d]);\n          }\n        }\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) {\n          if (!ccw) {\n            sphere.indices.push([d, c, b]);\n          } else {\n            sphere.indices.push([b, c, d]);\n          }\n        }\n      }\n    }\n    return sphere;\n  }\n\n  /**\n   * Slightly modified from ThreeJS\n   * @param radius\n   * @param widthSegments\n   * @param heightSegments\n   * @param phiStart\n   * @param phiLength\n   * @param thetaStart\n   * @param thetaLength\n   * @constructor\n   */\n  static ColoredSphere(radius = 1, widthSegments = 32, heightSegments = 16, color) {\n    // color = color??Color.RandomRGBA();\n    let phiStart = 0;\n    let phiLength = Math.PI * 2;\n    let thetaStart = 0;\n    let thetaLength = Math.PI;\n    let sphere = VertexArray3D.CreateForRendering(true, true, true);\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vec3();\n    // const normal = new Vec3();\n    // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n      // special case for the poles\n      let uOffset = 0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n        // vertex\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\n        // uv\n        let uv = V2(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n        sphere.addVertex(vertex, vertex.getNormalized(), uv, color !== null && color !== void 0 ? color : Color.RandomRGBA());\n      }\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) {\n          sphere.indices.push([a, b, d]);\n        }\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) {\n          sphere.indices.push([b, c, d]);\n        }\n      }\n    }\n    return sphere;\n  }\n\n  // static SpriteGeometry(texture: ATexture, scale: number = 100) {\n  //   let verts = new VertexArray3D();\n  //   let aspect = texture.width / texture.height;\n  //   verts.position = new VertexAttributeArray3D();\n  //   verts.position.push(V3(-0.5 * aspect, -0.5, 0.0).times(scale));\n  //   verts.position.push(V3(0.5 * aspect, -0.5, 0.0).times(scale));\n  //   verts.position.push(V3(0.5 * aspect, 0.5, 0.0).times(scale));\n  //   verts.position.push(V3(-0.5 * aspect, 0.5, 0.0).times(scale));\n  //   verts.uv = new VertexAttributeArray2D();\n  //   verts.uv.push(V2(0, 0));\n  //   verts.uv.push(V2(1, 0));\n  //   verts.uv.push(V2(1, 1));\n  //   verts.uv.push(V2(0, 1));\n  //\n  //   verts.normal = new VertexAttributeArray3D();\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //\n  //   verts.indices = new VertexIndexArray(3);\n  //   verts.indices.push([0, 1, 2]);\n  //   verts.indices.push([0, 2, 3]);\n  //   return verts;\n  // }\n\n  addVertex(v, normal, uv, color) {\n    this.position.push(v);\n    if (color) {\n      var _this$color;\n      (_this$color = this.color) === null || _this$color === void 0 ? void 0 : _this$color.push(V4A(...color.elements));\n    }\n    if (normal) {\n      var _this$normal;\n      (_this$normal = this.normal) === null || _this$normal === void 0 ? void 0 : _this$normal.push(V3(...normal.elements));\n    }\n    if (uv) {\n      var _this$uv;\n      (_this$uv = this.uv) === null || _this$uv === void 0 ? void 0 : _this$uv.push(V2(...uv.elements));\n    }\n  }\n  static FromVec3List(verts) {\n    let va = new VertexArray3D();\n    for (let v of verts) {\n      va.addVertex(v);\n    }\n    return va;\n  }\n}) || _class);","map":{"version":3,"names":["V2","V3","Vec3","V4","V4A","VertexAttributeArray2D","VertexAttributeArray3D","VertexAttributeArrayFromThreeJS","VertexAttributeColor3DArray","VertexAttributeColorArray","ASerializable","VertexArray","VertexIndexArray","BoundingBox3D","Color","VertexArray3D","_dec","_class","constructor","position","getBounds","b","boundVertexPositionArrray","value","attributes","setAttributeArray","name","attributeArray","FromThreeJS","buffergeo","varray","indices","index","atrname","addTriangleCCW","A","B","C","uv","color","i","nVerts","AB","minus","AC","N","getNormalized","cross","colorv","undefined","c","length","Vec4","addVertex","addTriangleIndices","a","push","addTriangleWithAttributesCCW","v0","v1","v2","calcNormals","hasNormal","hasColor","hasUV","normals","_v0$normal","_v1$normal","_v2$normal","Axis","scale","o","x","y","nz","verts","CreateForRendering","FromString","FrustumFromProjectionMatrix","P","imagePlaneDepth","imagePlaneNDC","baseNDC","PInv","getInverse","baseV","map","v","times","normal","Point3D","getHomogenized","initColorAttribute","initColor3DAttribute","initIndices","vertsPerElement","initUVAttribute","initNormalAttribute","hasNormals","hasTextureCoords","hasColors","SquareXYUV","wraps","IndexedGrid","width","height","widthSegments","heightSegments","textureWraps","_color","halfW","halfH","Box3D","minPoint","maxPoint","va","corners","clone","z","startIndex","addSide","si","MeshVertsForBoundingBox3D","bounds","GetBoxTriangleMeshVerts","BoundingBoxMeshVertsForObject3D","obj","FromTHREEJSObject","Sphere","radius","phiStart","phiLength","Math","PI","thetaStart","thetaLength","ccw","sphere","max","floor","thetaEnd","min","grid","vertex","iy","verticesRow","uOffset","ix","u","cos","sin","d","ColoredSphere","RandomRGBA","_this$color","elements","_this$normal","_this$uv","FromVec3List"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/geometry/VertexArray3D.ts"],"sourcesContent":["import {V2, Vec2, V3, Vec3, V4, Vec4, Mat4, V4A} from \"../math/linalg\";\nimport {\n  VertexAttributeArray,\n  VertexAttributeArray2D,\n  VertexAttributeArray3D,\n  VertexAttributeArray4D,\n  VertexAttributeArrayFromThreeJS, VertexAttributeColor3DArray, VertexAttributeColorArray,\n} from \"./VertexAttributeArray\";\nimport { ASerializable} from \"../index\";\nimport { VertexArray } from \"./VertexArray\";\nimport { VertexIndexArray } from \"./VertexIndexArray\";\nimport { BoundingBox3D } from \"./BoundingBox3D\";\nimport { Color} from \"../index\";\n\n// import { ATexture } from \"../arender/ATexture\";\n\n\nexport interface Vertex3DAttributes{\n  position:Vec3;\n  normal?:Vec3;\n  color?:Color;\n  uv?:Vec2;\n}\n\n@ASerializable(\"VertexArray3D\")\nexport class VertexArray3D extends VertexArray<Vec3> {\n  constructor() {\n    super();\n    this.position = new VertexAttributeArray3D();\n  }\n\n  getBounds(): BoundingBox3D {\n    let b = new BoundingBox3D();\n    b.boundVertexPositionArrray(this.position);\n    return b;\n  }\n\n  /** Get set position */\n  set position(value: VertexAttributeArray3D) {\n    this.attributes[\"position\"] = value;\n  }\n  get position() {\n    return this.attributes[\"position\"] as VertexAttributeArray3D;\n  }\n\n  setAttributeArray(name: string, attributeArray: VertexAttributeArray<any>) {\n    this.attributes[name] = attributeArray;\n  }\n\n  static FromThreeJS(buffergeo: THREE.BufferGeometry) {\n    let varray = new VertexArray3D();\n    varray.indices = VertexIndexArray.FromThreeJS(buffergeo.index);\n    for (let atrname in buffergeo.attributes) {\n      varray.attributes[atrname] = VertexAttributeArrayFromThreeJS(\n        buffergeo.attributes[atrname]\n      );\n    }\n    return varray;\n  }\n\n  // static FromVertexArray2D(v2:VertexArray2D, transform:Mat4){\n  //     let v3=new VertexArray3D();\n  // }\n\n  addTriangleCCW(A: Vec3, B: Vec3, C: Vec3, uv?: Vec2[], color?: Vec4[]|Color[]) {\n    let i = this.nVerts;\n    let AB = B.minus(A);\n    let AC = C.minus(A);\n    let N = AB.getNormalized().cross(AC.getNormalized());\n\n    let colorv=color;\n    if(colorv !== undefined) {\n      for(let c=0; c<colorv?.length;c++) {\n        if (colorv[c] instanceof Color) {\n          colorv[c] = (colorv[c] as Color).Vec4;\n        }\n      }\n    }\n\n    this.addVertex(A, N, uv ? uv[0] : undefined, colorv ? colorv[0] : undefined);\n    this.addVertex(B, N, uv ? uv[1] : undefined, colorv ? colorv[1] : undefined);\n    this.addVertex(C, N, uv ? uv[2] : undefined, colorv ? colorv[2] : undefined);\n\n    this.addTriangleIndices(i, i + 1, i + 2);\n  }\n\n  addTriangleIndices(a:number, b:number, c:number){\n    this.indices.push([a,b,c]);\n  }\n\n\n  addTriangleWithAttributesCCW(v0:Vertex3DAttributes, v1:Vertex3DAttributes, v2:Vertex3DAttributes, calcNormals=true){\n    // this.hasAttribute(\"\")\n    let i = this.nVerts;\n    let A = v0[\"position\"];\n    let B = v1[\"position\"];\n    let C = v2[\"position\"];\n\n    let hasNormal = this.hasNormal;\n    let hasColor = this.hasColor;\n    let hasUV = this.hasUV;\n\n    let normals:(Vec3|undefined)[] = [];\n    if(calcNormals && hasNormal) {\n      let AB = B.minus(A);\n      let AC = C.minus(A);\n      let N = AB.getNormalized().cross(AC.getNormalized());\n      normals.push(v0[\"normal\"]??N);\n      normals.push(v1[\"normal\"]??N);\n      normals.push(v2[\"normal\"]??N);\n    }else{\n      normals = [undefined, undefined, undefined];\n    }\n\n    this.addVertex(A, normals[0], v0[\"uv\"], v0[\"color\"]);\n    this.addVertex(B, normals[1], v0[\"uv\"], v1[\"color\"]);\n    this.addVertex(C, normals[2], v0[\"uv\"], v2[\"color\"]);\n    this.indices.push([i, i + 1, i + 2]);\n  }\n\n  // addTriangleCCW(A: Vec3, B: Vec3, C: Vec3, uv?: Vec2[], color?: Vec4[]) {\n  //   let i = this.nVerts;\n  //   let AB = B.minus(A);\n  //   let AC = C.minus(A);\n  //   let N = AB.getNormalized().cross(AC.getNormalized());\n  //\n  //   let colorv=color;\n  //   // if(colorv !== undefined) {\n  //   //   for(let c=0; c<colorv?.length;c++) {\n  //   //     if (colorv[c] instanceof Color) {\n  //   //       colorv[c] = (colorv[c] as Color).Vec4;\n  //   //     }\n  //   //   }\n  //   // }\n  //\n  //   this.addVertex(A, N, uv ? uv[0] : undefined, colorv ? colorv[0] : undefined);\n  //   this.addVertex(B, N, uv ? uv[1] : undefined, colorv ? colorv[1] : undefined);\n  //   this.addVertex(C, N, uv ? uv[2] : undefined, colorv ? colorv[2] : undefined);\n  //\n  //   this.indices.push([i, i + 1, i + 2]);\n  // }\n\n  static Axis(scale = 1) {\n    let o = V3(0, 0, 0);\n    let x = V3(scale, 0, 0);\n    let y = V3(0, scale, 0);\n    let nz = V3(0, 0, -scale);\n    let verts = VertexArray3D.CreateForRendering(false, false, true);\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#ff0000\"));\n    verts.addVertex(x, undefined, undefined, Color.FromString(\"#ff0000\"));\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#00ff00\"));\n    verts.addVertex(y, undefined, undefined, Color.FromString(\"#00ff00\"));\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#0000ff\"));\n    verts.addVertex(nz, undefined, undefined, Color.FromString(\"#0000ff\"));\n    verts.indices = new VertexIndexArray(2);\n    verts.indices.push([0, 1, 2, 3, 4, 5]);\n    return verts;\n  }\n\n  static FrustumFromProjectionMatrix(P: Mat4, imagePlaneDepth = 100) {\n    let imagePlaneNDC = 0.0;\n    let baseNDC = [\n      V4(-1, -1, imagePlaneNDC, 1),\n      V4(1, -1, imagePlaneNDC, 1),\n      V4(1, 1, imagePlaneNDC, 1),\n      V4(-1, 1, imagePlaneNDC, 1),\n    ];\n\n    let PInv = P.getInverse();\n    let baseV = baseNDC.map((v: Vec4) => {\n      return PInv.times(v);\n    });\n\n    let verts = new VertexArray3D();\n    verts.normal = new VertexAttributeArray3D();\n    verts.indices = new VertexIndexArray(3);\n\n    for (let i = 0; i < 3; i++) {\n      verts.addTriangleCCW(\n        V3(0, 0, 0),\n        baseV[i].Point3D.getHomogenized().times(-imagePlaneDepth),\n        baseV[i + 1].Point3D.getHomogenized().times(-imagePlaneDepth)\n      );\n    }\n    verts.addTriangleCCW(\n      V3(0, 0, 0),\n      baseV[3].Point3D.getHomogenized().times(-imagePlaneDepth),\n      baseV[0].Point3D.getHomogenized().times(-imagePlaneDepth)\n    );\n    return verts;\n  }\n\n  initColorAttribute(){\n    this.color = new VertexAttributeColorArray();\n  }\n  initColor3DAttribute(){\n    this.color = new VertexAttributeColor3DArray();\n  }\n  initIndices(vertsPerElement:number=3){\n    this.indices = new VertexIndexArray(vertsPerElement);\n  }\n\n  initUVAttribute(){\n    this.uv = new VertexAttributeArray2D();\n  }\n\n  initNormalAttribute(){\n    this.normal = new VertexAttributeArray3D();\n  }\n\n\n  static CreateForRendering(\n    hasNormals: boolean = true,\n    hasTextureCoords: boolean = true,\n    hasColors: boolean = false\n  ) {\n    let v = new this();\n    // v.indices = new VertexIndexArray(3);\n    v.initIndices()\n    if (hasNormals) {\n      v.initNormalAttribute();\n    }\n    if (hasTextureCoords) {\n      v.initUVAttribute();\n    }\n    if (hasColors) {\n      v.initColorAttribute();\n    }\n    return v;\n  }\n\n\n  static SquareXYUV(scale: number = 1, wraps: number = 1) {\n    let verts = new VertexArray3D();\n    // verts.position = new VertexAttributeArray3D();\n    verts.position.push(V3(-0.5, -0.5, 0.0).times(scale));\n    verts.position.push(V3(0.5, -0.5, 0.0).times(scale));\n    verts.position.push(V3(0.5, 0.5, 0.0).times(scale));\n    verts.position.push(V3(-0.5, 0.5, 0.0).times(scale));\n    // verts.uv = new VertexAttributeArray2D();\n    verts.initUVAttribute();\n    verts.uv.push(V2(0, 0).times(wraps));\n    verts.uv.push(V2(1, 0).times(wraps));\n    verts.uv.push(V2(1, 1).times(wraps));\n    verts.uv.push(V2(0, 1).times(wraps));\n\n    // verts.normal = new VertexAttributeArray3D();\n    verts.initNormalAttribute();\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n\n    // verts.indices = new VertexIndexArray(3);\n    verts.initIndices();\n    verts.indices.push([0, 1, 2]);\n    verts.indices.push([0, 2, 3]);\n    return verts;\n  }\n\n  static IndexedGrid(\n    width: number = 1,\n    height: number = 1,\n    widthSegments: number = 1,\n    heightSegments: number = 1,\n    textureWraps?:Vec2,\n    color?: Color\n  ) {\n    // let width:number=1, height:number=1, widthSegments:number=1,heightSegments:number=1;\n\n    color = color ?? Color.FromString(\"#ffffff\");\n\n    if(textureWraps === undefined){\n      textureWraps = V2(1, 1);\n    }\n\n    let halfW = width * 0.5;\n    let halfH = height * 0.5;\n    // let's use normals, texture coords, and colors...\n    let v = VertexArray3D.CreateForRendering(true, true, true);\n    for (let y = 0; y < heightSegments + 1; y++) {\n      for (let x = 0; x < widthSegments + 1; x++) {\n        v.addVertex(\n          V3(\n            -halfW + (x / widthSegments) * width,\n            -halfH + (y / heightSegments) * height,\n            0\n          ),\n          V3(0, 0, 1),\n          V2(x*textureWraps.x / widthSegments, y*textureWraps.y / heightSegments),\n          color\n        );\n      }\n    }\n\n    for (let y = 0; y < heightSegments; y++) {\n      for (let x = 0; x < widthSegments; x++) {\n        v.indices.push([\n          x + y * (widthSegments + 1),\n          x + 1 + y * (widthSegments + 1),\n          x + 1 + (y + 1) * (widthSegments + 1),\n        ]);\n        v.indices.push([\n          x + 1 + (y + 1) * (widthSegments + 1),\n          x + (y + 1) * (widthSegments + 1),\n          x + y * (widthSegments + 1),\n        ]);\n      }\n    }\n    return v;\n  }\n\n  // static VertsForBounds2D(bound:BoundingBox3D){\n  //     let verts = new VertexArray3D();\n  //     verts.position= new VertexAttributeArray3D();\n  //     verts.position.push(V3(-0.5*aspect,-0.5,0.0).times(scale))\n  //     verts.position.push(V3(0.5*aspect,-0.5,0.0).times(scale))\n  //     verts.position.push(V3(0.5*aspect,0.5,0.0).times(scale))\n  //     verts.position.push(V3(-0.5*aspect,0.5,0.0).times(scale))\n  //     verts.uv = new VertexAttributeArray2D()\n  //     verts.uv.push(V2(0,0));\n  //     verts.uv.push(V2(1,0));\n  //     verts.uv.push(V2(1,1));\n  //     verts.uv.push(V2(0,1));\n  //\n  //     verts.normal = new VertexAttributeArray3D();\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //\n  //     verts.indices = new VertexIndexArray(3);\n  //     verts.indices.push([0,1,2]);\n  //     verts.indices.push([0,2,3]);\n  //     return verts;\n  // }\n\n  static Box3D(minPoint:Vec3, maxPoint:Vec3) {\n    // let va = new VertexArray3D();\n    let va = VertexArray3D.CreateForRendering(true, true)\n    let corners = [minPoint.clone(),\n      V3(maxPoint.x, minPoint.y, minPoint.z),\n      V3(maxPoint.x, maxPoint.y, minPoint.z),\n      V3(minPoint.x, maxPoint.y, minPoint.z),\n      V3(minPoint.x, minPoint.y, maxPoint.z),\n      V3(maxPoint.x, minPoint.y, maxPoint.z),\n        maxPoint.clone(),\n      V3(minPoint.x, maxPoint.y, maxPoint.z)\n    ];\n\n    va.indices = new VertexIndexArray(3);\n    let startIndex = 0;\n    function addSide(verts:Vec3[]){\n      let si = startIndex;\n      // let normal = verts[1].minus(verts[0]).cross(verts[3].minus(verts[0])).getNormalized().times(-1);\n      let normal = V3(0,0,1);\n      va.addVertex(verts[0],normal,V2(0,1));\n      va.addVertex(verts[1],normal,V2(1,1));\n      va.addVertex(verts[2],normal,V2(1,0));\n      va.addVertex(verts[3],normal,V2(0,0));\n      va.indices.push([si,si+1,si+2]);\n      va.indices.push([si,si+2,si+3]);\n      startIndex = startIndex+4;\n    }\n\n    addSide([corners[0],corners[1],corners[2],corners[3]])\n    addSide([corners[0],corners[1],corners[5],corners[4]])\n    addSide([corners[0],corners[3],corners[7],corners[4]])\n\n    addSide([corners[4],corners[5],corners[6],corners[7]])\n    addSide([corners[2],corners[3],corners[7],corners[6]])\n    addSide([corners[1],corners[2],corners[6],corners[5]])\n    return va;\n  }\n\n\n  static MeshVertsForBoundingBox3D(bounds: BoundingBox3D) {\n    return bounds.GetBoxTriangleMeshVerts();\n  }\n\n  static BoundingBoxMeshVertsForObject3D(obj: THREE.Object3D) {\n    return BoundingBox3D.FromTHREEJSObject(obj).GetBoxTriangleMeshVerts();\n  }\n\n  /**\n   * Slightly modified from ThreeJS\n   * @param radius\n   * @param widthSegments\n   * @param heightSegments\n   * @param phiStart\n   * @param phiLength\n   * @param thetaStart\n   * @param thetaLength\n   * @constructor\n   */\n  static Sphere(\n    radius = 1,\n    widthSegments = 32,\n    heightSegments = 16,\n    phiStart = 0,\n    phiLength = Math.PI * 2,\n    thetaStart = 0,\n    thetaLength = Math.PI,\n    ccw:boolean = true\n  ) {\n    let sphere = VertexArray3D.CreateForRendering(true, true);\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vec3();\n    // const normal = new Vec3();\n    // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n      // special case for the poles\n      let uOffset = 0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n        // vertex\n        vertex.x =\n          -radius *\n          Math.cos(phiStart + u * phiLength) *\n          Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z =\n          radius *\n          Math.sin(phiStart + u * phiLength) *\n          Math.sin(thetaStart + v * thetaLength);\n\n        // uv\n        let uv = V2(u + uOffset, 1 - v);\n\n        verticesRow.push(index++);\n        sphere.addVertex(vertex, vertex.getNormalized(), uv);\n      }\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) {\n\n          if(!ccw) {\n            sphere.indices.push([d, b, a]);\n          }else{\n            sphere.indices.push([a, b, d]);\n          }\n        }\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) {\n          if(!ccw){\n            sphere.indices.push([d, c, b]);\n          }else{\n            sphere.indices.push([b, c, d]);\n          }\n\n\n        }\n      }\n    }\n    return sphere;\n  }\n\n\n  /**\n   * Slightly modified from ThreeJS\n   * @param radius\n   * @param widthSegments\n   * @param heightSegments\n   * @param phiStart\n   * @param phiLength\n   * @param thetaStart\n   * @param thetaLength\n   * @constructor\n   */\n  static ColoredSphere(\n      radius = 1,\n      widthSegments = 32,\n      heightSegments = 16,\n      color?:Color\n  ) {\n    // color = color??Color.RandomRGBA();\n    let phiStart = 0;\n    let phiLength = Math.PI * 2;\n    let thetaStart = 0;\n    let thetaLength = Math.PI\n    let sphere = VertexArray3D.CreateForRendering(true, true, true);\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vec3();\n    // const normal = new Vec3();\n    // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n      // special case for the poles\n      let uOffset = 0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n        // vertex\n        vertex.x =\n            -radius *\n            Math.cos(phiStart + u * phiLength) *\n            Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z =\n            radius *\n            Math.sin(phiStart + u * phiLength) *\n            Math.sin(thetaStart + v * thetaLength);\n\n        // uv\n        let uv = V2(u + uOffset, 1 - v);\n\n        verticesRow.push(index++);\n        sphere.addVertex(vertex, vertex.getNormalized(), uv,color??Color.RandomRGBA());\n      }\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) {\n          sphere.indices.push([a, b, d]);\n        }\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) {\n          sphere.indices.push([b, c, d]);\n        }\n      }\n    }\n    return sphere;\n  }\n\n\n  // static SpriteGeometry(texture: ATexture, scale: number = 100) {\n  //   let verts = new VertexArray3D();\n  //   let aspect = texture.width / texture.height;\n  //   verts.position = new VertexAttributeArray3D();\n  //   verts.position.push(V3(-0.5 * aspect, -0.5, 0.0).times(scale));\n  //   verts.position.push(V3(0.5 * aspect, -0.5, 0.0).times(scale));\n  //   verts.position.push(V3(0.5 * aspect, 0.5, 0.0).times(scale));\n  //   verts.position.push(V3(-0.5 * aspect, 0.5, 0.0).times(scale));\n  //   verts.uv = new VertexAttributeArray2D();\n  //   verts.uv.push(V2(0, 0));\n  //   verts.uv.push(V2(1, 0));\n  //   verts.uv.push(V2(1, 1));\n  //   verts.uv.push(V2(0, 1));\n  //\n  //   verts.normal = new VertexAttributeArray3D();\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //\n  //   verts.indices = new VertexIndexArray(3);\n  //   verts.indices.push([0, 1, 2]);\n  //   verts.indices.push([0, 2, 3]);\n  //   return verts;\n  // }\n\n  addVertex(v: Vec3, normal?: Vec3, uv?: Vec2, color?: Color | Vec4) {\n    this.position.push(v);\n    if (color) {\n      this.color?.push(V4A(...color.elements));\n    }\n    if (normal) {\n      this.normal?.push(V3(...normal.elements));\n    }\n    if (uv) {\n      this.uv?.push(V2(...uv.elements));\n    }\n  }\n\n  static FromVec3List(verts: Vec3[]) {\n    let va = new VertexArray3D();\n    for (let v of verts) {\n      va.addVertex(v);\n    }\n    return va;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}