{"ast":null,"code":"const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\nvar __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nclass Semaphore {\n  constructor(_maxConcurrency, _cancelError = E_CANCELED) {\n    this._maxConcurrency = _maxConcurrency;\n    this._cancelError = _cancelError;\n    this._queue = [];\n    this._waiters = [];\n    if (_maxConcurrency <= 0) {\n      throw new Error('semaphore must be initialized to a positive value');\n    }\n    this._value = _maxConcurrency;\n  }\n  acquire() {\n    const locked = this.isLocked();\n    const ticketPromise = new Promise((resolve, reject) => this._queue.push({\n      resolve,\n      reject\n    }));\n    if (!locked) this._dispatch();\n    return ticketPromise;\n  }\n  runExclusive(callback) {\n    return __awaiter$2(this, void 0, void 0, function* () {\n      const [value, release] = yield this.acquire();\n      try {\n        return yield callback(value);\n      } finally {\n        release();\n      }\n    });\n  }\n  waitForUnlock() {\n    return __awaiter$2(this, void 0, void 0, function* () {\n      if (!this.isLocked()) {\n        return Promise.resolve();\n      }\n      const waitPromise = new Promise(resolve => this._waiters.push({\n        resolve\n      }));\n      return waitPromise;\n    });\n  }\n  isLocked() {\n    return this._value <= 0;\n  }\n  /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n  release() {\n    if (this._maxConcurrency > 1) {\n      throw new Error('this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n    }\n    if (this._currentReleaser) {\n      const releaser = this._currentReleaser;\n      this._currentReleaser = undefined;\n      releaser();\n    }\n  }\n  cancel() {\n    this._queue.forEach(ticket => ticket.reject(this._cancelError));\n    this._queue = [];\n  }\n  _dispatch() {\n    const nextTicket = this._queue.shift();\n    if (!nextTicket) return;\n    let released = false;\n    this._currentReleaser = () => {\n      if (released) return;\n      released = true;\n      this._value++;\n      this._resolveWaiters();\n      this._dispatch();\n    };\n    nextTicket.resolve([this._value--, this._currentReleaser]);\n  }\n  _resolveWaiters() {\n    this._waiters.forEach(waiter => waiter.resolve());\n    this._waiters = [];\n  }\n}\nvar __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nclass Mutex {\n  constructor(cancelError) {\n    this._semaphore = new Semaphore(1, cancelError);\n  }\n  acquire() {\n    return __awaiter$1(this, void 0, void 0, function* () {\n      const [, releaser] = yield this._semaphore.acquire();\n      return releaser;\n    });\n  }\n  runExclusive(callback) {\n    return this._semaphore.runExclusive(() => callback());\n  }\n  isLocked() {\n    return this._semaphore.isLocked();\n  }\n  waitForUnlock() {\n    return this._semaphore.waitForUnlock();\n  }\n  /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n  release() {\n    this._semaphore.release();\n  }\n  cancel() {\n    return this._semaphore.cancel();\n  }\n}\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n  return {\n    acquire: () => new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      let isTimeout = false;\n      const handle = setTimeout(() => {\n        isTimeout = true;\n        reject(timeoutError);\n      }, timeout);\n      try {\n        const ticket = yield sync.acquire();\n        if (isTimeout) {\n          const release = Array.isArray(ticket) ? ticket[1] : ticket;\n          release();\n        } else {\n          clearTimeout(handle);\n          resolve(ticket);\n        }\n      } catch (e) {\n        if (!isTimeout) {\n          clearTimeout(handle);\n          reject(e);\n        }\n      }\n    })),\n    runExclusive(callback) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let release = () => undefined;\n        try {\n          const ticket = yield this.acquire();\n          if (Array.isArray(ticket)) {\n            release = ticket[1];\n            return yield callback(ticket[0]);\n          } else {\n            release = ticket;\n            return yield callback();\n          }\n        } finally {\n          release();\n        }\n      });\n    },\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n      sync.release();\n    },\n    cancel() {\n      return sync.cancel();\n    },\n    waitForUnlock: () => sync.waitForUnlock(),\n    isLocked: () => sync.isLocked()\n  };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return withTimeout(sync, 0, alreadyAcquiredError);\n}\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}