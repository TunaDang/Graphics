{"ast":null,"code":"var _dec, _class;\n/**\n * Player Controls. An InteractionMode that activates interactions with a given DOM element.\n * You can create custom controls by subclassing to define your own:\n * onMouseMove: callback for mouse movement\n * onKeyDown & onKeyUp: callbacks for when keys are pressed and released\n */\n\nimport { ADragInteraction, AKeyboardInteraction, SetInteractionCallbacks, AInteractionMode, ADOMPointerMoveInteraction, AClickInteraction } from \"../../interaction\";\nimport { ASerializable } from \"../../base\";\nimport { V2 } from \"../../math\";\nimport { AWheelInteraction } from \"../../interaction/AWheelInteraction\";\nexport let ASceneInteractionMode = (_dec = ASerializable(\"ASceneInteractionMode\"), _dec(_class = class ASceneInteractionMode extends AInteractionMode {\n  static InteractionModeClassName() {\n    // @ts-ignore\n    return this.constructor._serializationLabel;\n  }\n\n  // onKeyDown!:CallbackType;\n  onKeyDown(event, interaction) {}\n  onKeyUp(event, interaction) {}\n  onWheelMove(event, interaction) {}\n  onMouseMove(event, interaction) {}\n  onDragStart(event, interaction) {}\n  onDragMove(event, interaction) {}\n  onDragEnd(event, interaction) {}\n  onClick(event, interaction) {}\n  get owner() {\n    return this._owner;\n  }\n\n  // onKeyUp!:CallbackType;\n  // onMouseMove!:CallbackType;\n  // onWheelMove!:AWheelInteractionCallback;\n  // onDragStart!:ADragInteractionCallback;\n  // onDragMove!:ADragInteractionCallback;\n  // onDragEnd!:ADragInteractionCallback;\n\n  // new ASceneInteractionMode(\n  //     name,\n  //     owner,\n  //     {\n  //         onKeyDown: (event:AInteractionEvent, interaction:AKeyboardInteraction)=>{},\n  //         onKeyUp:(event:AInteractionEvent, interaction:AKeyboardInteraction)=>{},\n  //         onDragStart:(event:AInteractionEvent, interaction:ADragInteraction)=>{},\n  //         onDragMove:(event:AInteractionEvent, interaction:ADragInteraction)=>{},\n  //         onDragEnd:(event:AInteractionEvent, interaction:ADragInteraction)=>{},\n  //         // onClick:(event:AInteractionEvent)=>{},\n  //         // afterActivate:(...args:any[])=>{},\n  //         // afterDeactivate:(...args:any[])=>{},\n  //         // beforeActivate:(...args:any[])=>{},\n  //         // beforeDeactivate:(...args:any[])=>{},\n  //         //dispose:()=>{},\n  //     }\n  // )\n\n  /**\n   * If you use the regular constructor, it's best to call init(...) to initialize after.\n   * @param owner\n   * @param args\n   */\n  constructor(name, owner, interactionCallbacks, ...args) {\n    super(name, owner);\n    //Set and bind default interaction callbacks if they are defined for class\n    SetInteractionCallbacks(this, this, true);\n\n    //Override with any custom callbacks provided in the argument to the constructor.\n    if (interactionCallbacks) {\n      SetInteractionCallbacks(this, interactionCallbacks, false);\n    }\n    if (name === undefined) {\n      this.name = this.serializationLabel;\n    }\n    this.isGUISelectable = true;\n    if (owner) {\n      this.init(this.owner);\n    }\n  }\n  setupInteractions() {\n    if (this.onKeyDown !== undefined || this.onKeyUp !== undefined) {\n      this.addInteraction(AKeyboardInteraction.Create(this.domElement.ownerDocument, this.onKeyDown, this.onKeyUp));\n    }\n    if (this.onMouseMove !== undefined) {\n      this.addInteraction(ADOMPointerMoveInteraction.Create(this.domElement, this.onMouseMove));\n    }\n    if (this.onWheelMove !== undefined) {\n      this.addInteraction(AWheelInteraction.Create(this.domElement, this.onWheelMove));\n    }\n    if (this.onDragStart !== undefined || this.onDragMove !== undefined || this.onDragEnd !== undefined) {\n      this.addInteraction(ADragInteraction.Create(this.domElement, this.onDragStart, this.onDragMove, this.onDragEnd));\n    }\n    if (this.onClick !== undefined) {\n      this.addInteraction(AClickInteraction.Create(this.domElement, this.onClick));\n    }\n  }\n  static GetMouseEventMovement(event) {\n    let webEvent = event.DOMEvent;\n    // @ts-ignore\n    const movementX = webEvent.movementX || webEvent.mozMovementX || webEvent.webkitMovementX || 0;\n    // @ts-ignore\n    const movementY = webEvent.movementY || webEvent.mozMovementY || webEvent.webkitMovementY || 0;\n    return V2(movementX, movementY);\n  }\n\n  /**\n   * APlayerControls are a subclass of interactions that can only be added to SceneControllers\n   * @returns {A3DSceneController<any, any>}\n   */\n  get sceneController() {\n    return this.owner;\n  }\n  get serializationLabel() {\n    // @ts-ignore\n    return this.constructor._serializationLabel;\n  }\n\n  /**\n   * This is a model that contains a camera.\n   * The camera itself just encapsulates a pose and projection matrix. The model is what the camera belongs to,\n   * and can be an actual entity in the scene.\n   * @returns {ACameraNodeModel}\n   */\n  get cameraModel() {\n    return this.owner.cameraModel;\n  }\n  get camera() {\n    return this.cameraModel.camera;\n  }\n\n  /**\n   * This is the DOM element that is the game window being controlled\n   * @type {HTMLElement}\n   */\n  // domElement!: HTMLElement;\n  get domElement() {\n    return this.owner._renderWindow.container;\n  }\n  init(owner, ...args) {\n    this._owner = owner;\n    this.setupInteractions();\n  }\n\n  /**\n   * Create an instance in a single call, instead of calling new followed by init\n   * @param owner\n   * @param args\n   * @returns {ASceneInteractionMode}\n   * @constructor\n   */\n  static Create(owner, ...args) {\n    let controls = new this();\n    controls.init(owner);\n    return controls;\n  }\n}) || _class);","map":{"version":3,"names":["ADragInteraction","AKeyboardInteraction","SetInteractionCallbacks","AInteractionMode","ADOMPointerMoveInteraction","AClickInteraction","ASerializable","V2","AWheelInteraction","ASceneInteractionMode","_dec","_class","InteractionModeClassName","constructor","_serializationLabel","onKeyDown","event","interaction","onKeyUp","onWheelMove","onMouseMove","onDragStart","onDragMove","onDragEnd","onClick","owner","_owner","name","interactionCallbacks","args","undefined","serializationLabel","isGUISelectable","init","setupInteractions","addInteraction","Create","domElement","ownerDocument","GetMouseEventMovement","webEvent","DOMEvent","movementX","mozMovementX","webkitMovementX","movementY","mozMovementY","webkitMovementY","sceneController","cameraModel","camera","_renderWindow","container","controls"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/starter/interactionmodes/ASceneInteractionMode.ts"],"sourcesContent":["/**\n * Player Controls. An InteractionMode that activates interactions with a given DOM element.\n * You can create custom controls by subclassing to define your own:\n * onMouseMove: callback for mouse movement\n * onKeyDown & onKeyUp: callbacks for when keys are pressed and released\n */\n\nimport {\n    ADragInteraction,\n    AKeyboardInteraction,\n    SetInteractionCallbacks,\n    AInteractionEvent,\n    AInteractionMode,\n    ADOMPointerMoveInteraction, AClickInteraction\n} from \"../../interaction\";\nimport {ACamera} from \"../../math\";\nimport {ACameraModel} from \"../../scene/camera\";\nimport {ASerializable} from \"../../base\";\nimport {Vec2, V2} from \"../../math\";\nimport {AWheelInteraction, AWheelInteractionCallback} from \"../../interaction/AWheelInteraction\";\nimport {ASceneController} from \"../../scene/ASceneController\";\nimport type {HasInteractionModeCallbacks} from \"../../interaction\";\n\n@ASerializable(\"ASceneInteractionMode\")\nexport class ASceneInteractionMode extends AInteractionMode implements HasInteractionModeCallbacks {\n\n    static InteractionModeClassName(){\n        // @ts-ignore\n        return this.constructor._serializationLabel\n    }\n\n    // onKeyDown!:CallbackType;\n    onKeyDown(event:AInteractionEvent, interaction:AKeyboardInteraction){}\n    onKeyUp(event:AInteractionEvent, interaction:AKeyboardInteraction){}\n    onWheelMove(event:AInteractionEvent, interaction?:AWheelInteraction){}\n    onMouseMove(event:AInteractionEvent, interaction?: ADOMPointerMoveInteraction){}\n    onDragStart(event:AInteractionEvent, interaction:ADragInteraction){}\n    onDragMove(event:AInteractionEvent, interaction:ADragInteraction){}\n    onDragEnd(event:AInteractionEvent, interaction:ADragInteraction){}\n    onClick(event:AInteractionEvent, interaction:AClickInteraction){}\n\n    get owner():ASceneController{\n        return this._owner as ASceneController;\n    }\n\n    // onKeyUp!:CallbackType;\n    // onMouseMove!:CallbackType;\n    // onWheelMove!:AWheelInteractionCallback;\n    // onDragStart!:ADragInteractionCallback;\n    // onDragMove!:ADragInteractionCallback;\n    // onDragEnd!:ADragInteractionCallback;\n\n    // new ASceneInteractionMode(\n    //     name,\n    //     owner,\n    //     {\n    //         onKeyDown: (event:AInteractionEvent, interaction:AKeyboardInteraction)=>{},\n    //         onKeyUp:(event:AInteractionEvent, interaction:AKeyboardInteraction)=>{},\n    //         onDragStart:(event:AInteractionEvent, interaction:ADragInteraction)=>{},\n    //         onDragMove:(event:AInteractionEvent, interaction:ADragInteraction)=>{},\n    //         onDragEnd:(event:AInteractionEvent, interaction:ADragInteraction)=>{},\n    //         // onClick:(event:AInteractionEvent)=>{},\n    //         // afterActivate:(...args:any[])=>{},\n    //         // afterDeactivate:(...args:any[])=>{},\n    //         // beforeActivate:(...args:any[])=>{},\n    //         // beforeDeactivate:(...args:any[])=>{},\n    //         //dispose:()=>{},\n    //     }\n    // )\n\n    /**\n     * If you use the regular constructor, it's best to call init(...) to initialize after.\n     * @param owner\n     * @param args\n     */\n    constructor(name?:string, owner?:ASceneController,\n                interactionCallbacks?:HasInteractionModeCallbacks,\n                ...args:any[]) {\n        super(name, owner);\n        //Set and bind default interaction callbacks if they are defined for class\n        SetInteractionCallbacks(this, this, true);\n\n        //Override with any custom callbacks provided in the argument to the constructor.\n        if(interactionCallbacks) {\n            SetInteractionCallbacks(this, interactionCallbacks, false);\n        }\n        if(name === undefined){\n            this.name = this.serializationLabel;\n        }\n        this.isGUISelectable = true;\n        if(owner){\n            this.init(this.owner);\n        }\n    }\n\n\n    setupInteractions(){\n        if(this.onKeyDown!==undefined || this.onKeyUp!==undefined){\n            this.addInteraction(AKeyboardInteraction.Create(\n                this.domElement.ownerDocument,\n                this.onKeyDown,\n                this.onKeyUp\n            ))\n        }\n\n        if(this.onMouseMove!==undefined) {\n            this.addInteraction(ADOMPointerMoveInteraction.Create(\n                this.domElement,\n                this.onMouseMove\n            ))\n        }\n\n        if(this.onWheelMove!==undefined) {\n            this.addInteraction(AWheelInteraction.Create(\n                this.domElement,\n                this.onWheelMove\n            ));\n        }\n        if(\n            this.onDragStart!==undefined ||\n            this.onDragMove!==undefined ||\n            this.onDragEnd!==undefined\n        ) {\n            this.addInteraction(ADragInteraction.Create(\n                this.domElement,\n                this.onDragStart,\n                this.onDragMove,\n                this.onDragEnd\n            ));\n        }\n\n        if(this.onClick!==undefined){\n            this.addInteraction(AClickInteraction.Create(\n                this.domElement,\n                this.onClick\n            ))\n        }\n    }\n\n    static GetMouseEventMovement(event:AInteractionEvent){\n        let webEvent = (event.DOMEvent as MouseEvent);\n        // @ts-ignore\n        const movementX = webEvent.movementX || webEvent.mozMovementX || webEvent.webkitMovementX || 0;\n        // @ts-ignore\n        const movementY = webEvent.movementY || webEvent.mozMovementY || webEvent.webkitMovementY || 0;\n        return V2(movementX, movementY);\n    }\n\n\n\n    /**\n     * APlayerControls are a subclass of interactions that can only be added to SceneControllers\n     * @returns {A3DSceneController<any, any>}\n     */\n    get sceneController(): ASceneController{\n        return this.owner;\n    }\n\n    get serializationLabel() {\n        // @ts-ignore\n        return this.constructor._serializationLabel\n    }\n\n    /**\n     * This is a model that contains a camera.\n     * The camera itself just encapsulates a pose and projection matrix. The model is what the camera belongs to,\n     * and can be an actual entity in the scene.\n     * @returns {ACameraNodeModel}\n     */\n    get cameraModel(): ACameraModel {\n        return this.owner.cameraModel;\n    }\n\n    get camera(): ACamera {\n        return this.cameraModel.camera;\n    }\n\n    /**\n     * This is the DOM element that is the game window being controlled\n     * @type {HTMLElement}\n     */\n    // domElement!: HTMLElement;\n    get domElement():HTMLElement{\n        return this.owner._renderWindow.container;\n    }\n\n\n\n    init(owner: ASceneController, ...args: any[]) {\n        this._owner = owner;\n        this.setupInteractions();\n    }\n\n\n\n    /**\n     * Create an instance in a single call, instead of calling new followed by init\n     * @param owner\n     * @param args\n     * @returns {ASceneInteractionMode}\n     * @constructor\n     */\n    static Create(owner: ASceneController, ...args: any[]) {\n        let controls = new this();\n        controls.init(owner);\n        return controls;\n    }\n\n}\n\n\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}