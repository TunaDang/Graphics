{"ast":null,"code":"import { VertexArray } from \"./VertexArray\";\nimport { Mat3, V2, Vec2, Vec3 } from \"../math\";\nimport { BoundingBox3D } from \"./BoundingBox3D\";\nimport { Color } from \"../math\";\nimport { VertexAttributeArray2D, VertexAttributeArray3D, VertexAttributeColor3DArray, VertexAttributeColorArray, VertexPositionArray2DH } from \"./VertexAttributeArray\";\nimport { VertexIndexArray } from \"./VertexIndexArray\";\nexport class VertexArray2D extends VertexArray {\n  /** Get set position */\n  set position(value) {\n    this.attributes[VertexArray.AttributeNames.POSITION] = value;\n  }\n  get position() {\n    return this.attributes[VertexArray.AttributeNames.POSITION];\n  }\n  hasAttribute(name) {\n    return name in this.attributes;\n  }\n  get hasUVAttribute() {\n    return VertexArray.AttributeNames.UV in this.attributes;\n  }\n  get hasNormalAttribute() {\n    return VertexArray.AttributeNames.NORMAL in this.attributes;\n  }\n  get hasColorAttribute() {\n    return VertexArray.AttributeNames.COLOR in this.attributes;\n  }\n  getBounds() {\n    let b = new BoundingBox3D();\n    b.boundVertexPositionArrray(this.position);\n    return b;\n  }\n  get length() {\n    return this.position.elements.length / 3;\n  }\n  getPoint2DAt(i) {\n    return this.position.getPoint2DAt(i);\n  }\n  vertexAt(index) {\n    return this.getPoint2DAt(index);\n  }\n  FillColor(color) {\n    for (let v = 0; v < this.length; v++) {\n      this.color.setAt(v, color);\n    }\n    return this;\n  }\n  RandomizeColor() {\n    for (let v = 0; v < this.length; v++) {\n      this.color.setAt(v, Color.Random());\n    }\n    return this;\n  }\n  static CreateForCurve(hasColor = true) {\n    let v = new this();\n    v.initColorAttribute();\n    return v;\n  }\n  static CircleVArray(size, nverts = 16) {\n    let verts = new VertexArray2D();\n    for (let v = 0; v < nverts; v++) {\n      let phase = v * (2 * Math.PI) / nverts;\n      verts.addVertex(V2(Math.cos(phase) * size, Math.sin(phase) * size));\n    }\n    return verts;\n  }\n  static BoundingBoxVerts(minxy, maxxy) {\n    let va = new VertexArray2D();\n    va.addVertex(minxy);\n    va.addVertex(V2(maxxy.x, minxy.y));\n    va.addVertex(maxxy);\n    va.addVertex(V2(minxy.x, maxxy.y));\n    return va;\n  }\n  static Anchor(outerRadius = 25, innerRadius = 10, location) {\n    let verts = [new Vec2(innerRadius, innerRadius), new Vec2(0, outerRadius), new Vec2(-innerRadius, innerRadius), new Vec2(-outerRadius, 0), new Vec2(-innerRadius, -innerRadius), new Vec2(0, -outerRadius), new Vec2(innerRadius, -innerRadius), new Vec2(outerRadius, 0)];\n    if (location) {\n      verts = verts.map(v => {\n        return v.plus(location);\n      });\n    }\n    return VertexArray2D.FromLists(verts);\n  }\n\n  /**\n   * Positions have to be given with homogeneous coordinates!\n   * @param positions\n   * @param colors\n   */\n  constructor(homogeneous_positions, colors) {\n    super();\n    this.attributes = {};\n    if (homogeneous_positions !== undefined) {\n      this.position = new VertexPositionArray2DH(homogeneous_positions);\n    } else {\n      this.position = new VertexPositionArray2DH();\n    }\n    if (colors !== undefined) {\n      this.initColorAttribute();\n      this.color.setElements(colors);\n    }\n  }\n  static CreateForRendering(hasColors = true, hasTextureCoords = true, hasNormals = false) {\n    let v = new this();\n    v.indices = new VertexIndexArray(3);\n    if (hasNormals) {\n      v.normal = new VertexAttributeArray3D();\n    }\n    if (hasTextureCoords) {\n      v.uv = new VertexAttributeArray2D();\n    }\n    if (hasColors) {\n      v.initColorAttribute();\n      // v.color = new VertexAttributeColorArray();\n    }\n    return v;\n  }\n  initColorAttribute() {\n    this.color = new VertexAttributeColorArray();\n  }\n  initColor3DAttribute() {\n    this.color = new VertexAttributeColor3DArray();\n  }\n  initIndices(vertsPerElement = 3) {\n    this.indices = new VertexIndexArray(vertsPerElement);\n  }\n  initUVAttribute() {\n    this.uv = new VertexAttributeArray2D();\n  }\n  addVertex(v, color) {\n    this.position.push(v);\n    if (color) {\n      var _this$color;\n      (_this$color = this.color) === null || _this$color === void 0 ? void 0 : _this$color.push(color);\n    }\n  }\n  addVertices(positions, colors) {\n    this.position.pushArray(positions);\n    if (colors) {\n      if (colors instanceof Color) {\n        var _this$color2;\n        (_this$color2 = this.color) === null || _this$color2 === void 0 ? void 0 : _this$color2.pushArray(new Array(positions.length).fill(colors));\n      } else {\n        var _this$color3;\n        (_this$color3 = this.color) === null || _this$color3 === void 0 ? void 0 : _this$color3.pushArray(colors);\n      }\n    }\n  }\n  addVertexToFront(v, color) {\n    this.position.unshift(v);\n    if (color) {\n      var _this$color4;\n      (_this$color4 = this.color) === null || _this$color4 === void 0 ? void 0 : _this$color4.unshift(color);\n    }\n  }\n  addVerticesToFront(positions, colors) {\n    this.position.unshiftArray(positions);\n    if (colors) {\n      var _this$color5;\n      (_this$color5 = this.color) === null || _this$color5 === void 0 ? void 0 : _this$color5.unshiftArray(colors);\n    }\n  }\n  toString() {\n    let rstring = `new VertexArray2D([\\n`;\n    for (let e = 0; e < this.position.elements.length - 1; e++) {\n      rstring = rstring + `${this.position.elements[e]},`;\n    }\n    rstring = rstring + `${this.position.elements[this.position.elements.length - 1]}])`;\n    return rstring;\n  }\n  static FromLists(positions, colors) {\n    let v = new this();\n    if (colors === undefined) {\n      v.addVertices(positions);\n    } else {\n      v.initColorAttribute();\n      v.addVertices(positions, colors);\n    }\n    return v;\n  }\n  get _averagePosition() {\n    let average = new Vec3(0, 0, 0);\n    for (let v = 0; v < this.length; v++) {\n      average.addVector(this.position.getAt(v));\n    }\n    return average.Point2D;\n  }\n  static SquareXYUV(scale = 1, wraps = 1) {\n    let verts = new VertexArray2D();\n    verts.position = new VertexPositionArray2DH();\n    verts.position.push(V2(-0.5, -0.5).times(scale));\n    verts.position.push(V2(0.5, -0.5).times(scale));\n    verts.position.push(V2(0.5, 0.5).times(scale));\n    verts.position.push(V2(-0.5, 0.5).times(scale));\n    verts.uv = new VertexAttributeArray2D();\n    verts.uv.push(V2(0, 0).times(wraps));\n    verts.uv.push(V2(1, 0).times(wraps));\n    verts.uv.push(V2(1, 1).times(wraps));\n    verts.uv.push(V2(0, 1).times(wraps));\n    verts.indices = new VertexIndexArray(3);\n    verts.indices.push([0, 1, 2]);\n    verts.indices.push([0, 2, 3]);\n    return verts;\n  }\n  setUVToPositions(textureTransform) {\n    var _textureTransform;\n    textureTransform = (_textureTransform = textureTransform) !== null && _textureTransform !== void 0 ? _textureTransform : new Mat3();\n    this.initUVAttribute();\n    for (let vi = 0; vi < this.length; vi++) {\n      // let pi = this.position.getAt(vi);\n      // let uvval = textureTransform.times(V3(pi.x,pi.y,1).plus(V3(1.5,0.5,0)));\n      // this.uv.push(uvval.Point2D);\n      this.uv.push(V2(0, 0));\n    }\n  }\n}","map":{"version":3,"names":["VertexArray","Mat3","V2","Vec2","Vec3","BoundingBox3D","Color","VertexAttributeArray2D","VertexAttributeArray3D","VertexAttributeColor3DArray","VertexAttributeColorArray","VertexPositionArray2DH","VertexIndexArray","VertexArray2D","position","value","attributes","AttributeNames","POSITION","hasAttribute","name","hasUVAttribute","UV","hasNormalAttribute","NORMAL","hasColorAttribute","COLOR","getBounds","b","boundVertexPositionArrray","length","elements","getPoint2DAt","i","vertexAt","index","FillColor","color","v","setAt","RandomizeColor","Random","CreateForCurve","hasColor","initColorAttribute","CircleVArray","size","nverts","verts","phase","Math","PI","addVertex","cos","sin","BoundingBoxVerts","minxy","maxxy","va","x","y","Anchor","outerRadius","innerRadius","location","map","plus","FromLists","constructor","homogeneous_positions","colors","undefined","setElements","CreateForRendering","hasColors","hasTextureCoords","hasNormals","indices","normal","uv","initColor3DAttribute","initIndices","vertsPerElement","initUVAttribute","push","_this$color","addVertices","positions","pushArray","_this$color2","Array","fill","_this$color3","addVertexToFront","unshift","_this$color4","addVerticesToFront","unshiftArray","_this$color5","toString","rstring","e","_averagePosition","average","addVector","getAt","Point2D","SquareXYUV","scale","wraps","times","setUVToPositions","textureTransform","_textureTransform","vi"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/geometry/VertexArray2D.ts"],"sourcesContent":["import { VertexArray } from \"./VertexArray\";\nimport {Mat3, V2, V3, Vec2, Vec3, Vec4} from \"../math\";\nimport { BoundingBox3D } from \"./BoundingBox3D\";\nimport { Color} from \"../math\";\nimport {\n  VertexAttributeArray, VertexAttributeArray2D, VertexAttributeArray3D,\n  VertexAttributeColor3DArray,\n  VertexAttributeColorArray,\n  VertexPositionArray2DH,\n} from \"./VertexAttributeArray\";\nimport {VertexIndexArray} from \"./VertexIndexArray\";\n\nexport class VertexArray2D extends VertexArray<Vec2> {\n  public attributes: { [name: string]: VertexAttributeArray<any> } = {};\n\n  /** Get set position */\n  set position(value: VertexPositionArray2DH) {\n    this.attributes[VertexArray.AttributeNames.POSITION] = value;\n  }\n  get position(): VertexPositionArray2DH {\n    return this.attributes[VertexArray.AttributeNames.POSITION] as VertexPositionArray2DH;\n  }\n\n  hasAttribute(name:string){\n    return (name in this.attributes);\n  }\n\n  get hasUVAttribute(){\n    return VertexArray.AttributeNames.UV in this.attributes;\n  }\n\n  get hasNormalAttribute(){\n    return VertexArray.AttributeNames.NORMAL in this.attributes;\n  }\n\n  get hasColorAttribute(){\n    return VertexArray.AttributeNames.COLOR in this.attributes;\n  }\n\n  getBounds() {\n    let b = new BoundingBox3D();\n    b.boundVertexPositionArrray(this.position);\n    return b;\n  }\n\n  get length() {\n    return this.position.elements.length / 3;\n  }\n\n  getPoint2DAt(i: number) {\n    return this.position.getPoint2DAt(i);\n  }\n\n  vertexAt(index:number):Vec2{\n    return this.getPoint2DAt(index);\n  }\n\n  FillColor(color:Color){\n    for (let v = 0; v < this.length; v++) {\n      this.color.setAt(v, color);\n    }\n    return this;\n  }\n\n  RandomizeColor(){\n    for (let v = 0; v < this.length; v++) {\n      this.color.setAt(v, Color.Random());\n    }\n    return this;\n  }\n\n\n  static CreateForCurve(hasColor:boolean=true) {\n    let v = new this();\n    v.initColorAttribute();\n    return v;\n  }\n\n  static CircleVArray(size: number, nverts: number = 16) {\n    let verts = new VertexArray2D();\n    for (let v = 0; v < nverts; v++) {\n      let phase = (v * (2 * Math.PI)) / nverts;\n      verts.addVertex(V2(Math.cos(phase) * size, Math.sin(phase) * size));\n    }\n    return verts;\n  }\n\n  static BoundingBoxVerts(minxy: Vec2, maxxy: Vec2) {\n    let va = new VertexArray2D();\n    va.addVertex(minxy);\n    va.addVertex(V2(maxxy.x, minxy.y));\n    va.addVertex(maxxy);\n    va.addVertex(V2(minxy.x, maxxy.y));\n    return va;\n  }\n\n  static Anchor(\n    outerRadius: number = 25,\n    innerRadius: number = 10,\n    location?: Vec2\n  ) {\n    let verts = [\n      new Vec2(innerRadius, innerRadius),\n      new Vec2(0, outerRadius),\n      new Vec2(-innerRadius, innerRadius),\n      new Vec2(-outerRadius, 0),\n      new Vec2(-innerRadius, -innerRadius),\n      new Vec2(0, -outerRadius),\n      new Vec2(innerRadius, -innerRadius),\n      new Vec2(outerRadius, 0),\n    ];\n    if (location) {\n      verts = verts.map((v) => {\n        return v.plus(location);\n      });\n    }\n    return VertexArray2D.FromLists(verts);\n  }\n\n  /**\n   * Positions have to be given with homogeneous coordinates!\n   * @param positions\n   * @param colors\n   */\n  constructor(homogeneous_positions?: number[], colors?: number[]) {\n    super();\n    if (homogeneous_positions !== undefined) {\n      this.position = new VertexPositionArray2DH(homogeneous_positions);\n    } else {\n      this.position = new VertexPositionArray2DH();\n    }\n    if(colors !== undefined){\n      this.initColorAttribute();\n      this.color.setElements(colors);\n    }\n  }\n\n  static CreateForRendering(\n      hasColors: boolean = true,\n      hasTextureCoords: boolean = true,\n      hasNormals: boolean = false,\n  ) {\n    let v = new this();\n    v.indices = new VertexIndexArray(3);\n    if (hasNormals) {\n      v.normal = new VertexAttributeArray3D();\n    }\n    if (hasTextureCoords) {\n      v.uv = new VertexAttributeArray2D();\n    }\n    if (hasColors) {\n      v.initColorAttribute();\n      // v.color = new VertexAttributeColorArray();\n    }\n    return v;\n  }\n\n\n  initColorAttribute(){\n    this.color = new VertexAttributeColorArray();\n  }\n  initColor3DAttribute(){\n    this.color = new VertexAttributeColor3DArray();\n  }\n  initIndices(vertsPerElement:number=3){\n    this.indices = new VertexIndexArray(vertsPerElement);\n  }\n\n  initUVAttribute(){\n    this.uv = new VertexAttributeArray2D();\n  }\n\n  addVertex(v: Vec2 | Vec3, color?: Color | Vec3 | Vec4) {\n    this.position.push(v);\n    if (color) {\n      this.color?.push(color);\n    }\n  }\n\n  addVertices(positions: Vec2[] | Vec3[], colors?: Color|Color[] | Vec3[] | Vec4[]) {\n    this.position.pushArray(positions);\n    if (colors) {\n      if(colors instanceof Color){\n        this.color?.pushArray(new Array(positions.length).fill(colors));\n      }else {\n        this.color?.pushArray(colors);\n      }\n    }\n  }\n\n  addVertexToFront(v: Vec2 | Vec3, color?: Color | Vec3 | Vec4){\n    this.position.unshift(v);\n    if (color) {\n      this.color?.unshift(color);\n    }\n  }\n\n  addVerticesToFront(positions: Vec2[] | Vec3[], colors?: Color[] | Vec3[] | Vec4[]) {\n    this.position.unshiftArray(positions);\n    if (colors) {\n      this.color?.unshiftArray(colors)\n    }\n  }\n\n\n  toString() {\n    let rstring = `new VertexArray2D([\\n`;\n    for (let e = 0; e < this.position.elements.length - 1; e++) {\n      rstring = rstring + `${this.position.elements[e]},`;\n    }\n    rstring =\n      rstring +\n      `${this.position.elements[this.position.elements.length - 1]}])`;\n    return rstring;\n  }\n\n  static FromLists(positions:Vec2[], colors?:Color[]){\n    let v = new this();\n    if(colors===undefined) {\n      v.addVertices(positions);\n    }else{\n      v.initColorAttribute()\n      v.addVertices(positions, colors);\n    }\n    return v;\n  }\n\n  get _averagePosition() {\n    let average = new Vec3(0, 0, 0);\n    for (let v = 0; v < this.length; v++) {\n      average.addVector(this.position.getAt(v));\n    }\n    return average.Point2D;\n  }\n\n\n  static SquareXYUV(scale:number=1, wraps:number=1){\n    let verts = new VertexArray2D();\n    verts.position= new VertexPositionArray2DH();\n    verts.position.push(V2(-0.5,-0.5).times(scale))\n    verts.position.push(V2(0.5,-0.5).times(scale))\n    verts.position.push(V2(0.5,0.5).times(scale))\n    verts.position.push(V2(-0.5,0.5).times(scale))\n    verts.uv = new VertexAttributeArray2D()\n    verts.uv.push(V2(0,0).times(wraps));\n    verts.uv.push(V2(1,0).times(wraps));\n    verts.uv.push(V2(1,1).times(wraps));\n    verts.uv.push(V2(0,1).times(wraps));\n    verts.indices = new VertexIndexArray(3);\n    verts.indices.push([0,1,2]);\n    verts.indices.push([0,2,3]);\n    return verts;\n  }\n\n  setUVToPositions(textureTransform?:Mat3){\n    textureTransform = textureTransform??new Mat3();\n    this.initUVAttribute()\n    for(let vi=0;vi<this.length;vi++){\n      // let pi = this.position.getAt(vi);\n      // let uvval = textureTransform.times(V3(pi.x,pi.y,1).plus(V3(1.5,0.5,0)));\n      // this.uv.push(uvval.Point2D);\n      this.uv.push(V2(0,0));\n    }\n  }\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}