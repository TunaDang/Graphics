{"ast":null,"code":"var _dec, _class;\nimport { ASerializable } from \"../../base\";\nimport { Vec2, Vec3, Mat3, Quaternion, V3, V2 } from \"../linalg\";\nimport { Precision } from \"../Precision\";\nimport { NodeTransform3D } from \"./NodeTransform3D\";\nexport let NodeTransform2D = (_dec = ASerializable(\"NodeTransform2D\"), _dec(_class = class NodeTransform2D {\n  /**\n   * Static function for getting the identity transform\n   * @returns {NodeTransform2D}\n   * @constructor\n   */\n  static Identity() {\n    return new this();\n  }\n  get scale() {\n    return this._scale;\n  }\n\n  /**\n   * if you set scale to a number (e.g., 'myTransform.scale = 2;`) it will automatically set all dimensions of the scale\n   * vector to that number to achieve uniform scaling. You can also set it to a vector for non-uniform scaling.\n   * @param value\n   */\n  set scale(value) {\n    if (value instanceof Vec2) {\n      this._scale = value;\n    } else {\n      this._scale = new Vec2(value, value);\n    }\n  }\n\n  /**\n   * Preferred method for initializing is to specify parameters\n   * @param position\n   * @param rotation\n   * @param scale\n   * @param anchor\n   */\n\n  /**\n   * You can optionally give it a matrix, but remember this is risky.\n   * @param matrix\n   * @param position\n   */\n\n  constructor(...args) {\n    /**\n     * The convention here is that a NodeTransform object parameterized transformations that can be expressed as a matrix\n     * product M = PRSA where:\n     * P is a translation by the vector defined in position\n     * R is a rotation by the angle defined in rotation\n     * S is a scale by the amounds stored in _scale\n     * A is a translation by the negative of the vector stored in anchor\n     *\n     * The translation by -anchor is a convention used in many animation tools. The reason for this is that if anchor\n     * indicates where the local origin of our object is moved, then the transform that performs this movement is\n     * actually a translation by -anchor.\n     *\n     * Notes:\n     * - This is an over-complete representation for matrices of this form. Most notably, it is possible to\n     * achieve the same transformation through changes to position or anchor. There is also a more subtle redundancy\n     * between scale and rotation.\n     * - Only a subset of valid 3x3 matrices can be represented this way. For this reason, initializing a NodeTransform\n     * with a matrix will result in an approximating projection of sorts. And, more generally, the transformation from\n     * matrix to NodeTransform is often not invertable. The transform from NodeTransform to matrix is usually invertable,\n     * but the inverse may be ambiguous due to the over-completeness.\n     */\n    this.position = void 0;\n    this.anchor = void 0;\n    this._scale = void 0;\n    this.rotation = void 0;\n    if (args[0] instanceof Mat3) {\n      let pos = args.length > 1 ? args[1] : undefined;\n      this.setWithMatrix(args[0], pos);\n      if (!this.position) {\n        this.position = new Vec2(0, 0);\n      }\n    } else {\n      var _args$, _args$2, _args$3, _args$4;\n      this.position = args.length > 0 ? (_args$ = args[0]) !== null && _args$ !== void 0 ? _args$ : V2(0, 0) : new Vec2(0, 0);\n      this.rotation = args.length > 1 ? (_args$2 = args[1]) !== null && _args$2 !== void 0 ? _args$2 : 0 : 0;\n      this.scale = args.length > 2 ? (_args$3 = args[2]) !== null && _args$3 !== void 0 ? _args$3 : V2(1, 1) : new Vec2(1, 1);\n      this.anchor = args.length > 3 ? (_args$4 = args[3]) !== null && _args$4 !== void 0 ? _args$4 : V2(0, 0) : new Vec2(0, 0);\n    }\n  }\n  static FromTransformationInterface(t) {\n    if (t === undefined) {\n      return new NodeTransform2D();\n    }\n    if (t instanceof NodeTransform2D) {\n      return t.clone();\n    } else {\n      return NodeTransform2D.FromMatrix(t);\n    }\n  }\n  getPosition() {\n    return Vec3.FromVec2(this.position);\n  }\n  _getQuaternionRotation() {\n    throw new Error(\"Method not implemented.\");\n  }\n  _setQuaternionRotation(q) {\n    throw new Error(\"Method not implemented.\");\n  }\n  setPosition(position) {\n    this.position = position.xy;\n  }\n  clone() {\n    return new NodeTransform2D(this.position.clone(), this.rotation, this.scale.clone(), this.anchor.clone());\n  }\n\n  /**\n   * Returns the transformation matrix for this set of transform properties.\n   *\n   * @returns the transformation matrix\n   */\n  getMatrix() {\n    const position = Mat3.Translation2D(this.position);\n    const rotation = Mat3.Rotation(this.rotation);\n    const scale = Mat3.Scale2D(this.scale);\n    const anchor = Mat3.Translation2D(this.anchor.times(-1));\n    return position.times(rotation).times(scale).times(anchor);\n  }\n  getMat4() {\n    return this.getMatrix().Mat4From2DH();\n  }\n  static FromMatrix(m, position, useOldRotation) {\n    let newNT = new NodeTransform2D();\n    newNT.setWithMatrix(m, position, useOldRotation);\n    return newNT;\n  }\n\n  /**\n   * Sets the transform properties based on the given affine transformation\n   * matrix and optional position.\n   *\n   * This function should set the transform based on an input matrix and\n   * (optionally) a starting position. Calling T.getMatrix() on the resulting\n   * transform should produce the input matrix `m`. Position should\n   * be the point where changes to rotation or scale will rotate and scale around.\n   * Meanings of position, rotation, scale, and anchor match those used in Adobe\n   * standards (e.g., After Effects). The corresponding matrix is calculated\n   * as shown in getMatrix() above: (P)*(R)*(S)*(-A). Position is specified as\n   * a constraint because the two translations in the above equation create a\n   * redundancy.\n   *\n   * We recommend familiarizing yourself with the available methods in\n   * `src/anigraph/amath/Mat3.ts`.\n   *\n   * Also familiarize yourself with the available functions in\n   * `src/anigraph/amath/Precision.ts`. These are useful when dealing with\n   * floating point inaccuracies and other small numbers.\n   *\n   * Note: do not let the scale factor be less than epsilon.\n   *\n   * @param m the affine transformation matrix\n   * @param position the starting positon\n   */\n  setWithMatrix(m, position, useOldRotation) {\n    // throw new Error(\"setWithMatrix not implemented yet! Wait for assignment 2!\")\n\n    //TODO: Don't leave this in!\n    const ex = new Vec3(1, 0, 0);\n    const ey = new Vec3(0, 1, 0);\n    if (position !== undefined) {\n      this.position = position;\n    } else {\n      this.position = m.times(V3(0.0, 0.0, 1.0)).xy;\n    }\n    if (!useOldRotation) {\n      const Mex = m.times(ex);\n      this.rotation = Math.atan2(Mex.y, Mex.x);\n    }\n    const noRo = Mat3.Rotation(-this.rotation).times(m);\n    const scaleX = noRo.times(ex);\n    const scaleY = noRo.times(ey);\n    this.scale = new Vec2(Precision.ClampAbsAboveEpsilon(scaleX.x), Precision.ClampAbsAboveEpsilon(scaleY.y));\n    var ORSinv = Mat3.Translation2D(this.position).times(Mat3.Rotation(this.rotation).times(Mat3.Scale2D(this.scale))).getInverse();\n    if (ORSinv === null) {\n      throw new Error(`tried to set transform with matrix that has zero determinant: ${m}`);\n      return;\n    }\n    this.anchor = ORSinv.times(m).times(Vec3.From2DHPoint(new Vec2(0, 0))).Point2D.times(-1);\n  }\n  NodeTransform3D() {\n    let rval = new NodeTransform3D(new Vec3(this.position.x, this.position.y, 0), Quaternion.FromAxisAngle(new Vec3(0, 0, 1), this.rotation), new Vec3(this.scale.x, this.scale.y, 1), new Vec3(this.anchor.x, this.anchor.y, 0));\n    return rval;\n  }\n  NodeTransform2D() {\n    return this;\n  }\n  assignTo(threejsMat) {\n    this.getMat4().assignTo(threejsMat);\n  }\n}) || _class);","map":{"version":3,"names":["ASerializable","Vec2","Vec3","Mat3","Quaternion","V3","V2","Precision","NodeTransform3D","NodeTransform2D","_dec","_class","Identity","scale","_scale","value","constructor","args","position","anchor","rotation","pos","length","undefined","setWithMatrix","_args$","_args$2","_args$3","_args$4","FromTransformationInterface","t","clone","FromMatrix","getPosition","FromVec2","_getQuaternionRotation","Error","_setQuaternionRotation","q","setPosition","xy","getMatrix","Translation2D","Rotation","Scale2D","times","getMat4","Mat4From2DH","m","useOldRotation","newNT","ex","ey","Mex","Math","atan2","y","x","noRo","scaleX","scaleY","ClampAbsAboveEpsilon","ORSinv","getInverse","From2DHPoint","Point2D","rval","FromAxisAngle","assignTo","threejsMat"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/math/nodetransforms/NodeTransform2D.ts"],"sourcesContent":["import { ASerializable } from \"../../base\";\nimport { NodeTransform } from \"./NodeTransform\";\nimport {Vec2, Vec3, Mat3, Mat4, Quaternion, V4, V3, V2} from \"../linalg\";\nimport { Precision } from \"../Precision\";\nimport { NodeTransform3D } from \"./NodeTransform3D\";\nimport {TransformationInterface} from \"../TrasnformationInterface\";\n\n@ASerializable(\"NodeTransform2D\")\nexport class NodeTransform2D implements NodeTransform<Vec2, Mat3> {\n  /**\n   * The convention here is that a NodeTransform object parameterized transformations that can be expressed as a matrix\n   * product M = PRSA where:\n   * P is a translation by the vector defined in position\n   * R is a rotation by the angle defined in rotation\n   * S is a scale by the amounds stored in _scale\n   * A is a translation by the negative of the vector stored in anchor\n   *\n   * The translation by -anchor is a convention used in many animation tools. The reason for this is that if anchor\n   * indicates where the local origin of our object is moved, then the transform that performs this movement is\n   * actually a translation by -anchor.\n   *\n   * Notes:\n   * - This is an over-complete representation for matrices of this form. Most notably, it is possible to\n   * achieve the same transformation through changes to position or anchor. There is also a more subtle redundancy\n   * between scale and rotation.\n   * - Only a subset of valid 3x3 matrices can be represented this way. For this reason, initializing a NodeTransform\n   * with a matrix will result in an approximating projection of sorts. And, more generally, the transformation from\n   * matrix to NodeTransform is often not invertable. The transform from NodeTransform to matrix is usually invertable,\n   * but the inverse may be ambiguous due to the over-completeness.\n   */\n  public position!: Vec2;\n  public anchor!: Vec2;\n  public _scale!: Vec2;\n  public rotation!: number;\n\n  /**\n   * Static function for getting the identity transform\n   * @returns {NodeTransform2D}\n   * @constructor\n   */\n  static Identity(){\n    return new this();\n  }\n\n  get scale(): Vec2 {\n    return this._scale;\n  }\n\n  /**\n   * if you set scale to a number (e.g., 'myTransform.scale = 2;`) it will automatically set all dimensions of the scale\n   * vector to that number to achieve uniform scaling. You can also set it to a vector for non-uniform scaling.\n   * @param value\n   */\n  set scale(value: Vec2 | number) {\n    if (value instanceof Vec2) {\n      this._scale = value;\n    } else {\n      this._scale = new Vec2(value, value);\n    }\n  }\n\n  /**\n   * Preferred method for initializing is to specify parameters\n   * @param position\n   * @param rotation\n   * @param scale\n   * @param anchor\n   */\n  constructor(position?: Vec2, rotation?: number, scale?: Vec2, anchor?: Vec2);\n  /**\n   * You can optionally give it a matrix, but remember this is risky.\n   * @param matrix\n   * @param position\n   */\n  constructor(matrix: Mat3, position?: Vec2);\n  constructor(...args: any[]) {\n    if (args[0] instanceof Mat3) {\n      let pos = args.length > 1 ? args[1] : undefined;\n      this.setWithMatrix(args[0], pos);\n      if (!this.position) {\n        this.position = new Vec2(0, 0);\n      }\n    } else {\n      this.position = (args.length > 0) ? args[0]?? V2(0, 0): new Vec2(0, 0);\n      this.rotation = (args.length > 1) ? args[1]?? 0 : 0;\n      this.scale = (args.length > 2) ? args[2]?? V2(1, 1): new Vec2(1, 1);\n      this.anchor = (args.length > 3) ? args[3]?? V2(0, 0): new Vec2(0, 0);\n    }\n  }\n\n  static FromTransformationInterface(t?:TransformationInterface){\n    if(t===undefined){\n      return new NodeTransform2D();\n    }\n    if(t instanceof NodeTransform2D){\n      return t.clone()\n    }else{\n      return NodeTransform2D.FromMatrix(t as Mat3);\n    }\n  }\n\n  getPosition(): Vec3 {\n    return Vec3.FromVec2(this.position);\n  }\n  _getQuaternionRotation(): Quaternion {\n    throw new Error(\"Method not implemented.\");\n    }\n  _setQuaternionRotation(q: Quaternion): void {\n    throw new Error(\"Method not implemented.\");\n  }\n  setPosition(position: Vec3): void {\n    this.position = position.xy;\n  }\n\n  clone() {\n    return new NodeTransform2D(\n      this.position.clone(),\n      this.rotation,\n      this.scale.clone(),\n      this.anchor.clone()\n    );\n  }\n\n  /**\n   * Returns the transformation matrix for this set of transform properties.\n   *\n   * @returns the transformation matrix\n   */\n  getMatrix() {\n    const position = Mat3.Translation2D(this.position);\n    const rotation = Mat3.Rotation(this.rotation);\n    const scale = Mat3.Scale2D(this.scale);\n    const anchor = Mat3.Translation2D(this.anchor.times(-1));\n    return position.times(rotation).times(scale).times(anchor);\n  }\n\n  getMat4(): Mat4 {\n    return this.getMatrix().Mat4From2DH();\n  }\n\n  static FromMatrix(m:Mat3, position?:Vec2, useOldRotation?:boolean){\n    let newNT = new NodeTransform2D();\n    newNT.setWithMatrix(m, position, useOldRotation);\n    return newNT;\n  }\n\n\n  /**\n   * Sets the transform properties based on the given affine transformation\n   * matrix and optional position.\n   *\n   * This function should set the transform based on an input matrix and\n   * (optionally) a starting position. Calling T.getMatrix() on the resulting\n   * transform should produce the input matrix `m`. Position should\n   * be the point where changes to rotation or scale will rotate and scale around.\n   * Meanings of position, rotation, scale, and anchor match those used in Adobe\n   * standards (e.g., After Effects). The corresponding matrix is calculated\n   * as shown in getMatrix() above: (P)*(R)*(S)*(-A). Position is specified as\n   * a constraint because the two translations in the above equation create a\n   * redundancy.\n   *\n   * We recommend familiarizing yourself with the available methods in\n   * `src/anigraph/amath/Mat3.ts`.\n   *\n   * Also familiarize yourself with the available functions in\n   * `src/anigraph/amath/Precision.ts`. These are useful when dealing with\n   * floating point inaccuracies and other small numbers.\n   *\n   * Note: do not let the scale factor be less than epsilon.\n   *\n   * @param m the affine transformation matrix\n   * @param position the starting positon\n   */\n  setWithMatrix(m: Mat3, position?: Vec2, useOldRotation?: boolean) {\n    // throw new Error(\"setWithMatrix not implemented yet! Wait for assignment 2!\")\n\n    //TODO: Don't leave this in!\n    const ex = new Vec3(1,0,0);\n    const ey = new Vec3(0,1,0);\n\n    if (position !== undefined) {\n      this.position = position;\n    }else{\n      this.position = m.times(V3(0.0,0.0,1.0)).xy;\n    }\n\n    if(!useOldRotation) {\n      const Mex = m.times(ex);\n      this.rotation = Math.atan2(Mex.y, Mex.x);\n    }\n\n    const noRo = Mat3.Rotation(-this.rotation).times(m);\n    const scaleX = noRo.times(ex);\n    const scaleY = noRo.times(ey);\n    this.scale = new Vec2(Precision.ClampAbsAboveEpsilon(scaleX.x), Precision.ClampAbsAboveEpsilon(scaleY.y));\n\n    var ORSinv = Mat3.Translation2D(this.position).times(\n        Mat3.Rotation(this.rotation).times(\n            Mat3.Scale2D(this.scale)\n        )\n    ).getInverse();\n\n    if(ORSinv===null){\n      throw new Error(`tried to set transform with matrix that has zero determinant: ${m}`);\n      return;\n    }\n    this.anchor = ORSinv.times(m).times(Vec3.From2DHPoint(new Vec2(0,0))).Point2D.times(-1);\n  }\n\n  NodeTransform3D() {\n    let rval = new NodeTransform3D(\n      new Vec3(this.position.x, this.position.y, 0),\n      Quaternion.FromAxisAngle(new Vec3(0, 0, 1), this.rotation),\n      new Vec3(this.scale.x, this.scale.y, 1),\n      new Vec3(this.anchor.x, this.anchor.y, 0)\n    );\n    return rval;\n  }\n\n  NodeTransform2D() {\n    return this;\n  }\n\n  assignTo(threejsMat: THREE.Matrix4) {\n    this.getMat4().assignTo(threejsMat);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}