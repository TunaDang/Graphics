{"ast":null,"code":"import { AAppState, CheckAAppState, SetAppState, AMaterialManager, DefaultMaterials, AMaterialModelBase } from \"../index\";\nimport { AGLRenderWindow } from \"../index\";\nvar AppStateEnums = /*#__PURE__*/function (AppStateEnums) {\n  AppStateEnums[\"MAIN_RENDER_WINDOW\"] = \"mainWindow\";\n  AppStateEnums[\"SECOND_RENDER_WINDOW\"] = \"secondWindow\";\n  return AppStateEnums;\n}(AppStateEnums || {});\nexport class AppState extends AAppState {\n  constructor(sceneModel) {\n    super();\n    this.sceneModel = void 0;\n    this.materials = void 0;\n    this.renderWindows = {};\n    this._getReactGUIContent = void 0;\n    this._getReactGUIBottomContent = void 0;\n    this.sceneModel = sceneModel;\n    this.materials = new AMaterialManager();\n  }\n  getReactGUIContent() {\n    if (this._getReactGUIContent !== undefined) {\n      return this._getReactGUIContent({\n        appState: this\n      });\n    } else {\n      return undefined;\n    }\n  }\n  getReactGUIBottomContent() {\n    if (this._getReactGUIBottomContent !== undefined) {\n      return this._getReactGUIBottomContent({\n        appState: this\n      });\n    } else {\n      return undefined;\n    }\n  }\n  setReactGUIContentFunction(func) {\n    this._getReactGUIContent = func;\n  }\n  setReactGUIBottomContentFunction(func) {\n    this._getReactGUIBottomContent = func;\n  }\n  get mainRenderWindow() {\n    return this.renderWindows[AppStateEnums.MAIN_RENDER_WINDOW];\n  }\n  getRenderWindow(key) {\n    return this.renderWindows[key];\n  }\n  createMainRenderWindow(controllerClass) {\n    this.createRenderWindow(AppStateEnums.MAIN_RENDER_WINDOW, controllerClass);\n  }\n  getSceneController(name) {\n    return this.renderWindows[name].sceneController;\n  }\n  get mainSceneController() {\n    return this.getSceneController(AppStateEnums.MAIN_RENDER_WINDOW);\n  }\n  async confirmInitialized() {\n    const self = this;\n    for (let window_name in this.renderWindows) {\n      await self.renderWindows[window_name].sceneController.confirmInitialized();\n    }\n    return self.initMutex.runExclusive(async () => {\n      self.init();\n    });\n  }\n  updateComponents() {\n    this.sceneModel.signalComponentUpdate();\n  }\n  addComponentUpdateListener(callback, handle) {\n    return this.sceneModel.addComponentUpdateListener(callback, handle);\n  }\n  createRenderWindow(name, controllerClass) {\n    let sceneController = new controllerClass(this.sceneModel);\n    this.renderWindows[name] = new AGLRenderWindow(sceneController);\n    return this.renderWindows[name];\n  }\n\n  /**\n   * You can just provide SHADERNAME, where the shaders are in public/shaders/SHADERNAME/SHADERNAME.vert.glsl\n   * and public/shaders/SHADERNAME/SHADERNAME.frag.glsl\n   * @param name\n   * @returns {Promise<void>}\n   */\n  async loadShaderMaterialModel(name) {\n    return this.materials.loadShaderModel(name);\n  }\n  async loadLineShaderMaterialModel(name) {\n    return this.materials.loadLineShaderModel(name);\n  }\n  async addShaderMaterialModel(name, m, ...args) {\n    if (m instanceof AMaterialModelBase) {\n      return this.setMaterialModel(name, m);\n    } else {\n      let model = await m.CreateModel(name, ...args);\n      return this.setMaterialModel(name, model);\n    }\n  }\n  async setMaterialModel(name, m) {\n    return this.materials.setMaterialModel(name, m);\n  }\n  getShaderMaterialModel(name) {\n    return this.materials.getShaderMaterialModel(name);\n  }\n  CreateMaterial(modelName, ...args) {\n    return this.materials.getMaterialModel(modelName).CreateMaterial(...args);\n  }\n  CreateBasicMaterial(color) {\n    let basic = this.materials.getMaterialModel(DefaultMaterials.Basic).CreateMaterial();\n    if (color) {\n      basic.setValue(\"color\", color.asThreeJS());\n    }\n    return basic;\n  }\n  CreateShaderMaterial(modelName, ...args) {\n    return this.materials.getMaterialModel(modelName).CreateMaterial(...args);\n  }\n}\nexport function CreateAppState(sceneModel) {\n  let appState = CheckAAppState();\n  if (appState === undefined) {\n    appState = new AppState(sceneModel);\n    SetAppState(appState);\n  } else {\n    console.warn(`ALREADY HAVE APP STATE!\\n${appState}`);\n    SetAppState(appState);\n  }\n  return appState;\n}\n\n// // TO_DO: APP STATE FIX / MERGE!!!\n// export class AppState extends AObject implements ConfirmInitialized{\n//     static enums = AppStateEnums;\n//     @AObjectState columnSize:number;\n//     _initMutex:Mutex;\n//     renderWindows:{[name:string]:AGLRenderWindow}={};\n//     sceneModel:ASceneModel;\n//\n//     constructor(){\n//         super();\n//         this._initMutex = new Mutex();\n//         this.columnSize=6;\n//         this.sceneModel = new A0SceneModel();\n//     }\n//\n//\n//     get mainRenderWindow(){\n//         return this.renderWindows[AppState.enums.MAIN_RENDER_WINDOW];\n//     }\n//     get secondRenderWindow(){\n//         return this.renderWindows[AppState.enums.SECOND_RENDER_WINDOW];\n//     }\n//\n//     createMainRenderWindow(controllerClass:ClassInterface<ASceneController>){\n//         this.addRenderWindow(AppState.enums.MAIN_RENDER_WINDOW, controllerClass);\n//     }\n//\n//     createSecondRenderWindow(controllerClass:ClassInterface<ASceneController>){\n//         this.addRenderWindow(AppState.enums.SECOND_RENDER_WINDOW, controllerClass);\n//     }\n//\n//     addRenderWindow(name:string, controllerClass:ClassInterface<ASceneController>){\n//         let sceneController = new controllerClass(this.sceneModel);\n//         this.renderWindows[name]= new AGLRenderWindow(sceneController);\n//     }\n//\n//     getSceneController(name:string){\n//         return this.renderWindows[name].sceneController;\n//     }\n//\n//     init(){\n//         console.log(\"Initializing App State!\")\n//     }\n//\n//     get initMutex(){\n//         return this._initMutex;\n//     }\n//     async confirmInitialized(){\n//         const self = this;\n//         for(let window_name in this.renderWindows){\n//             await self.renderWindows[window_name].sceneController.confirmInitialized();\n//         }\n//         return self.initMutex.runExclusive(async () => {\n//             self.init();\n//         });\n//     }\n//\n//     updateComponents(){\n//         this.sceneModel.signalComponentUpdate();\n//     }\n//\n//     addComponentUpdateListener(callback:(self:AObject)=>void, handle?:string):ACallbackSwitch{\n//         return this.sceneModel.addComponentUpdateListener(callback, handle);\n//     }\n// }\n_c = CreateAppState;\nvar _c;\n$RefreshReg$(_c, \"CreateAppState\");","map":{"version":3,"names":["AAppState","CheckAAppState","SetAppState","AMaterialManager","DefaultMaterials","AMaterialModelBase","AGLRenderWindow","AppStateEnums","AppState","constructor","sceneModel","materials","renderWindows","_getReactGUIContent","_getReactGUIBottomContent","getReactGUIContent","undefined","appState","getReactGUIBottomContent","setReactGUIContentFunction","func","setReactGUIBottomContentFunction","mainRenderWindow","MAIN_RENDER_WINDOW","getRenderWindow","key","createMainRenderWindow","controllerClass","createRenderWindow","getSceneController","name","sceneController","mainSceneController","confirmInitialized","self","window_name","initMutex","runExclusive","init","updateComponents","signalComponentUpdate","addComponentUpdateListener","callback","handle","loadShaderMaterialModel","loadShaderModel","loadLineShaderMaterialModel","loadLineShaderModel","addShaderMaterialModel","m","args","setMaterialModel","model","CreateModel","getShaderMaterialModel","CreateMaterial","modelName","getMaterialModel","CreateBasicMaterial","color","basic","Basic","setValue","asThreeJS","CreateShaderMaterial","CreateAppState","console","warn","_c","$RefreshReg$"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/appstate/AppState.ts"],"sourcesContent":["import {\n    AAppState,\n    ACallbackSwitch,\n    ASceneController,\n    ASceneModel,\n    CheckAAppState,\n    ClassInterface,\n    SetAppState,\n    AMaterialManager,\n    GetAAppState,\n    AShaderMaterial,\n    Color,\n    DefaultMaterials,\n    AMaterialModelBase,\n    AMaterialModel, ABasicMaterialModel, AShaderModel\n} from \"../index\";\nimport {AGLRenderWindow} from \"../index\";\nimport {AHandlesEvents} from \"../base/aobject/AHandlesEvents\";\nimport { ABlinnPhongShaderModel } from \"../rendering/shadermodels\";\n\nenum AppStateEnums{\n    MAIN_RENDER_WINDOW=\"mainWindow\",\n    SECOND_RENDER_WINDOW=\"secondWindow\"\n}\n\ninterface CreatesShaderModels{\n    CreateModel:(...args:any[])=>ABlinnPhongShaderModel;\n}\n\nexport class AppState extends AAppState{\n    sceneModel:ASceneModel;\n    materials:AMaterialManager;\n    renderWindows:{[name:string]:AGLRenderWindow}={};\n    constructor(sceneModel:ASceneModel) {\n        super();\n        this.sceneModel = sceneModel;\n        this.materials = new AMaterialManager();\n    }\n\n\n    _getReactGUIContent!:(props:{appState:AppState})=>any;\n    _getReactGUIBottomContent!:(props:{appState:AppState})=>any;\n\n    getReactGUIContent(){\n        if(this._getReactGUIContent !== undefined){\n            return this._getReactGUIContent({appState: this});\n        }else{\n            return undefined;\n        }\n    }\n\n    getReactGUIBottomContent(){\n        if(this._getReactGUIBottomContent !== undefined){\n            return this._getReactGUIBottomContent({appState: this});\n        }else{\n            return undefined;\n        }\n    }\n\n    setReactGUIContentFunction(func:(props:{appState:any})=>any){\n        this._getReactGUIContent=func;\n    }\n\n    setReactGUIBottomContentFunction(func:(props:{appState:any})=>any){\n        this._getReactGUIBottomContent=func;\n    }\n\n    get mainRenderWindow(){\n        return this.renderWindows[AppStateEnums.MAIN_RENDER_WINDOW];\n    }\n    getRenderWindow(key:string){\n        return this.renderWindows[key];\n    }\n\n    createMainRenderWindow(controllerClass:ClassInterface<ASceneController>){\n        this.createRenderWindow(AppStateEnums.MAIN_RENDER_WINDOW, controllerClass);\n    }\n\n    getSceneController(name:string){\n        return this.renderWindows[name].sceneController;\n    }\n\n    get mainSceneController(){\n        return this.getSceneController(AppStateEnums.MAIN_RENDER_WINDOW);\n    }\n\n    async confirmInitialized(){\n        const self = this;\n        for(let window_name in this.renderWindows){\n            await self.renderWindows[window_name].sceneController.confirmInitialized();\n        }\n        return self.initMutex.runExclusive(async () => {\n            self.init();\n        });\n    }\n\n\n    updateComponents(){\n        this.sceneModel.signalComponentUpdate();\n    }\n\n    addComponentUpdateListener(callback:(self:AHandlesEvents)=>void, handle?:string):ACallbackSwitch{\n        return this.sceneModel.addComponentUpdateListener(callback, handle);\n    }\n\n\n    createRenderWindow(name:string, controllerClass:ClassInterface<ASceneController>){\n        let sceneController = new controllerClass(this.sceneModel);\n        this.renderWindows[name]= new AGLRenderWindow(sceneController);\n        return this.renderWindows[name];\n    }\n\n    /**\n     * You can just provide SHADERNAME, where the shaders are in public/shaders/SHADERNAME/SHADERNAME.vert.glsl\n     * and public/shaders/SHADERNAME/SHADERNAME.frag.glsl\n     * @param name\n     * @returns {Promise<void>}\n     */\n    async loadShaderMaterialModel(name:string){\n        return this.materials.loadShaderModel(name);\n    }\n    async loadLineShaderMaterialModel(name:string){\n        return this.materials.loadLineShaderModel(name);\n    }\n\n    async addShaderMaterialModel(name:string, m:AMaterialModelBase<any>|typeof AShaderModel, ...args:any[]){\n        if(m instanceof AMaterialModelBase<any>){\n            return this.setMaterialModel(name, m);\n        }else{\n            let model = await (m as typeof AShaderModel).CreateModel(name, ...args);\n            return this.setMaterialModel(name, model);\n        }\n    }\n\n    async setMaterialModel(name:string, m:AMaterialModelBase<any>){\n        return this.materials.setMaterialModel(name, m);\n    }\n\n    getShaderMaterialModel(name:string){\n        return this.materials.getShaderMaterialModel(name);\n    }\n\n\n\n    CreateMaterial(modelName:string, ...args:any[]){\n        return this.materials.getMaterialModel(modelName).CreateMaterial(...args);\n    }\n\n    CreateBasicMaterial(color?:Color){\n        let basic = this.materials.getMaterialModel(DefaultMaterials.Basic).CreateMaterial();\n        if(color) {\n            basic.setValue(\"color\", color.asThreeJS());\n        }\n        return basic;\n    }\n\n    CreateShaderMaterial(modelName:string, ...args:any[]):AShaderMaterial{\n        return this.materials.getMaterialModel(modelName).CreateMaterial(...args) as AShaderMaterial;\n    }\n}\n\n\nexport function CreateAppState(sceneModel:ASceneModel):AppState{\n    let appState = CheckAAppState() as AppState;\n    if(appState===undefined){\n        appState = new AppState(sceneModel);\n        SetAppState(appState);\n    }else{\n        console.warn(`ALREADY HAVE APP STATE!\\n${appState}`)\n        SetAppState(appState);\n    }\n    return appState;\n}\n\n\n\n\n\n// // TO_DO: APP STATE FIX / MERGE!!!\n// export class AppState extends AObject implements ConfirmInitialized{\n//     static enums = AppStateEnums;\n//     @AObjectState columnSize:number;\n//     _initMutex:Mutex;\n//     renderWindows:{[name:string]:AGLRenderWindow}={};\n//     sceneModel:ASceneModel;\n//\n//     constructor(){\n//         super();\n//         this._initMutex = new Mutex();\n//         this.columnSize=6;\n//         this.sceneModel = new A0SceneModel();\n//     }\n//\n//\n//     get mainRenderWindow(){\n//         return this.renderWindows[AppState.enums.MAIN_RENDER_WINDOW];\n//     }\n//     get secondRenderWindow(){\n//         return this.renderWindows[AppState.enums.SECOND_RENDER_WINDOW];\n//     }\n//\n//     createMainRenderWindow(controllerClass:ClassInterface<ASceneController>){\n//         this.addRenderWindow(AppState.enums.MAIN_RENDER_WINDOW, controllerClass);\n//     }\n//\n//     createSecondRenderWindow(controllerClass:ClassInterface<ASceneController>){\n//         this.addRenderWindow(AppState.enums.SECOND_RENDER_WINDOW, controllerClass);\n//     }\n//\n//     addRenderWindow(name:string, controllerClass:ClassInterface<ASceneController>){\n//         let sceneController = new controllerClass(this.sceneModel);\n//         this.renderWindows[name]= new AGLRenderWindow(sceneController);\n//     }\n//\n//     getSceneController(name:string){\n//         return this.renderWindows[name].sceneController;\n//     }\n//\n//     init(){\n//         console.log(\"Initializing App State!\")\n//     }\n//\n//     get initMutex(){\n//         return this._initMutex;\n//     }\n//     async confirmInitialized(){\n//         const self = this;\n//         for(let window_name in this.renderWindows){\n//             await self.renderWindows[window_name].sceneController.confirmInitialized();\n//         }\n//         return self.initMutex.runExclusive(async () => {\n//             self.init();\n//         });\n//     }\n//\n//     updateComponents(){\n//         this.sceneModel.signalComponentUpdate();\n//     }\n//\n//     addComponentUpdateListener(callback:(self:AObject)=>void, handle?:string):ACallbackSwitch{\n//         return this.sceneModel.addComponentUpdateListener(callback, handle);\n//     }\n// }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}