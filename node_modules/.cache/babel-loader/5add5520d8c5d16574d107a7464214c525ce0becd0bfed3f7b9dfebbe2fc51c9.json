{"ast":null,"code":"import _initializerDefineProperty from \"/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js\";\nimport _applyDecoratedDescriptor from \"/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js\";\nimport _initializerWarningHelper from \"/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js\";\nvar _class, _descriptor, _descriptor2, _descriptor3, _ANodeModel;\nimport { AObjectState } from \"../../base\";\nimport { AModel } from \"../../base\";\nimport { AGeometrySet } from \"../../geometry\";\nimport { AMaterial } from \"../../rendering\";\nconst MATERIAL_UPDATE_SUBSCRIPTION_HANDLE = 'MATERIAL_UPDATE_SUBSCRIPTION_NodeModel';\nvar ANodeModelEvents = /*#__PURE__*/function (ANodeModelEvents) {\n  ANodeModelEvents[\"GEOMETRY_UPDATE\"] = \"GEOMETRY_UPDATE\";\n  ANodeModelEvents[\"TRANSFORM_UPDATE\"] = \"TRANSFORM_UPDATE\";\n  ANodeModelEvents[\"TEXTURE_UPDATE\"] = \"TEXTURE_UPDATE\";\n  ANodeModelEvents[\"COLOR_UPDATE\"] = \"COLOR_UPDATE\";\n  return ANodeModelEvents;\n}(ANodeModelEvents || {});\nexport let ANodeModel = (_class = (_ANodeModel = class ANodeModel extends AModel {\n  /** Get set visible */\n  set visible(value) {\n    this._visible = value;\n  }\n  get visible() {\n    return this._visible;\n  }\n  get geometry() {\n    return this._geometry;\n  }\n  get material() {\n    return this._material;\n  }\n\n  //###############################################//--Tags--\\\\###############################################\n  //<editor-fold desc=\"Tags\">\n\n  getNodeTags() {\n    return this._nodeTags;\n  }\n  addTag(tagName) {\n    this._nodeTags[tagName] = true;\n  }\n  setTagValue(tagName, value) {\n    this._nodeTags[tagName] = value;\n  }\n  hasTag(tagName) {\n    return tagName in this._nodeTags;\n  }\n  getTagValue(tagName) {\n    return this._nodeTags[tagName];\n  }\n  removeTag(tagName) {\n    delete this._nodeTags[tagName];\n  }\n  //</editor-fold>\n  //###############################################\\\\--Tags--//###############################################\n\n  constructor(...args) {\n    super();\n    /**\n     * Transform of the node model. This is generally its model matrix in the scene graph.\n     */\n    _initializerDefineProperty(this, \"_transform\", _descriptor, this);\n    _initializerDefineProperty(this, \"_visible\", _descriptor2, this);\n    this._geometry = void 0;\n    this._material = void 0;\n    _initializerDefineProperty(this, \"_nodeTags\", _descriptor3, this);\n    this._nodeTags = [];\n    this._geometry = new AGeometrySet();\n    this._visible = true;\n    this.signalGeometryUpdate = this.signalGeometryUpdate.bind(this);\n    this.signalTransformUpdate = this.signalTransformUpdate.bind(this);\n    const self = this;\n    this.subscribe(this.addStateKeyListener(\"_transform\", () => {\n      self.signalTransformUpdate();\n    }), \"NODE_TRANSFORM_UPDATE\");\n  }\n\n  //##################//--Listeners--\\\\##################\n  //<editor-fold desc=\"Listeners\">\n  /*\n          this.subscribe(this.addStateKeyListener(\"_transform\", ()=>{\n              self.signalTransformUpdate();\n          }), \"NODE_TRANSFORM_UPDATE\");\n      addTransformListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true):ACallbackSwitch{\n          return this.addStateKeyListener(\"_transform\", callback, handle, synchronous);\n  \n      }\n      signalTransformUpdate(){\n          this.signalEvent(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, this);\n      }\n   */\n\n  /**\n   * Implemented as event listener that triggers whenever state key changes. This is so that the transform can be delegated to some other object, like in the case of a ACameraModel delegating it to a camera\n   * @param callback\n   * @param handle\n   * @param synchronous\n   * @returns {AEventCallbackSwitch}\n   */\n  addTransformListener(callback, handle, synchronous = true) {\n    return this.addEventListener(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, callback, handle);\n  }\n  signalTransformUpdate() {\n    this.signalEvent(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, this);\n  }\n  addGeometryListener(callback, handle, synchronous = true) {\n    return this.addEventListener(ANodeModel.NodeModelEvents.GEOMETRY_UPDATE, callback, handle);\n  }\n  signalGeometryUpdate() {\n    this.signalEvent(ANodeModel.NodeModelEvents.GEOMETRY_UPDATE, this);\n  }\n  addVisibilityListener(callback, handle, synchronous = true) {\n    return this.addStateKeyListener(\"_visible\", callback, handle, synchronous);\n  }\n\n  // signalMaterialUpdate(){\n  //     this.signalEvent(ANodeModel.NodeModelEvents.MATERIAL_UPDATE, this);\n  // }\n  //</editor-fold>\n  //##################\\\\--Listeners--//##################\n\n  //###############################################//--Material Updates--\\\\###############################################\n  //<editor-fold desc=\"Material Updates\">\n  /**\n   * These are designed so that you can have the same material used for multiple objects. For this reason, we listen\n   * to the material directly for updates, which will trigger updates even if we change the material elsewhere in code.\n   */\n  addMaterialUpdateListener(callback, handle) {\n    return this.addEventListener(AMaterial.Events.UPDATE, callback, handle);\n  }\n  addMaterialChangeListener(callback, handle) {\n    return this.addEventListener(AMaterial.Events.CHANGE, callback, handle);\n  }\n  signalMaterialUpdate() {\n    this.signalEvent(AMaterial.Events.CHANGE);\n  }\n  setMaterialUpdateSubscriptions() {\n    const self = this;\n    this.subscribe(this.material.addEventListener(AMaterial.Events.UPDATE, (...args) => {\n      self.onMaterialUpdate(AMaterial.Events.UPDATE, ...args);\n    }), MATERIAL_UPDATE_SUBSCRIPTION_HANDLE);\n  }\n  onMaterialUpdate(...args) {\n    this.signalEvent(AMaterial.Events.UPDATE, ...args);\n  }\n  setMaterial(material) {\n    if (this.material === material) {\n      return;\n    } else {\n      let amaterial;\n      if (material instanceof AMaterial) {\n        amaterial = material;\n      } else {\n        throw new Error(\"Material from string not implemented yet. Should look up in MaterialManager.\");\n      }\n      if (this.material) {\n        this._disposeMaterial();\n      }\n      this._material = amaterial;\n      this.setMaterialUpdateSubscriptions();\n    }\n    this.signalMaterialUpdate();\n    // this.signalEvent(AMaterial.Events.CHANGE)\n  }\n  _disposeMaterial() {\n    this.unsubscribe(MATERIAL_UPDATE_SUBSCRIPTION_HANDLE);\n    this.material.release();\n  }\n  //</editor-fold>\n  //###############################################\\\\--Material Updates--//###############################################\n\n  timeUpdate(t, ...args) {}\n}, _ANodeModel.NodeModelEvents = ANodeModelEvents, _ANodeModel), _descriptor = _applyDecoratedDescriptor(_class.prototype, \"_transform\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"_visible\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"_nodeTags\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class);","map":{"version":3,"names":["AObjectState","AModel","AGeometrySet","AMaterial","MATERIAL_UPDATE_SUBSCRIPTION_HANDLE","ANodeModelEvents","ANodeModel","_class","_ANodeModel","visible","value","_visible","geometry","_geometry","material","_material","getNodeTags","_nodeTags","addTag","tagName","setTagValue","hasTag","getTagValue","removeTag","constructor","args","_initializerDefineProperty","_descriptor","_descriptor2","_descriptor3","signalGeometryUpdate","bind","signalTransformUpdate","self","subscribe","addStateKeyListener","addTransformListener","callback","handle","synchronous","addEventListener","NodeModelEvents","TRANSFORM_UPDATE","signalEvent","addGeometryListener","GEOMETRY_UPDATE","addVisibilityListener","addMaterialUpdateListener","Events","UPDATE","addMaterialChangeListener","CHANGE","signalMaterialUpdate","setMaterialUpdateSubscriptions","onMaterialUpdate","setMaterial","amaterial","Error","_disposeMaterial","unsubscribe","release","timeUpdate","t","_applyDecoratedDescriptor","prototype","configurable","enumerable","writable","initializer"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/scene/nodeModel/ANodeModel.ts"],"sourcesContent":["import {AObjectState, AObject, ACallbackSwitch, HasTags} from \"../../base\";\nimport {AModel} from \"../../base\";\nimport {AGeometrySet,\n    VertexArray\n} from \"../../geometry\";\nimport type {TransformationInterface} from \"../../math\";\nimport {AMaterial, AShaderMaterial} from \"../../rendering\";\n\n\nconst MATERIAL_UPDATE_SUBSCRIPTION_HANDLE = 'MATERIAL_UPDATE_SUBSCRIPTION_NodeModel';\nenum ANodeModelEvents{\n    GEOMETRY_UPDATE = \"GEOMETRY_UPDATE\",\n    TRANSFORM_UPDATE = \"TRANSFORM_UPDATE\",\n    TEXTURE_UPDATE=\"TEXTURE_UPDATE\",\n    COLOR_UPDATE=\"COLOR_UPDATE\"\n}\n\nexport abstract class ANodeModel extends AModel implements HasTags{\n    static NodeModelEvents = ANodeModelEvents;\n    /**\n     * Transform of the node model. This is generally its model matrix in the scene graph.\n     */\n    @AObjectState protected _transform!:TransformationInterface;\n\n    abstract get zValue():number;\n\n    @AObjectState _visible!:boolean;\n    /** Get set visible */\n    set visible(value:boolean){this._visible = value;}\n    get visible(){return this._visible;}\n    abstract get transform():TransformationInterface;\n    abstract setTransform(transform:TransformationInterface):void;\n\n\n    protected _geometry!:AGeometrySet;\n    get geometry(){return this._geometry;}\n    abstract get verts():VertexArray<any>;\n    abstract setVerts(verts:VertexArray<any>):void;\n    protected _material!:AMaterial;\n    get material():AShaderMaterial{return this._material as AShaderMaterial;}\n\n    //###############################################//--Tags--\\\\###############################################\n    //<editor-fold desc=\"Tags\">\n    @AObjectState _nodeTags!:{[tagName:string]:any};\n    protected getNodeTags(){return this._nodeTags;}\n    addTag(tagName:string){this._nodeTags[tagName]=true;}\n    setTagValue(tagName:string, value:any){this._nodeTags[tagName]=value;}\n    hasTag(tagName:string){return (tagName in this._nodeTags);}\n    getTagValue(tagName:string){return this._nodeTags[tagName];}\n    removeTag(tagName:string){delete this._nodeTags[tagName];}\n    //</editor-fold>\n    //###############################################\\\\--Tags--//###############################################\n\n\n    constructor(...args:any[]) {\n        super();\n        this._nodeTags = [];\n        this._geometry = new AGeometrySet();\n        this._visible = true;\n        this.signalGeometryUpdate = this.signalGeometryUpdate.bind(this);\n        this.signalTransformUpdate = this.signalTransformUpdate.bind(this);\n        const self = this;\n        this.subscribe(this.addStateKeyListener(\"_transform\", ()=>{\n            self.signalTransformUpdate();\n        }), \"NODE_TRANSFORM_UPDATE\");\n    }\n\n\n    //##################//--Listeners--\\\\##################\n    //<editor-fold desc=\"Listeners\">\n/*\n        this.subscribe(this.addStateKeyListener(\"_transform\", ()=>{\n            self.signalTransformUpdate();\n        }), \"NODE_TRANSFORM_UPDATE\");\n    addTransformListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true):ACallbackSwitch{\n        return this.addStateKeyListener(\"_transform\", callback, handle, synchronous);\n\n    }\n    signalTransformUpdate(){\n        this.signalEvent(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, this);\n    }\n */\n\n    /**\n     * Implemented as event listener that triggers whenever state key changes. This is so that the transform can be delegated to some other object, like in the case of a ACameraModel delegating it to a camera\n     * @param callback\n     * @param handle\n     * @param synchronous\n     * @returns {AEventCallbackSwitch}\n     */\n    addTransformListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true):ACallbackSwitch{\n        return this.addEventListener(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, callback, handle);\n    }\n    signalTransformUpdate(){\n        this.signalEvent(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, this);\n    }\n    addGeometryListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true){\n        return this.addEventListener(ANodeModel.NodeModelEvents.GEOMETRY_UPDATE, callback, handle);\n    }\n    signalGeometryUpdate(){\n        this.signalEvent(ANodeModel.NodeModelEvents.GEOMETRY_UPDATE, this);\n    }\n\n\n    addVisibilityListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true){\n        return this.addStateKeyListener(\"_visible\", callback, handle, synchronous);\n    }\n\n    // signalMaterialUpdate(){\n    //     this.signalEvent(ANodeModel.NodeModelEvents.MATERIAL_UPDATE, this);\n    // }\n    //</editor-fold>\n    //##################\\\\--Listeners--//##################\n\n    //###############################################//--Material Updates--\\\\###############################################\n    //<editor-fold desc=\"Material Updates\">\n    /**\n     * These are designed so that you can have the same material used for multiple objects. For this reason, we listen\n     * to the material directly for updates, which will trigger updates even if we change the material elsewhere in code.\n     */\n    addMaterialUpdateListener(callback:(...args:any[])=>void, handle?:string){\n        return this.addEventListener(AMaterial.Events.UPDATE, callback, handle);\n    }\n    addMaterialChangeListener(callback:(...args:any[])=>void, handle?:string){\n        return this.addEventListener(AMaterial.Events.CHANGE, callback, handle);\n    }\n\n    signalMaterialUpdate(){\n        this.signalEvent(AMaterial.Events.CHANGE);\n    }\n\n    setMaterialUpdateSubscriptions(){\n        const self = this;\n        this.subscribe(this.material.addEventListener(AMaterial.Events.UPDATE, (...args:any[])=>{\n            self.onMaterialUpdate(AMaterial.Events.UPDATE, ...args)\n        }), MATERIAL_UPDATE_SUBSCRIPTION_HANDLE);\n    }\n    onMaterialUpdate(...args:any[]){\n        this.signalEvent(AMaterial.Events.UPDATE, ...args);\n    }\n\n    setMaterial(material:AMaterial|string){\n        if(this.material === material){\n            return;\n        }else{\n            let amaterial:AMaterial;\n            if(material instanceof AMaterial){\n                amaterial=material;\n            }else{\n                throw new Error(\"Material from string not implemented yet. Should look up in MaterialManager.\")\n            }\n\n            if(this.material){\n                this._disposeMaterial()\n            }\n            this._material = amaterial;\n            this.setMaterialUpdateSubscriptions();\n        }\n        this.signalMaterialUpdate();\n        // this.signalEvent(AMaterial.Events.CHANGE)\n    }\n\n    _disposeMaterial(){\n        this.unsubscribe(MATERIAL_UPDATE_SUBSCRIPTION_HANDLE);\n        this.material.release();\n    }\n    //</editor-fold>\n    //###############################################\\\\--Material Updates--//###############################################\n\n    timeUpdate(t:number, ...args:any[]){\n\n    }\n\n\n\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}