{"ast":null,"code":"var _dec, _class, _SplineModel;\nimport { ASerializable, Color, Curve2DModel, CurveInterpolationModes, V2 } from \"../../../anigraph\";\nexport let SplineModel = (_dec = ASerializable(\"SplineModel\"), _dec(_class = (_SplineModel = class SplineModel extends Curve2DModel {\n  /**\n   * When the interpolation mode changes, we need to signal an update of the geometry.\n   * @param value\n   */\n  set interpolationMode(value) {\n    this._interpolationMode = value;\n    this.signalGeometryUpdate();\n  }\n  get interpolationMode() {\n    return this._interpolationMode;\n  }\n\n  /**\n   * Width/thickness of the control shape when it is visible\n   * @type {number}\n   */\n\n  /**\n   * The number of control points in our spline.\n   * This is simply the number of vertices in `this.verts`, which is a VertexArray2D inherited from `ANodeModel2D`,\n   * which is a parent class.\n   * @returns {number}\n   */\n  get nControlPoints() {\n    return this.verts.nVerts;\n  }\n  getControlPointLocation(index) {\n    return this.verts.getPoint2DAt(index);\n  }\n  getControlPointColor(index) {\n    return this.verts.color.getAt(index);\n  }\n\n  /**\n   * There are 4 point in a cubic Bezier segment, and when we chain segments together we typically use the last\n   * control point of each segment as the first control point of the subsequent segment.\n   *\n   * Here we give you a function that takes a segment index and returns the 4 corresponding control points.\n   * @param segmentIndex\n   * @returns {[Vec2, Vec2, Vec2, Vec2]}\n   */\n  getSegmentControlPoints(segmentIndex) {\n    let startHandle = segmentIndex * 3;\n    return [this.verts.getPoint2DAt(startHandle), this.verts.getPoint2DAt(startHandle + 1), this.verts.getPoint2DAt(startHandle + 2), this.verts.getPoint2DAt(startHandle + 3)];\n  }\n\n  /**\n   * Similar to `getSegmentControlPoints`, we give you a function to get the colors stored at each of the control\n   * points in the bezier segment with index `segmentIndex`.\n   * @param segmentIndex\n   * @returns {[Color, Color, Color, Color]}\n   */\n  getSegmentControlPointColors(segmentIndex) {\n    let startHandle = segmentIndex * 3;\n    return [this.verts.color.getAt(startHandle), this.verts.color.getAt(startHandle + 1), this.verts.color.getAt(startHandle + 2), this.verts.color.getAt(startHandle + 3)];\n  }\n\n  //###########################################//--Linear Interpolation--\\\\###########################################\n  //<editor-fold desc=\"Linear Interpolation\">\n\n  /**\n   * Returns a point `progress` along the linear interpolation of control points.\n   * Remember, only the first and last point in each segment are interpolated!\n   * @param progress\n   * @returns {Vec2}\n   */\n  getLinearInterpolationPoint(progress) {\n    if (this.nControlPoints < 2) {\n      return V2();\n    }\n    let currentIndex = progress * (this.nControlPoints - 2);\n    let tfloor = Math.floor(currentIndex);\n    let startControlPointIndex = tfloor;\n    let startControlPoint = this.verts.getPoint2DAt(startControlPointIndex);\n    let endControlPointIndex = Math.ceil(currentIndex);\n    let endControlPoint = this.verts.getPoint2DAt(endControlPointIndex);\n    let alpha = currentIndex - tfloor;\n\n    /**\n     * We've given you most of this function as an example of how to get control points by index.\n     * From here, you need to return a point that is interpolated `alpha` along the way from `startControlPoint` to\n     * `endControlPoint`...\n     */\n\n    throw new Error(\"getLinearInterpolationPoint not implemented!\");\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Colors can be represented as a vector of color channels. We can interpolate between these vectors in the same way\n   * we interpolate between the coordinate vector representations of spline control points.\n   *\n   * Hint: AniGraph's Color class represents a 4D vector with channels [red, green, blue, alpha], and is implemented\n   * as a subclass of VectorBase, which has element-wise `.plus()` and `.times()` operators, which can make\n   * implementing this function much shorter.\n   * @param progress\n   * @returns {VectorBase | Vec2}\n   */\n  getLinearInterpolationColor(progress) {\n    if (this.nControlPoints < 2) {\n      if (this.nControlPoints > 0) {\n        return this.verts.color.getAt(0);\n      } else {\n        return Color.FromString(\"#000000\");\n      }\n    }\n    throw new Error(\"getLinearInterpolationColor not implemented!\");\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Returns a unit vector pointed toward the linearly interpolated shape's positive tangent `progress` along the\n   * length of the shape. Make sure you still return a unit vector at control points, though we won't test you on\n   * the direction of vectors at control points.\n   * @param progress\n   * @returns {Vec2}\n   */\n  getLinearInterpolationVelocity(progress) {\n    if (this.nControlPoints < 2) {\n      return V2();\n    }\n    throw new Error(\"getLinearInterpolationVelocity not implemented!\");\n    // TODO: Replace the line above with your own code\n  }\n  //</editor-fold>\n  //###########################################\\\\--Linear Interpolation--//###########################################\n\n  //###############################################//--Cubic Bezier--\\\\###############################################\n  //<editor-fold desc=\"Cubic Bezier\">\n\n  /**\n   * The number of interpolated control points in the spline.\n   * Review the online documentation for the assignment to figure out how the number of interpolated control points relates to the total number of\n   * control points.\n   * @returns {number}\n   */\n  get nInterpolatedControlPoints() {\n    return this.nControlPoints;\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * The number of spline segments. This should also be a function of the number of control points.\n   * @returns {number}\n   */\n  get nBezierSegments() {\n    return Math.floor(this.nControlPoints / 3);\n    // TODO: Replace the line above with your own code\n  }\n  constructor() {\n    super();\n    /**\n     * Getter and setter for `interpolationMode`, which wraps the protected variable _interpolationMode holding the\n     * current interpolation mode for the spline.\n     * */\n    this._interpolationMode = CurveInterpolationModes.CubicBezier;\n    this.controlShapeWidth = 0.003;\n    /**\n     * Whether the control shape is visible.\n     * @type {boolean}\n     */\n    this.controlShapeVisible = true;\n  }\n\n  /**\n   * Progress of 0 should map to the first interpolated point of the spline. Progress of 1 should map to the last interpolated point.\n   * A segment index of `n` where `n` is an integer should map to the first interpolated point of the nth segment.\n   * values between n and n+1 should map linearly to progress along the nth segment.\n   * @param progress\n   * @returns {number}\n   */\n  continuousSegmentIndexForProgress(progress) {\n    return progress * this.nBezierSegments;\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Should return the control point index for the kth interpolated point.\n   * Remember that not every control point is an interpolated point.\n   * @param interpolatedPointIndex\n   * @returns {number}\n   */\n  getControlPointIndexForInterpolatedPoint(interpolatedPointIndex) {\n    throw new Error(\"Not Implemented!\");\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Returns the point `progress` along the bezier spline interpolation of the control points\n   * @param progress\n   * @returns {VectorBase | Vec2}\n   */\n  getCubicBezierInterpolationPoint(progress) {\n    if (this.nControlPoints < 4) {\n      return this.getLinearInterpolationPoint(progress);\n    }\n\n    //Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha here\n    throw new Error(\"Not Implemented!\");\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Returns the point `progress` along the bezier spline interpolation of the control points\n   * @param progress\n   * @returns {VectorBase | Vec2}\n   */\n  getCubicBezierInterpolatedColor(progress) {\n    if (this.nControlPoints < 4) {\n      return this.getLinearInterpolationColor(progress);\n    }\n    // Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha\n    throw new Error(\"Not Implemented!\");\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Returns the point `progress` along the bezier spline interpolation of the control points\n   * @param progress\n   * @returns {VectorBase | Vec2}\n   */\n  getCubicBezierVelocityVector(progress) {\n    if (this.nControlPoints < 4) {\n      return this.getLinearInterpolationVelocity(progress);\n    }\n    // Hint: you probably want to use GetCubicBezierSplineSegmentDerivativeForAlpha here\n    throw new Error(\"Not Implemented!\");\n    // TODO: Replace the line above with your own code\n  }\n  //</editor-fold>\n  //###############################################\\\\--Cubic Bezier--//###############################################\n\n  getPointForProgress(progress) {\n    switch (this.interpolationMode) {\n      case SplineModel.InterpolationModes.Linear:\n        return this.getLinearInterpolationPoint(progress);\n      case SplineModel.InterpolationModes.CubicBezier:\n        try {\n          return this.getCubicBezierInterpolationPoint(progress);\n        } catch (e) {\n          console.error(e);\n          return this.getLinearInterpolationPoint(progress);\n        }\n      default:\n        throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n    }\n  }\n  getDerivativeForProgress(progress) {\n    switch (this.interpolationMode) {\n      case SplineModel.InterpolationModes.Linear:\n        return this.getLinearInterpolationVelocity(progress);\n      case SplineModel.InterpolationModes.CubicBezier:\n        try {\n          return this.getCubicBezierVelocityVector(progress);\n        } catch (e) {\n          console.error(e);\n          return this.getLinearInterpolationVelocity(progress);\n        }\n      default:\n        throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n    }\n  }\n  getColorForProgress(progress) {\n    switch (this.interpolationMode) {\n      case SplineModel.InterpolationModes.Linear:\n        return this.getLinearInterpolationColor(progress);\n      case SplineModel.InterpolationModes.CubicBezier:\n        try {\n          return this.getCubicBezierInterpolatedColor(progress);\n        } catch (e) {\n          console.error(e);\n          return this.getLinearInterpolationColor(progress);\n        }\n      default:\n        throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n    }\n  }\n}, _SplineModel.InterpolationModes = CurveInterpolationModes, _SplineModel)) || _class);","map":{"version":3,"names":["ASerializable","Color","Curve2DModel","CurveInterpolationModes","V2","SplineModel","_dec","_class","_SplineModel","interpolationMode","value","_interpolationMode","signalGeometryUpdate","nControlPoints","verts","nVerts","getControlPointLocation","index","getPoint2DAt","getControlPointColor","color","getAt","getSegmentControlPoints","segmentIndex","startHandle","getSegmentControlPointColors","getLinearInterpolationPoint","progress","currentIndex","tfloor","Math","floor","startControlPointIndex","startControlPoint","endControlPointIndex","ceil","endControlPoint","alpha","Error","getLinearInterpolationColor","FromString","getLinearInterpolationVelocity","nInterpolatedControlPoints","nBezierSegments","constructor","CubicBezier","controlShapeWidth","controlShapeVisible","continuousSegmentIndexForProgress","getControlPointIndexForInterpolatedPoint","interpolatedPointIndex","getCubicBezierInterpolationPoint","getCubicBezierInterpolatedColor","getCubicBezierVelocityVector","getPointForProgress","InterpolationModes","Linear","e","console","error","getDerivativeForProgress","getColorForProgress"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/A1/nodes/Spline/SplineModel.ts"],"sourcesContent":["import {\n    ALineMaterialModel,\n    ANodeModel2D,\n    ASerializable,\n    Color, Curve2DModel, CurveInterpolationModes,\n    V2,\n    Vec2, Vector,\n    VectorBase,\n    VertexArray2D\n} from \"../../../anigraph\";\nimport {\n    GetCubicBezierSplineSegmentValueForAlpha,\n    GetCubicBezierSplineSegmentDerivativeForAlpha\n} from \"./CubicBezierFunctions\";\n\n\n@ASerializable(\"SplineModel\")\nexport class SplineModel extends Curve2DModel{\n\n    /**\n     * We will have two interpolation modes: Linear, and CubicBezier.\n     * These are set to the enum declared at the top of this file.\n     * @type {CurveInterpolationModes}\n     */\n    static InterpolationModes=CurveInterpolationModes;\n\n    /**\n     * Getter and setter for `interpolationMode`, which wraps the protected variable _interpolationMode holding the\n     * current interpolation mode for the spline.\n     * */\n    protected _interpolationMode:CurveInterpolationModes=CurveInterpolationModes.CubicBezier;\n    /**\n     * When the interpolation mode changes, we need to signal an update of the geometry.\n     * @param value\n     */\n    set interpolationMode(value){\n        this._interpolationMode = value;\n        this.signalGeometryUpdate();\n    }\n    get interpolationMode(){return this._interpolationMode;}\n\n    /**\n     * Width/thickness of the control shape when it is visible\n     * @type {number}\n     */\n    controlShapeWidth:number=0.003;\n    /**\n     * Whether the control shape is visible.\n     * @type {boolean}\n     */\n    controlShapeVisible:boolean=true;\n\n    /**\n     * The number of control points in our spline.\n     * This is simply the number of vertices in `this.verts`, which is a VertexArray2D inherited from `ANodeModel2D`,\n     * which is a parent class.\n     * @returns {number}\n     */\n    get nControlPoints():number{\n        return this.verts.nVerts;\n    }\n\n\n\n    getControlPointLocation(index:number):Vec2{\n        return this.verts.getPoint2DAt(index);\n    }\n\n    getControlPointColor(index:number):Color{\n        return this.verts.color.getAt(index);\n    }\n\n    /**\n     * There are 4 point in a cubic Bezier segment, and when we chain segments together we typically use the last\n     * control point of each segment as the first control point of the subsequent segment.\n     *\n     * Here we give you a function that takes a segment index and returns the 4 corresponding control points.\n     * @param segmentIndex\n     * @returns {[Vec2, Vec2, Vec2, Vec2]}\n     */\n    getSegmentControlPoints(segmentIndex:number):[Vec2, Vec2, Vec2, Vec2]{\n        let startHandle = segmentIndex*3\n        return [\n            this.verts.getPoint2DAt(startHandle),\n            this.verts.getPoint2DAt(startHandle + 1),\n            this.verts.getPoint2DAt(startHandle + 2),\n            this.verts.getPoint2DAt(startHandle + 3)\n        ]\n    }\n\n    /**\n     * Similar to `getSegmentControlPoints`, we give you a function to get the colors stored at each of the control\n     * points in the bezier segment with index `segmentIndex`.\n     * @param segmentIndex\n     * @returns {[Color, Color, Color, Color]}\n     */\n    getSegmentControlPointColors(segmentIndex:number):[Color, Color, Color, Color]{\n        let startHandle = segmentIndex*3\n        return [\n            this.verts.color.getAt(startHandle),\n            this.verts.color.getAt(startHandle + 1),\n            this.verts.color.getAt(startHandle + 2),\n            this.verts.color.getAt(startHandle + 3)\n        ]\n    }\n\n\n    //###########################################//--Linear Interpolation--\\\\###########################################\n    //<editor-fold desc=\"Linear Interpolation\">\n\n    /**\n     * Returns a point `progress` along the linear interpolation of control points.\n     * Remember, only the first and last point in each segment are interpolated!\n     * @param progress\n     * @returns {Vec2}\n     */\n    getLinearInterpolationPoint(progress:number):Vec2{\n        if(this.nControlPoints<2){\n            return V2();\n        }\n        let currentIndex = progress*(this.nControlPoints-2);\n        let tfloor = Math.floor(currentIndex);\n\n        let startControlPointIndex = tfloor;\n        let startControlPoint = this.verts.getPoint2DAt(startControlPointIndex);\n\n        let endControlPointIndex =Math.ceil(currentIndex);\n        let endControlPoint = this.verts.getPoint2DAt(endControlPointIndex);\n\n        let alpha = currentIndex-tfloor;\n\n        /**\n         * We've given you most of this function as an example of how to get control points by index.\n         * From here, you need to return a point that is interpolated `alpha` along the way from `startControlPoint` to\n         * `endControlPoint`...\n         */\n\n        throw new Error(\"getLinearInterpolationPoint not implemented!\")\n        // TODO: Replace the line above with your own code\n    }\n\n\n    /**\n     * Colors can be represented as a vector of color channels. We can interpolate between these vectors in the same way\n     * we interpolate between the coordinate vector representations of spline control points.\n     *\n     * Hint: AniGraph's Color class represents a 4D vector with channels [red, green, blue, alpha], and is implemented\n     * as a subclass of VectorBase, which has element-wise `.plus()` and `.times()` operators, which can make\n     * implementing this function much shorter.\n     * @param progress\n     * @returns {VectorBase | Vec2}\n     */\n    getLinearInterpolationColor(progress:number):Color{\n        if(this.nControlPoints<2){\n            if(this.nControlPoints>0) {\n                return this.verts.color.getAt(0);\n            }else{\n                return Color.FromString(\"#000000\")\n            }\n        }\n\n        throw new Error(\"getLinearInterpolationColor not implemented!\")\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * Returns a unit vector pointed toward the linearly interpolated shape's positive tangent `progress` along the\n     * length of the shape. Make sure you still return a unit vector at control points, though we won't test you on\n     * the direction of vectors at control points.\n     * @param progress\n     * @returns {Vec2}\n     */\n    getLinearInterpolationVelocity(progress:number):Vec2{\n        if(this.nControlPoints<2){\n            return V2();\n        }\n        throw new Error(\"getLinearInterpolationVelocity not implemented!\")\n        // TODO: Replace the line above with your own code\n    }\n    //</editor-fold>\n    //###########################################\\\\--Linear Interpolation--//###########################################\n\n\n    //###############################################//--Cubic Bezier--\\\\###############################################\n    //<editor-fold desc=\"Cubic Bezier\">\n\n    /**\n     * The number of interpolated control points in the spline.\n     * Review the online documentation for the assignment to figure out how the number of interpolated control points relates to the total number of\n     * control points.\n     * @returns {number}\n     */\n    get nInterpolatedControlPoints():number{\n        return this.nControlPoints\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * The number of spline segments. This should also be a function of the number of control points.\n     * @returns {number}\n     */\n    get nBezierSegments():number{\n        return Math.floor(this.nControlPoints/3)\n        // TODO: Replace the line above with your own code\n    }\n\n    constructor() {\n        super();\n    }\n\n    /**\n     * Progress of 0 should map to the first interpolated point of the spline. Progress of 1 should map to the last interpolated point.\n     * A segment index of `n` where `n` is an integer should map to the first interpolated point of the nth segment.\n     * values between n and n+1 should map linearly to progress along the nth segment.\n     * @param progress\n     * @returns {number}\n     */\n    continuousSegmentIndexForProgress(progress:number):number{\n        return progress * this.nBezierSegments\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * Should return the control point index for the kth interpolated point.\n     * Remember that not every control point is an interpolated point.\n     * @param interpolatedPointIndex\n     * @returns {number}\n     */\n    getControlPointIndexForInterpolatedPoint(interpolatedPointIndex:number):number{\n        throw new Error(\"Not Implemented!\")\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * Returns the point `progress` along the bezier spline interpolation of the control points\n     * @param progress\n     * @returns {VectorBase | Vec2}\n     */\n    getCubicBezierInterpolationPoint(progress:number):Vec2{\n        if(this.nControlPoints<4){\n            return this.getLinearInterpolationPoint(progress);\n        }\n\n        //Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha here\n        throw new Error(\"Not Implemented!\")\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * Returns the point `progress` along the bezier spline interpolation of the control points\n     * @param progress\n     * @returns {VectorBase | Vec2}\n     */\n    getCubicBezierInterpolatedColor(progress:number):Color{\n        if(this.nControlPoints<4){\n            return this.getLinearInterpolationColor(progress);\n        }\n        // Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha\n        throw new Error(\"Not Implemented!\")\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * Returns the point `progress` along the bezier spline interpolation of the control points\n     * @param progress\n     * @returns {VectorBase | Vec2}\n     */\n    getCubicBezierVelocityVector(progress:number):Vec2{\n        if(this.nControlPoints<4){\n            return this.getLinearInterpolationVelocity(progress);\n        }\n        // Hint: you probably want to use GetCubicBezierSplineSegmentDerivativeForAlpha here\n        throw new Error(\"Not Implemented!\")\n        // TODO: Replace the line above with your own code\n    }\n    //</editor-fold>\n    //###############################################\\\\--Cubic Bezier--//###############################################\n\n\n\n\n    getPointForProgress(progress:number){\n        switch (this.interpolationMode){\n            case SplineModel.InterpolationModes.Linear:\n                return this.getLinearInterpolationPoint(progress);\n            case SplineModel.InterpolationModes.CubicBezier:\n                try {\n                return this.getCubicBezierInterpolationPoint(progress);\n                }catch(e){\n                    console.error(e);\n                    return this.getLinearInterpolationPoint(progress);\n                }\n            default:\n                throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n        }\n    }\n\n    getDerivativeForProgress(progress:number){\n        switch (this.interpolationMode){\n            case SplineModel.InterpolationModes.Linear:\n                return this.getLinearInterpolationVelocity(progress);\n            case SplineModel.InterpolationModes.CubicBezier:\n                try {\n                    return this.getCubicBezierVelocityVector(progress);\n                }catch(e){\n                    console.error(e);\n                    return this.getLinearInterpolationVelocity(progress);\n                }\n            default:\n                throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n        }\n    }\n\n    getColorForProgress(progress:number){\n        switch (this.interpolationMode){\n            case SplineModel.InterpolationModes.Linear:\n                return this.getLinearInterpolationColor(progress);\n            case SplineModel.InterpolationModes.CubicBezier:\n                try {\n                return this.getCubicBezierInterpolatedColor(progress);\n                }catch(e){\n                    console.error(e);\n                    return this.getLinearInterpolationColor(progress);\n                }\n            default:\n                throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n        }\n    }\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}