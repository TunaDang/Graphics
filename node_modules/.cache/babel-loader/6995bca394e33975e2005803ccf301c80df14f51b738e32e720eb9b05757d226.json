{"ast":null,"code":"//@ts-nocheck\nimport { Box2, BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Matrix3, Path, Shape, ShapePath, ShapeUtils, Vector2 } from \"three\";\nimport { ANIGRAPH_DEBUG_MODE } from \"../../defines\";\nexport class SVGPath extends ShapePath {\n  constructor(...args) {\n    super(...args);\n    this.userData = void 0;\n  }\n}\nexport class SVGLoader extends Loader {\n  constructor(manager = undefined) {\n    super(manager);\n    // Default dots per inch\n    this.defaultDPI = 90;\n    // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n    this.defaultUnit = \"px\";\n  }\n  async load(url, onLoad = undefined, onProgress = undefined, onError = undefined) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    const svgText = await loader.loadAsync(url);\n    return scope.parse(svgText);\n  }\n  async loadSVGText(url) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    const svgText = await loader.loadAsync(url);\n    return svgText;\n  }\n  parse(text) {\n    const scope = this;\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return;\n      const currentSvgNode = {\n        id: node.getAttribute(\"id\"),\n        children: [],\n        originPath: null,\n        globalPath: null,\n        localTransform: null,\n        globalTransform: null,\n        node\n      };\n      const transform = getNodeTransform(node);\n      currentSvgNode.localTransform = transform ? transform.clone() : new Matrix3();\n      let traverseChildNodes = true;\n      let path = null;\n      currentSvgNode.node = node;\n      switch (node.nodeName) {\n        case \"svg\":\n          break;\n        case \"style\":\n          parseCSSStylesheet(node);\n          break;\n        case \"g\":\n          style = parseStyle(node, style);\n          break;\n        case \"path\":\n          style = parseStyle(node, style);\n          if (node.hasAttribute(\"d\")) path = parsePathNode(node);\n          break;\n        case \"rect\":\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n        case \"polygon\":\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n        case \"polyline\":\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n        case \"circle\":\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n        case \"ellipse\":\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n        case \"line\":\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n        case \"defs\":\n          traverseChildNodes = false;\n          break;\n\n        //TO_DO: need to fix use\n        // case 'use':\n        // \tstyle = parseStyle(node, style);\n        // \tconst usedNodeId = (node as SVGUseElement).href.baseVal.substring(1);\n        // \t// const usedNode = node.viewportElement.getElementById(usedNodeId);\n        // \tconst usedNode = document.getElementById(usedNodeId) as unknown as SVGElement;\n        // \tif (usedNode) {\n\n        // \t\tconst childNode = parseNode(usedNode, style);\n        // \t\tif (childNode) {\n\n        // \t\t\tcurrentSvgNode.children.push(childNode);\n\n        // \t\t}\n\n        // \t} else {\n\n        // \t\tconsole.warn(\n        // \t\t\t'SVGLoader: \\'use node\\' references non-existent node id: ' +\n        // \t\t\tusedNodeId\n        // \t\t);\n\n        // \t}\n\n        // \tbreak;\n\n        default:\n        // console.log( node );\n      }\n      if (path) {\n        if (style.fill !== undefined && style.fill !== \"none\") {\n          path.color.setStyle(style.fill);\n        }\n        currentSvgNode.originPath = path;\n        // transformPath( path, currentTransform );\n\n        currentSvgNode.globalTransform = currentTransform ? currentTransform.clone() : new Matrix3();\n        currentSvgNode.globalPath = path;\n        paths.push(path);\n        path.userData = {\n          node: node,\n          style: style\n        };\n      }\n      if (traverseChildNodes) {\n        const nodes = node.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n          const childNode = parseNode(nodes[i], style);\n          if (childNode) {\n            currentSvgNode.children.push(childNode);\n          }\n        }\n      }\n      if (transform) {\n        transformStack.pop();\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n      return currentSvgNode;\n    }\n    function parsePathNode(node) {\n      const path = new ShapePath();\n      const point = new Vector2();\n      const control = new Vector2();\n      const firstPoint = new Vector2();\n      let isFirstPoint = true;\n      let doSetFirstPoint = false;\n      const d = node.getAttribute(\"d\");\n      const commands = d.match(/[a-df-z][^a-df-z]*/gi);\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i];\n        const type = command.charAt(0);\n        const data = command.substr(1).trim();\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n        let numbers;\n        switch (type) {\n          case \"M\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"H\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"V\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"L\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"C\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"S\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"Q\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"T\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"A\":\n            numbers = parseFloats(data, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] === point.x && numbers[j + 6] === point.y) continue;\n              const start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"m\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"h\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"v\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"l\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"c\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"s\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"q\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"t\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"a\":\n            numbers = parseFloats(data, [3, 4], 7);\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] === 0 && numbers[j + 6] === 0) continue;\n              const start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n            break;\n          case \"Z\":\n          case \"z\":\n            path.currentPath.autoClose = true;\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n            break;\n          default:\n            console.warn(command);\n        }\n\n        // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n        doSetFirstPoint = false;\n      }\n      return path;\n    }\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1) continue;\n        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(i => i.trim());\n        for (let j = 0; j < selectorList.length; j++) {\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n        }\n      }\n    }\n\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx === 0 || ry === 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y);\n        return;\n      }\n      x_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n      // Ensure radii are positive\n      rx = Math.abs(rx);\n      ry = Math.abs(ry);\n\n      // Compute (x1', y1')\n      const dx2 = (start.x - end.x) / 2.0;\n      const dy2 = (start.y - end.y) / 2.0;\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n\n      // Compute (cx', cy')\n      let rxs = rx * rx;\n      let rys = ry * ry;\n      const x1ps = x1p * x1p;\n      const y1ps = y1p * y1p;\n\n      // Ensure radii are large enough\n      const cr = x1ps / rxs + y1ps / rys;\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        const s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n      const dq = rxs * y1ps + rys * x1ps;\n      const pq = (rxs * rys - dq) / dq;\n      let q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag) q = -q;\n      const cxp = q * rx * y1p / ry;\n      const cyp = -q * ry * x1p / rx;\n\n      // Step 3: Compute (cx, cy) from (cx', cy')\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n\n      // Step 4: Compute θ1 and Δθ\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy;\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n      if (ux * vy - uy * vx < 0) ang = -ang;\n      return ang;\n    }\n\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n      const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n      const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n      const path = new ShapePath();\n      path.moveTo(x + 2 * rx, y);\n      path.lineTo(x + w - 2 * rx, y);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n      path.lineTo(x + w, y + h - 2 * ry);\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n      path.lineTo(x + 2 * rx, y + h);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n      }\n      path.lineTo(x, y + 2 * ry);\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n      }\n      return path;\n    }\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /(-?[\\d.?]+)[,|\\s](-?[\\d.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n        index++;\n      }\n      const regex = /(-?[\\d.?]+)[,|\\s](-?[\\d.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute(\"points\").replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n      const subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2, false);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n      const subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2, false, 0);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n      const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n      const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n      const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n      const path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n\n    //\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style); // clone style\n\n      let stylesheetStyles = {};\n      if (node.hasAttribute(\"class\")) {\n        const classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map(i => i.trim());\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n        }\n      }\n      if (node.hasAttribute(\"id\")) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n      }\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined) adjustFunction = function copy(v) {\n          if (v.startsWith(\"url\")) {\n            if (ANIGRAPH_DEBUG_MODE) {\n              console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n            }\n            return undefined;\n          }\n          return v;\n        };\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== \"\") style[jsName] = adjustFunction(node.style[svgName]);\n      }\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n      addStyle(\"fill\", \"fill\");\n      addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n      addStyle(\"opacity\", \"opacity\", clamp);\n      addStyle(\"stroke\", \"stroke\");\n      addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n      addStyle(\"stroke-width\", \"strokeWidth\", positive);\n      addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n      addStyle(\"stroke-linecap\", \"strokeLineCap\");\n      addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n      addStyle(\"visibility\", \"visibility\");\n      return style;\n    }\n\n    // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n    function getReflection(a, b) {\n      return a - (b - a);\n    }\n\n    // from https://github.com/ppvg/svg-numbers (MIT License)\n\n    function parseFloats(input, flags = undefined, stride = undefined) {\n      if (typeof input !== \"string\") {\n        throw new TypeError(\"Invalid input: \" + typeof input);\n      }\n\n      // Character groups\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/\n      };\n\n      // States\n      const SEP = 0;\n      const INT = 1;\n      const FLOAT = 2;\n      const EXP = 3;\n      let state = SEP;\n      let seenComma = true;\n      let number = \"\",\n        exponent = \"\";\n      const result = [];\n      function throwSyntaxError(current, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + \".\");\n        // error.partial = partial;\n        throw error;\n      }\n      function newNumber() {\n        if (number !== \"\") {\n          if (exponent === \"\") result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n        number = \"\";\n        exponent = \"\";\n      }\n      let current;\n      const length = input.length;\n      for (let i = 0; i < length; i++) {\n        current = input[i];\n\n        // check for flags\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT;\n          number = current;\n          newNumber();\n          continue;\n        }\n\n        // parse until next number\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          }\n\n          // start new number\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          }\n\n          // throw on double commas (e.g. \"1, , 2\")\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n            seenComma = true;\n          }\n        }\n\n        // parse integer part\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n\n          // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        }\n\n        // parse decimal part\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n\n          // throw on double decimal points (e.g. \"1..2\")\n          if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n            throwSyntaxError(current, i, result);\n          }\n        }\n\n        // parse exponent part\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n          if (RE.SIGN.test(current)) {\n            if (exponent === \"\") {\n              exponent += current;\n              continue;\n            }\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        }\n\n        // end of number\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      }\n\n      // add the last number found (if any)\n      newNumber();\n      return result;\n    }\n\n    // Units\n\n    const units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n\n    // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n    const unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1\n      },\n      px: {\n        px: 1\n      }\n    };\n    function parseFloatWithUnits(string) {\n      let theUnit = \"px\";\n      if (typeof string === \"string\" || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i];\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n      let scale = undefined;\n      if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n        // Conversion scale from  pixels to inches, then to default units\n\n        scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n        if (scale < 0) {\n          // Conversion scale to pixels\n\n          scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n        }\n      }\n      return scale * parseFloat(string);\n    }\n\n    // Transforms\n\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n        return null;\n      }\n      const transform = parseNodeTransform(node);\n      return transform;\n      // if ( transformStack.length > 0 ) {\n\n      // \ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n      // }\n\n      // currentTransform.copy( transform );\n      // transformStack.push( transform );\n\n      // return transform;\n    }\n    function parseNodeTransform(node) {\n      const transform = new Matrix3();\n      const currentTransform = tempTransform0;\n      const translate = [0, 0];\n      if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n        const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n        const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n        transform.translate(tx, ty);\n        translate[0] += tx;\n        translate[1] += ty;\n      }\n      if (node.hasAttribute(\"transform\")) {\n        const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim();\n          if (transformText === \"\") continue;\n          const openParPos = transformText.indexOf(\"(\");\n          const closeParPos = transformText.length;\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.substr(0, openParPos);\n            const array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n            currentTransform.identity();\n            switch (transformType) {\n              case \"translate\":\n                if (array.length >= 1) {\n                  const tx = array[0];\n                  let ty = tx;\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n                  currentTransform.translate(tx, ty);\n                  translate[0] += tx;\n                  translate[1] += ty;\n                }\n                break;\n              case \"rotate\":\n                if (array.length >= 1) {\n                  let angle = 0;\n                  let cx = 0;\n                  let cy = 0;\n\n                  // Angle\n                  angle = -array[0] * Math.PI / 180;\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1];\n                    cy = array[2];\n                  }\n\n                  // Rotate around center (cx, cy)\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n                break;\n              case \"scale\":\n                if (array.length >= 1) {\n                  const scaleX = array[0];\n                  let scaleY = scaleX;\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n                  currentTransform.scale(scaleX, scaleY);\n                }\n                break;\n              case \"skewX\":\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"skewY\":\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n                break;\n              case \"matrix\":\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n                break;\n            }\n          }\n          transform.premultiply(currentTransform);\n        }\n      }\n      return transform;\n    }\n\n    // function transformPath(path: ShapePath, m) {\n\n    // \tfunction transfVec2(v2) {\n\n    // \t\ttempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n\n    // \t\tv2.set(tempV3.x, tempV3.y);\n\n    // \t}\n\n    // \tconst isRotated = isTransformRotated(m);\n\n    // \tconst subPaths = path.subPaths;\n\n    // \tfor (let i = 0, n = subPaths.length; i < n; i++) {\n\n    // \t\tconst subPath = subPaths[i];\n    // \t\tconst curves = subPath.curves;\n\n    // \t\tfor (let j = 0; j < curves.length; j++) {\n\n    // \t\t\tconst curve = curves[j];\n\n    // \t\t\tif (curve.isLineCurve) {\n\n    // \t\t\t\ttransfVec2(curve.v1);\n    // \t\t\t\ttransfVec2(curve.v2);\n\n    // \t\t\t} else if (curve.isCubicBezierCurve) {\n\n    // \t\t\t\ttransfVec2(curve.v0);\n    // \t\t\t\ttransfVec2(curve.v1);\n    // \t\t\t\ttransfVec2(curve.v2);\n    // \t\t\t\ttransfVec2(curve.v3);\n\n    // \t\t\t} else if (curve.isQuadraticBezierCurve) {\n\n    // \t\t\t\ttransfVec2(curve.v0);\n    // \t\t\t\ttransfVec2(curve.v1);\n    // \t\t\t\ttransfVec2(curve.v2);\n\n    // \t\t\t} else if (curve.isEllipseCurve) {\n\n    // \t\t\t\tif (isRotated) {\n\n    // \t\t\t\t\tconsole.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n\n    // \t\t\t\t}\n\n    // \t\t\t\ttempV2.set(curve.aX, curve.aY);\n    // \t\t\t\ttransfVec2(tempV2);\n    // \t\t\t\tcurve.aX = tempV2.x;\n    // \t\t\t\tcurve.aY = tempV2.y;\n\n    // \t\t\t\tcurve.xRadius *= getTransformScaleX(m);\n    // \t\t\t\tcurve.yRadius *= getTransformScaleY(m);\n\n    // \t\t\t}\n\n    // \t\t}\n\n    // \t}\n\n    // }\n\n    // function isTransformRotated(m) {\n\n    // \treturn m.elements[1] !== 0 || m.elements[3] !== 0;\n\n    // }\n\n    // function getTransformScaleX(m) {\n\n    // \tconst te = m.elements;\n    // \treturn Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n\n    // }\n\n    // function getTransformScaleY(m) {\n\n    // \tconst te = m.elements;\n    // \treturn Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n\n    // }\n\n    const paths = [];\n    const stylesheets = {};\n    const transformStack = [];\n    const tempTransform0 = new Matrix3();\n    const tempTransform1 = new Matrix3();\n    const tempTransform2 = new Matrix3();\n    const tempTransform3 = new Matrix3();\n    // const tempV2 = new Vector2();\n    // const tempV3 = new Vector3();\n\n    const currentTransform = new Matrix3();\n    const xml = new DOMParser().parseFromString(text, \"image/svg+xml\"); // application/xml\n\n    const rootSvgNode = parseNode(xml.documentElement, {\n      fill: \"#000\",\n      stroke: undefined,\n      opacity: 1,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: \"miter\",\n      strokeLineCap: \"butt\",\n      strokeMiterLimit: 4,\n      visibility: \"visible\"\n    });\n    const data = {\n      paths,\n      rootSvgNode: rootSvgNode,\n      xml: xml.documentElement\n    };\n    return data;\n  }\n  static createShapes(shapePath) {\n    // Param shapePath: a shapepath as returned by the parse function of this class\n    // Returns Shape object\n\n    const BIGNUMBER = 999999999;\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6\n    };\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0\n    };\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x;\n      const x2 = a1.x;\n      const x3 = b0.x;\n      const x4 = b1.x;\n      const y1 = a0.y;\n      const y2 = a1.y;\n      const y3 = b0.y;\n      const y4 = b1.y;\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      const t1 = nom1 / denom;\n      const t2 = nom2 / denom;\n      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        //1. lines are parallel or edges don't intersect\n\n        return null;\n      } else if (nom1 === 0 && denom === 0) {\n        //2. lines are colinear\n\n        //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          //find position of this endpoints relatively to edge1\n          if (classifyResult.loc === IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return {\n              x: point.x,\n              y: point.y,\n              t: classifyResult.t\n            };\n          } else if (classifyResult.loc === IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n            return {\n              x: x,\n              y: y,\n              t: classifyResult.t\n            };\n          }\n        }\n        return null;\n      } else {\n        //3. edges intersect\n\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          if (classifyResult.loc === IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return {\n              x: point.x,\n              y: point.y,\n              t: classifyResult.t\n            };\n          }\n        }\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n        return {\n          x: x,\n          y: y,\n          t: t1\n        };\n      }\n    }\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x;\n      const ay = edgeEnd.y - edgeStart.y;\n      const bx = p.x - edgeStart.x;\n      const by = p.y - edgeStart.y;\n      const sa = ax * by - bx * ay;\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN;\n        classifyResult.t = 0;\n        return;\n      }\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION;\n        classifyResult.t = 1;\n        return;\n      }\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT;\n        return;\n      }\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT;\n        return;\n      }\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND;\n        return;\n      }\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND;\n        return;\n      }\n      let t;\n      if (ax !== 0) {\n        t = bx / ax;\n      } else {\n        t = by / ay;\n      }\n      classifyResult.loc = IntersectionLocationType.BETWEEN;\n      classifyResult.t = t;\n    }\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = [];\n      const intersections = [];\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1];\n        const path1EdgeEnd = path1[index];\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1];\n          const path2EdgeEnd = path2[index2];\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n          if (intersection !== null && intersectionsRaw.find(i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === undefined) {\n            intersectionsRaw.push(intersection);\n            intersections.push(new Vector2(intersection.x, intersection.y));\n          }\n        }\n      }\n      return intersections;\n    }\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2();\n      boundingBox.getCenter(center);\n      const allIntersections = [];\n      paths.forEach(path => {\n        // check if the center of the bounding box is in the bounding box of the paths.\n        // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n        // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points);\n          intersections.forEach(p => {\n            allIntersections.push({\n              identifier: path.identifier,\n              isCW: path.isCW,\n              point: p\n            });\n          });\n        }\n      });\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      return allIntersections;\n    }\n    function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n      if (_fillRule === null || _fillRule === undefined || _fillRule === \"\") {\n        _fillRule = \"nonzero\";\n      }\n      const centerBoundingBox = new Vector2();\n      simplePath.boundingBox.getCenter(centerBoundingBox);\n      const scanline = [new Vector2(scanlineMinX, centerBoundingBox.y), new Vector2(scanlineMaxX, centerBoundingBox.y)];\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      const baseIntersections = [];\n      const otherIntersections = [];\n      scanlineIntersections.forEach(i => {\n        if (i.identifier === simplePath.identifier) {\n          baseIntersections.push(i);\n        } else {\n          otherIntersections.push(i);\n        }\n      });\n      const firstXOfPath = baseIntersections[0].point.x;\n\n      // build up the path hierarchy\n      const stack = [];\n      let i = 0;\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop();\n        } else {\n          stack.push(otherIntersections[i].identifier);\n        }\n        i++;\n      }\n      stack.push(simplePath.identifier);\n      if (_fillRule === \"evenodd\") {\n        const isHole = stack.length % 2 === 0 ? true : false;\n        const isHoleFor = stack[stack.length - 2];\n        return {\n          identifier: simplePath.identifier,\n          isHole: isHole,\n          for: isHoleFor\n        };\n      } else if (_fillRule === \"nonzero\") {\n        // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n        let isHole = true;\n        let isHoleFor = null;\n        let lastCWValue = null;\n        for (let i = 0; i < stack.length; i++) {\n          const identifier = stack[i];\n          if (isHole) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = false;\n            isHoleFor = identifier;\n          } else if (lastCWValue !== allPaths[identifier].isCW) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = true;\n          }\n        }\n        return {\n          identifier: simplePath.identifier,\n          isHole: isHole,\n          for: isHoleFor\n        };\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n      }\n    }\n\n    // check for self intersecting paths\n    // TO_DO\n\n    // check intersecting paths\n    // TO_DO\n\n    // prepare paths for hole detection\n    let identifier = 0;\n    let scanlineMinX = BIGNUMBER;\n    let scanlineMaxX = -BIGNUMBER;\n    let simplePaths = shapePath.subPaths.map(p => {\n      const points = p.getPoints();\n      let maxY = -BIGNUMBER;\n      let minY = BIGNUMBER;\n      let maxX = -BIGNUMBER;\n      let minX = BIGNUMBER;\n\n      //points.forEach(p => p.y *= -1);\n\n      for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        if (p.y > maxY) {\n          maxY = p.y;\n        }\n        if (p.y < minY) {\n          minY = p.y;\n        }\n        if (p.x > maxX) {\n          maxX = p.x;\n        }\n        if (p.x < minX) {\n          minX = p.x;\n        }\n      }\n\n      //\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1;\n      }\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1;\n      }\n      return {\n        points: points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: identifier++,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n      };\n    });\n    simplePaths = simplePaths.filter(sp => sp.points.length > 1);\n\n    // check if path is solid or a hole\n    // TO_DO: need to fix fillRule since it's not captured\n    // const isAHole = simplePaths.map(p => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule));\n    const isAHole = simplePaths.map(p => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, undefined));\n    const shapesToReturn = [];\n    simplePaths.forEach(p => {\n      const amIAHole = isAHole[p.identifier];\n      if (!amIAHole.isHole) {\n        const shape = new Shape(p.points);\n        const holes = isAHole.filter(h => h.isHole && h.for === p.identifier);\n        holes.forEach(h => {\n          const path = simplePaths[h.identifier];\n          shape.holes.push(new Path(path.points));\n        });\n        shapesToReturn.push(shape);\n      }\n    });\n    return shapesToReturn;\n  }\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    // Param width: Stroke width\n    // Param color: As returned by THREE.Color.getStyle()\n    // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n    // Param lineCap: One of \"round\", \"square\" or \"butt\"\n    // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n    // Returns style object\n\n    width = width !== undefined ? width : 1;\n    color = color !== undefined ? color : \"#000\";\n    lineJoin = lineJoin !== undefined ? lineJoin : \"miter\";\n    lineCap = lineCap !== undefined ? lineCap : \"butt\";\n    miterLimit = miterLimit !== undefined ? miterLimit : 4;\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit\n    };\n  }\n  static pointsToStroke(points, style, arcDivisions = 12, minDistance = 0.001) {\n    // Generates a stroke with some witdh around the given path.\n    // The path can be open or closed (last point equals to first point)\n    // Param points: Array of Vector2D (the path). Minimum 2 points.\n    // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n    // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n    // Param minDistance: Points closer to this distance will be merged. (Optional)\n    // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null;\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    return geometry;\n  }\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices = undefined, normals = undefined, uvs = undefined, vertexOffset = 0) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n\n    const tempV2_1 = new Vector2();\n    const tempV2_2 = new Vector2();\n    const tempV2_3 = new Vector2();\n    const tempV2_4 = new Vector2();\n    const tempV2_5 = new Vector2();\n    const tempV2_6 = new Vector2();\n    const tempV2_7 = new Vector2();\n    const lastPointL = new Vector2();\n    const lastPointR = new Vector2();\n    const point0L = new Vector2();\n    const point0R = new Vector2();\n    const currentPointL = new Vector2();\n    const currentPointR = new Vector2();\n    const nextPointL = new Vector2();\n    const nextPointR = new Vector2();\n    const innerPoint = new Vector2();\n    const outerPoint = new Vector2();\n\n    // First ensure there are no duplicated points\n    points = removeDuplicatedPoints(points);\n    const numPoints = points.length;\n    if (numPoints < 2) return 0;\n    const isClosed = points[0].equals(points[numPoints - 1]);\n    let currentPoint;\n    let previousPoint = points[0];\n    let nextPoint;\n    const strokeWidth2 = style.strokeWidth / 2;\n    const deltaU = 1 / (numPoints - 1);\n    let u0 = 0,\n      u1;\n    let innerSideModified;\n    let joinIsOnLeftSide;\n    let isMiter;\n    let initialJoinIsOnLeftSide = false;\n    let numVertices = 0;\n    let currentCoordinate = vertexOffset * 3;\n    let currentCoordinateUV = vertexOffset * 2;\n\n    // Get initial left and right stroke points\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint];\n\n      // Get next point\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1];\n        } else nextPoint = undefined;\n      } else {\n        nextPoint = points[iPoint + 1];\n      }\n\n      // Normal of previous segment in tempV2_1\n      const normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      u1 = u0 + deltaU;\n      innerSideModified = false;\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        const dot = Math.abs(normal1.dot(tempV2_3));\n\n        // If path is straight, don't create join\n        if (dot !== 0) {\n          // Compute inner and outer segment intersections\n          const miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          const miterLength2 = tempV2_5.length();\n          const segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          const segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext);\n          // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n\n            makeSegmentTriangles();\n          }\n          switch (style.strokeLineJoin) {\n            case \"bevel\":\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n            case \"round\":\n              // Segment triangles\n\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n\n              // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n              break;\n            case \"miter\":\n            case \"miter-clip\":\n            default:\n              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n\n                if (style.strokeLineJoin !== \"miter-clip\") {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  // Segment triangles\n\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n\n                  // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  // Add extra miter join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n                isMiter = true;\n              }\n              break;\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n\n          makeSegmentTriangles();\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n\n        makeSegmentTriangles();\n      }\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      }\n\n      // Increment loop variables\n\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n      let lastOuter = outerPoint;\n      let lastInner = innerPoint;\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n    return numVertices;\n\n    // -- End of algorithm\n\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n        currentCoordinate += 3;\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n      numVertices += 3;\n    }\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      let angle = Math.PI;\n      const dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n\n          // Bevel join triangle\n\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n\n          // Bevel join triangle\n\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the Component loop\n\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n\n      switch (style.strokeLineCap) {\n        case \"round\":\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n          break;\n        case \"square\":\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            const vl = vertices.length;\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n          break;\n        case \"butt\":\n        default:\n          // Nothing to do here\n          break;\n      }\n    }\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n\n      let dupPoints = false;\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n      if (!dupPoints) return points;\n      const newPoints = [];\n      newPoints.push(points[0]);\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i]);\n        }\n      }\n      newPoints.push(points[points.length - 1]);\n      return newPoints;\n    }\n  }\n}","map":{"version":3,"names":["Box2","BufferGeometry","FileLoader","Float32BufferAttribute","Loader","Matrix3","Path","Shape","ShapePath","ShapeUtils","Vector2","ANIGRAPH_DEBUG_MODE","SVGPath","constructor","args","userData","SVGLoader","manager","undefined","defaultDPI","defaultUnit","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","svgText","loadAsync","parse","loadSVGText","text","parseNode","node","style","nodeType","currentSvgNode","id","getAttribute","children","originPath","globalPath","localTransform","globalTransform","transform","getNodeTransform","clone","traverseChildNodes","nodeName","parseCSSStylesheet","parseStyle","hasAttribute","parsePathNode","parseRectNode","parsePolygonNode","parsePolylineNode","parseCircleNode","parseEllipseNode","parseLineNode","fill","color","setStyle","currentTransform","paths","push","nodes","childNodes","i","length","childNode","transformStack","pop","copy","identity","point","control","firstPoint","isFirstPoint","doSetFirstPoint","d","commands","match","l","command","type","charAt","data","substr","trim","numbers","parseFloats","j","jl","x","y","moveTo","lineTo","bezierCurveTo","getReflection","quadraticCurveTo","rx","ry","start","parseArcCommand","currentPath","autoClose","curves","currentPoint","console","warn","sheet","cssRules","stylesheet","selectorList","selectorText","split","filter","Boolean","map","stylesheets","Object","assign","x_axis_rotation","large_arc_flag","sweep_flag","end","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseFloatWithUnits","w","h","iterator","a","b","index","regex","replace","r","subpath","absarc","subPaths","x1","y1","x2","y2","stylesheetStyles","classSelectors","addStyle","svgName","jsName","adjustFunction","v","startsWith","clamp","positive","input","flags","stride","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","SEP","INT","FLOAT","state","seenComma","number","exponent","result","throwSyntaxError","current","partial","error","SyntaxError","newNumber","Number","pow","Array","isArray","includes","test","units","unitConversion","mm","cm","in","pt","pc","px","string","theUnit","String","n","u","endsWith","substring","scale","parseFloat","parseNodeTransform","tempTransform0","translate","tx","ty","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","array","angle","tempTransform1","tempTransform2","rotate","tempTransform3","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","xml","DOMParser","parseFromString","rootSvgNode","documentElement","stroke","opacity","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","visibility","createShapes","shapePath","BIGNUMBER","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","t","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","nom2","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","EPSILON","getIntersections","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","index2","path2EdgeStart","path2EdgeEnd","intersection","find","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","points","identifier","isCW","sort","i1","i2","isHoleTo","simplePath","allPaths","scanlineMinX","scanlineMaxX","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","simplePaths","getPoints","maxY","minY","maxX","minX","isClockWise","sp","isAHole","shapesToReturn","amIAHole","shape","holes","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","removeDuplicatedPoints","numPoints","isClosed","equals","previousPoint","nextPoint","strokeWidth2","deltaU","u0","u1","innerSideModified","joinIsOnLeftSide","isMiter","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","il","rotateAround","addVectors","vl","dupPoints","distanceTo","newPoints"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/fileio/svg/SVGLoader.ts"],"sourcesContent":["//@ts-nocheck\nimport {\n  Box2,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  Matrix3,\n  Path,\n  Shape,\n  ShapePath,\n  ShapeUtils,\n  Vector2,\n} from \"three\";\nimport {ANIGRAPH_DEBUG_MODE} from \"../../defines\";\n\nexport interface SvgNode {\n  id: string;\n  children: SvgNode[];\n  originPath: SVGPath;\n  globalPath: SVGPath;\n  localTransform: THREE.Matrix3;\n  globalTransform: THREE.Matrix3;\n  node: SVGElement;\n}\n\nexport interface SVGParsedData {\n  paths: SVGPath[];\n  rootSvgNode: SvgNode;\n  xml: HTMLElement;\n}\n\ninterface SVGStyle {\n  opacity: number;\n  fill: string;\n  fillOpacity: number;\n  stroke: string;\n  strokeOpacity: number;\n  strokeWidth: number;\n  strokeLineJoin: string;\n  strokeLineCap: string;\n  strokeMiterLimit: number;\n  visibility: string;\n}\n\nexport class SVGPath extends ShapePath {\n  userData: { node: HTMLElement; style: SVGStyle };\n}\n\nexport class SVGLoader extends Loader {\n  // Default dots per inch\n  defaultDPI: number = 90;\n\n  // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n  defaultUnit: string = \"px\";\n  constructor(manager = undefined) {\n    super(manager);\n  }\n\n  async load(\n    url: string,\n    onLoad: (data: SVGParsedData) => void = undefined,\n    onProgress = undefined,\n    onError = undefined\n  ) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    const svgText = (await loader.loadAsync(url)) as string;\n    return scope.parse(svgText);\n  }\n\n  async loadSVGText(\n      url: string\n  ) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    const svgText = (await loader.loadAsync(url)) as string;\n    return svgText;\n  }\n\n  parse(text: string): SVGParsedData {\n    const scope = this;\n    function parseNode(node: SVGElement, style: SVGStyle) {\n      if (node.nodeType !== 1) return;\n\n      const currentSvgNode: SvgNode = {\n        id: node.getAttribute(\"id\"),\n        children: [],\n        originPath: null,\n        globalPath: null,\n        localTransform: null,\n        globalTransform: null,\n        node,\n      };\n\n      const transform = getNodeTransform(node);\n\n      currentSvgNode.localTransform = transform\n        ? transform.clone()\n        : new Matrix3();\n      let traverseChildNodes = true;\n\n      let path = null;\n      currentSvgNode.node = node;\n      switch (node.nodeName) {\n        case \"svg\":\n          break;\n\n        case \"style\":\n          parseCSSStylesheet(node);\n          break;\n\n        case \"g\":\n          style = parseStyle(node, style);\n          break;\n\n        case \"path\":\n          style = parseStyle(node, style);\n          if (node.hasAttribute(\"d\")) path = parsePathNode(node);\n          break;\n\n        case \"rect\":\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n\n        case \"polygon\":\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n\n        case \"polyline\":\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n\n        case \"circle\":\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n\n        case \"ellipse\":\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n\n        case \"line\":\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n\n        case \"defs\":\n          traverseChildNodes = false;\n          break;\n\n        //TO_DO: need to fix use\n        // case 'use':\n        // \tstyle = parseStyle(node, style);\n        // \tconst usedNodeId = (node as SVGUseElement).href.baseVal.substring(1);\n        // \t// const usedNode = node.viewportElement.getElementById(usedNodeId);\n        // \tconst usedNode = document.getElementById(usedNodeId) as unknown as SVGElement;\n        // \tif (usedNode) {\n\n        // \t\tconst childNode = parseNode(usedNode, style);\n        // \t\tif (childNode) {\n\n        // \t\t\tcurrentSvgNode.children.push(childNode);\n\n        // \t\t}\n\n        // \t} else {\n\n        // \t\tconsole.warn(\n        // \t\t\t'SVGLoader: \\'use node\\' references non-existent node id: ' +\n        // \t\t\tusedNodeId\n        // \t\t);\n\n        // \t}\n\n        // \tbreak;\n\n        default:\n        // console.log( node );\n      }\n\n      if (path) {\n        if (style.fill !== undefined && style.fill !== \"none\") {\n          path.color.setStyle(style.fill);\n        }\n\n        currentSvgNode.originPath = path;\n        // transformPath( path, currentTransform );\n\n        currentSvgNode.globalTransform = currentTransform\n          ? currentTransform.clone()\n          : new Matrix3();\n        currentSvgNode.globalPath = path;\n        paths.push(path);\n\n        path.userData = { node: node, style: style };\n      }\n\n      if (traverseChildNodes) {\n        const nodes = node.childNodes;\n\n        for (let i = 0; i < nodes.length; i++) {\n          const childNode = parseNode(nodes[i] as SVGElement, style);\n          if (childNode) {\n            currentSvgNode.children.push(childNode);\n          }\n        }\n      }\n\n      if (transform) {\n        transformStack.pop();\n\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n\n      return currentSvgNode;\n    }\n\n    function parsePathNode(node) {\n      const path = new ShapePath();\n\n      const point = new Vector2();\n      const control = new Vector2();\n\n      const firstPoint = new Vector2();\n      let isFirstPoint = true;\n      let doSetFirstPoint = false;\n\n      const d = node.getAttribute(\"d\");\n\n      const commands = d.match(/[a-df-z][^a-df-z]*/gi);\n\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i];\n\n        const type = command.charAt(0);\n        const data = command.substr(1).trim();\n\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n\n        let numbers;\n\n        switch (type) {\n          case \"M\":\n            numbers = parseFloats(data);\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"H\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"V\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"L\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"C\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                numbers[j + 5]\n              );\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"S\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3]\n              );\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"Q\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3]\n              );\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"T\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"A\":\n            numbers = parseFloats(data, [3, 4], 7);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] === point.x && numbers[j + 6] === point.y)\n                continue;\n\n              const start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point\n              );\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"m\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"h\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"v\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"l\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"c\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n                point.x + numbers[j + 4],\n                point.y + numbers[j + 5]\n              );\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"s\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3]\n              );\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"q\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3]\n              );\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"t\":\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(\n                rx,\n                ry,\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1]\n              );\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"a\":\n            numbers = parseFloats(data, [3, 4], 7);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] === 0 && numbers[j + 6] === 0) continue;\n\n              const start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point\n              );\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case \"Z\":\n          case \"z\":\n            path.currentPath.autoClose = true;\n\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n\n            break;\n\n          default:\n            console.warn(command);\n        }\n\n        // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n        doSetFirstPoint = false;\n      }\n\n      return path;\n    }\n\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)\n        return;\n\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i];\n\n        if (stylesheet.type !== 1) continue;\n\n        const selectorList = stylesheet.selectorText\n          .split(/,/gm)\n          .filter(Boolean)\n          .map((i) => i.trim());\n\n        for (let j = 0; j < selectorList.length; j++) {\n          stylesheets[selectorList[j]] = Object.assign(\n            stylesheets[selectorList[j]] || {},\n            stylesheet.style\n          );\n        }\n      }\n    }\n\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n    function parseArcCommand(\n      path,\n      rx,\n      ry,\n      x_axis_rotation,\n      large_arc_flag,\n      sweep_flag,\n      start,\n      end\n    ) {\n      if (rx === 0 || ry === 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y);\n        return;\n      }\n\n      x_axis_rotation = (x_axis_rotation * Math.PI) / 180;\n\n      // Ensure radii are positive\n      rx = Math.abs(rx);\n      ry = Math.abs(ry);\n\n      // Compute (x1', y1')\n      const dx2 = (start.x - end.x) / 2.0;\n      const dy2 = (start.y - end.y) / 2.0;\n      const x1p =\n        Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      const y1p =\n        -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n\n      // Compute (cx', cy')\n      let rxs = rx * rx;\n      let rys = ry * ry;\n      const x1ps = x1p * x1p;\n      const y1ps = y1p * y1p;\n\n      // Ensure radii are large enough\n      const cr = x1ps / rxs + y1ps / rys;\n\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        const s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n\n      const dq = rxs * y1ps + rys * x1ps;\n      const pq = (rxs * rys - dq) / dq;\n      let q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag) q = -q;\n      const cxp = (q * rx * y1p) / ry;\n      const cyp = (-q * ry * x1p) / rx;\n\n      // Step 3: Compute (cx, cy) from (cx', cy')\n      const cx =\n        Math.cos(x_axis_rotation) * cxp -\n        Math.sin(x_axis_rotation) * cyp +\n        (start.x + end.x) / 2;\n      const cy =\n        Math.sin(x_axis_rotation) * cxp +\n        Math.cos(x_axis_rotation) * cyp +\n        (start.y + end.y) / 2;\n\n      // Step 4: Compute θ1 and Δθ\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      const delta =\n        svgAngle(\n          (x1p - cxp) / rx,\n          (y1p - cyp) / ry,\n          (-x1p - cxp) / rx,\n          (-y1p - cyp) / ry\n        ) %\n        (Math.PI * 2);\n\n      path.currentPath.absellipse(\n        cx,\n        cy,\n        rx,\n        ry,\n        theta,\n        theta + delta,\n        sweep_flag === 0,\n        x_axis_rotation\n      );\n    }\n\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy;\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n      if (ux * vy - uy * vx < 0) ang = -ang;\n      return ang;\n    }\n\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n      const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n      const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n\n      const path = new ShapePath();\n      path.moveTo(x + 2 * rx, y);\n      path.lineTo(x + w - 2 * rx, y);\n      if (rx !== 0 || ry !== 0)\n        path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n      path.lineTo(x + w, y + h - 2 * ry);\n      if (rx !== 0 || ry !== 0)\n        path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n      path.lineTo(x + 2 * rx, y + h);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n      }\n\n      path.lineTo(x, y + 2 * ry);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n      }\n\n      return path;\n    }\n\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      const regex = /(-?[\\d.?]+)[,|\\s](-?[\\d.?]+)/g;\n\n      const path = new ShapePath();\n\n      let index = 0;\n\n      node.getAttribute(\"points\").replace(regex, iterator);\n\n      path.currentPath.autoClose = true;\n\n      return path;\n    }\n\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      const regex = /(-?[\\d.?]+)[,|\\s](-?[\\d.?]+)/g;\n\n      const path = new ShapePath();\n\n      let index = 0;\n\n      node.getAttribute(\"points\").replace(regex, iterator);\n\n      path.currentPath.autoClose = false;\n\n      return path;\n    }\n\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n\n      const subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2, false);\n\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n\n      return path;\n    }\n\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n      const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n      const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n      const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n\n      const subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2, false, 0);\n\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n\n      return path;\n    }\n\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n      const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n      const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n      const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n\n      const path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n\n      return path;\n    }\n\n    //\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style); // clone style\n\n      let stylesheetStyles = {};\n\n      if (node.hasAttribute(\"class\")) {\n        const classSelectors = node\n          .getAttribute(\"class\")\n          .split(/\\s/)\n          .filter(Boolean)\n          .map((i) => i.trim());\n\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(\n            stylesheetStyles,\n            stylesheets[\".\" + classSelectors[i]]\n          );\n        }\n      }\n\n      if (node.hasAttribute(\"id\")) {\n        stylesheetStyles = Object.assign(\n          stylesheetStyles,\n          stylesheets[\"#\" + node.getAttribute(\"id\")]\n        );\n      }\n\n      function addStyle(\n        svgName: string,\n        jsName: string,\n        adjustFunction?: (v: any) => number\n      ) {\n        if (adjustFunction === undefined)\n          adjustFunction = function copy(v) {\n            if (v.startsWith(\"url\")) {\n              if (ANIGRAPH_DEBUG_MODE) {\n                console.warn(\n                    \"SVGLoader: url access in attributes is not implemented.\"\n                );\n              }\n              return undefined;\n            }\n            return v;\n          };\n\n        if (node.hasAttribute(svgName))\n          style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName])\n          style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== \"\")\n          style[jsName] = adjustFunction(node.style[svgName]);\n      }\n\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n\n      addStyle(\"fill\", \"fill\");\n      addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n      addStyle(\"opacity\", \"opacity\", clamp);\n      addStyle(\"stroke\", \"stroke\");\n      addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n      addStyle(\"stroke-width\", \"strokeWidth\", positive);\n      addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n      addStyle(\"stroke-linecap\", \"strokeLineCap\");\n      addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n      addStyle(\"visibility\", \"visibility\");\n\n      return style;\n    }\n\n    // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n    function getReflection(a, b) {\n      return a - (b - a);\n    }\n\n    // from https://github.com/ppvg/svg-numbers (MIT License)\n\n    function parseFloats(input: string, flags = undefined, stride = undefined) {\n      if (typeof input !== \"string\") {\n        throw new TypeError(\"Invalid input: \" + typeof input);\n      }\n\n      // Character groups\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/,\n      };\n\n      // States\n      const SEP = 0;\n      const INT = 1;\n      const FLOAT = 2;\n      const EXP = 3;\n\n      let state = SEP;\n      let seenComma = true;\n      let number = \"\",\n        exponent = \"\";\n      const result = [];\n\n      function throwSyntaxError(current, i, partial) {\n        const error = new SyntaxError(\n          'Unexpected character \"' + current + '\" at index ' + i + \".\"\n        );\n        // error.partial = partial;\n        throw error;\n      }\n\n      function newNumber() {\n        if (number !== \"\") {\n          if (exponent === \"\") result.push(Number(number));\n          else result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n\n        number = \"\";\n        exponent = \"\";\n      }\n\n      let current;\n      const length = input.length;\n\n      for (let i = 0; i < length; i++) {\n        current = input[i];\n\n        // check for flags\n        if (\n          Array.isArray(flags) &&\n          flags.includes(result.length % stride) &&\n          RE.FLAGS.test(current)\n        ) {\n          state = INT;\n          number = current;\n          newNumber();\n          continue;\n        }\n\n        // parse until next number\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          }\n\n          // start new number\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          }\n\n          // throw on double commas (e.g. \"1, , 2\")\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n\n            seenComma = true;\n          }\n        }\n\n        // parse integer part\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n\n          // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n          if (\n            RE.SIGN.test(current) &&\n            number.length === 1 &&\n            RE.SIGN.test(number[0])\n          ) {\n            throwSyntaxError(current, i, result);\n          }\n        }\n\n        // parse decimal part\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          }\n\n          // throw on double decimal points (e.g. \"1..2\")\n          if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n            throwSyntaxError(current, i, result);\n          }\n        }\n\n        // parse exponent part\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n\n          if (RE.SIGN.test(current)) {\n            if (exponent === \"\") {\n              exponent += current;\n              continue;\n            }\n\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        }\n\n        // end of number\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      }\n\n      // add the last number found (if any)\n      newNumber();\n\n      return result;\n    }\n\n    // Units\n\n    const units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n\n    // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n    const unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1,\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1,\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1,\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1,\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1,\n      },\n      px: {\n        px: 1,\n      },\n    };\n\n    function parseFloatWithUnits(string) {\n      let theUnit = \"px\";\n\n      if (typeof string === \"string\" || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i];\n\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n\n      let scale = undefined;\n\n      if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n        // Conversion scale from  pixels to inches, then to default units\n\n        scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n\n        if (scale < 0) {\n          // Conversion scale to pixels\n\n          scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n        }\n      }\n\n      return scale * parseFloat(string);\n    }\n\n    // Transforms\n\n    function getNodeTransform(node) {\n      if (\n        !(\n          node.hasAttribute(\"transform\") ||\n          (node.nodeName === \"use\" &&\n            (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))\n        )\n      ) {\n        return null;\n      }\n\n      const transform = parseNodeTransform(node);\n      return transform;\n      // if ( transformStack.length > 0 ) {\n\n      // \ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n      // }\n\n      // currentTransform.copy( transform );\n      // transformStack.push( transform );\n\n      // return transform;\n    }\n\n    function parseNodeTransform(node) {\n      const transform = new Matrix3();\n      const currentTransform = tempTransform0;\n\n      const translate = [0, 0];\n\n      if (\n        node.nodeName === \"use\" &&\n        (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))\n      ) {\n        const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n        const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n\n        transform.translate(tx, ty);\n        translate[0] += tx;\n        translate[1] += ty;\n      }\n\n      if (node.hasAttribute(\"transform\")) {\n        const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim();\n\n          if (transformText === \"\") continue;\n\n          const openParPos = transformText.indexOf(\"(\");\n          const closeParPos = transformText.length;\n\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.substr(0, openParPos);\n\n            const array = parseFloats(\n              transformText.substr(openParPos + 1, closeParPos - openParPos - 1)\n            );\n\n            currentTransform.identity();\n\n            switch (transformType) {\n              case \"translate\":\n                if (array.length >= 1) {\n                  const tx = array[0];\n                  let ty = tx;\n\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n\n                  currentTransform.translate(tx, ty);\n                  translate[0] += tx;\n                  translate[1] += ty;\n                }\n\n                break;\n\n              case \"rotate\":\n                if (array.length >= 1) {\n                  let angle = 0;\n                  let cx = 0;\n                  let cy = 0;\n\n                  // Angle\n                  angle = (-array[0] * Math.PI) / 180;\n\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1];\n                    cy = array[2];\n                  }\n\n                  // Rotate around center (cx, cy)\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(\n                    tempTransform2,\n                    tempTransform1\n                  );\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform.multiplyMatrices(\n                    tempTransform1,\n                    tempTransform3\n                  );\n                }\n\n                break;\n\n              case \"scale\":\n                if (array.length >= 1) {\n                  const scaleX = array[0];\n                  let scaleY = scaleX;\n\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n\n                  currentTransform.scale(scaleX, scaleY);\n                }\n\n                break;\n\n              case \"skewX\":\n                if (array.length === 1) {\n                  currentTransform.set(\n                    1,\n                    Math.tan((array[0] * Math.PI) / 180),\n                    0,\n                    0,\n                    1,\n                    0,\n                    0,\n                    0,\n                    1\n                  );\n                }\n\n                break;\n\n              case \"skewY\":\n                if (array.length === 1) {\n                  currentTransform.set(\n                    1,\n                    0,\n                    0,\n                    Math.tan((array[0] * Math.PI) / 180),\n                    1,\n                    0,\n                    0,\n                    0,\n                    1\n                  );\n                }\n\n                break;\n\n              case \"matrix\":\n                if (array.length === 6) {\n                  currentTransform.set(\n                    array[0],\n                    array[2],\n                    array[4],\n                    array[1],\n                    array[3],\n                    array[5],\n                    0,\n                    0,\n                    1\n                  );\n                }\n\n                break;\n            }\n          }\n\n          transform.premultiply(currentTransform);\n        }\n      }\n\n      return transform;\n    }\n\n    // function transformPath(path: ShapePath, m) {\n\n    // \tfunction transfVec2(v2) {\n\n    // \t\ttempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n\n    // \t\tv2.set(tempV3.x, tempV3.y);\n\n    // \t}\n\n    // \tconst isRotated = isTransformRotated(m);\n\n    // \tconst subPaths = path.subPaths;\n\n    // \tfor (let i = 0, n = subPaths.length; i < n; i++) {\n\n    // \t\tconst subPath = subPaths[i];\n    // \t\tconst curves = subPath.curves;\n\n    // \t\tfor (let j = 0; j < curves.length; j++) {\n\n    // \t\t\tconst curve = curves[j];\n\n    // \t\t\tif (curve.isLineCurve) {\n\n    // \t\t\t\ttransfVec2(curve.v1);\n    // \t\t\t\ttransfVec2(curve.v2);\n\n    // \t\t\t} else if (curve.isCubicBezierCurve) {\n\n    // \t\t\t\ttransfVec2(curve.v0);\n    // \t\t\t\ttransfVec2(curve.v1);\n    // \t\t\t\ttransfVec2(curve.v2);\n    // \t\t\t\ttransfVec2(curve.v3);\n\n    // \t\t\t} else if (curve.isQuadraticBezierCurve) {\n\n    // \t\t\t\ttransfVec2(curve.v0);\n    // \t\t\t\ttransfVec2(curve.v1);\n    // \t\t\t\ttransfVec2(curve.v2);\n\n    // \t\t\t} else if (curve.isEllipseCurve) {\n\n    // \t\t\t\tif (isRotated) {\n\n    // \t\t\t\t\tconsole.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n\n    // \t\t\t\t}\n\n    // \t\t\t\ttempV2.set(curve.aX, curve.aY);\n    // \t\t\t\ttransfVec2(tempV2);\n    // \t\t\t\tcurve.aX = tempV2.x;\n    // \t\t\t\tcurve.aY = tempV2.y;\n\n    // \t\t\t\tcurve.xRadius *= getTransformScaleX(m);\n    // \t\t\t\tcurve.yRadius *= getTransformScaleY(m);\n\n    // \t\t\t}\n\n    // \t\t}\n\n    // \t}\n\n    // }\n\n    // function isTransformRotated(m) {\n\n    // \treturn m.elements[1] !== 0 || m.elements[3] !== 0;\n\n    // }\n\n    // function getTransformScaleX(m) {\n\n    // \tconst te = m.elements;\n    // \treturn Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n\n    // }\n\n    // function getTransformScaleY(m) {\n\n    // \tconst te = m.elements;\n    // \treturn Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n\n    // }\n\n    const paths: SVGPath[] = [];\n    const stylesheets = {};\n\n    const transformStack = [];\n\n    const tempTransform0 = new Matrix3();\n    const tempTransform1 = new Matrix3();\n    const tempTransform2 = new Matrix3();\n    const tempTransform3 = new Matrix3();\n    // const tempV2 = new Vector2();\n    // const tempV3 = new Vector3();\n\n    const currentTransform = new Matrix3();\n\n    const xml = new DOMParser().parseFromString(text, \"image/svg+xml\"); // application/xml\n\n    const rootSvgNode = parseNode(\n      xml.documentElement as unknown as SVGElement,\n      {\n        fill: \"#000\",\n        stroke: undefined,\n        opacity: 1,\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: \"miter\",\n        strokeLineCap: \"butt\",\n        strokeMiterLimit: 4,\n        visibility: \"visible\",\n      }\n    );\n\n    const data: SVGParsedData = {\n      paths,\n      rootSvgNode: rootSvgNode,\n      xml: xml.documentElement,\n    };\n\n    return data;\n  }\n\n  static createShapes(shapePath: SVGPath): THREE.Shape[] {\n    // Param shapePath: a shapepath as returned by the parse function of this class\n    // Returns Shape object\n\n    const BIGNUMBER = 999999999;\n\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6,\n    };\n\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0,\n    };\n\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x;\n      const x2 = a1.x;\n      const x3 = b0.x;\n      const x4 = b1.x;\n      const y1 = a0.y;\n      const y2 = a1.y;\n      const y3 = b0.y;\n      const y4 = b1.y;\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      const t1 = nom1 / denom;\n      const t2 = nom2 / denom;\n\n      if (\n        (denom === 0 && nom1 !== 0) ||\n        t1 <= 0 ||\n        t1 >= 1 ||\n        t2 < 0 ||\n        t2 > 1\n      ) {\n        //1. lines are parallel or edges don't intersect\n\n        return null;\n      } else if (nom1 === 0 && denom === 0) {\n        //2. lines are colinear\n\n        //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n          //find position of this endpoints relatively to edge1\n          if (classifyResult.loc === IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return { x: point.x, y: point.y, t: classifyResult.t };\n          } else if (classifyResult.loc === IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n            return { x: x, y: y, t: classifyResult.t };\n          }\n        }\n\n        return null;\n      } else {\n        //3. edges intersect\n\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n\n          if (classifyResult.loc === IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return { x: point.x, y: point.y, t: classifyResult.t };\n          }\n        }\n\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n        return { x: x, y: y, t: t1 };\n      }\n    }\n\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x;\n      const ay = edgeEnd.y - edgeStart.y;\n      const bx = p.x - edgeStart.x;\n      const by = p.y - edgeStart.y;\n      const sa = ax * by - bx * ay;\n\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN;\n        classifyResult.t = 0;\n        return;\n      }\n\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION;\n        classifyResult.t = 1;\n        return;\n      }\n\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT;\n        return;\n      }\n\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT;\n        return;\n      }\n\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND;\n        return;\n      }\n\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND;\n        return;\n      }\n\n      let t;\n\n      if (ax !== 0) {\n        t = bx / ax;\n      } else {\n        t = by / ay;\n      }\n\n      classifyResult.loc = IntersectionLocationType.BETWEEN;\n      classifyResult.t = t;\n    }\n\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = [];\n      const intersections = [];\n\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1];\n        const path1EdgeEnd = path1[index];\n\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1];\n          const path2EdgeEnd = path2[index2];\n\n          const intersection = findEdgeIntersection(\n            path1EdgeStart,\n            path1EdgeEnd,\n            path2EdgeStart,\n            path2EdgeEnd\n          );\n\n          if (\n            intersection !== null &&\n            intersectionsRaw.find(\n              (i) =>\n                i.t <= intersection.t + Number.EPSILON &&\n                i.t >= intersection.t - Number.EPSILON\n            ) === undefined\n          ) {\n            intersectionsRaw.push(intersection);\n            intersections.push(new Vector2(intersection.x, intersection.y));\n          }\n        }\n      }\n\n      return intersections;\n    }\n\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2();\n      boundingBox.getCenter(center);\n\n      const allIntersections = [];\n\n      paths.forEach((path) => {\n        // check if the center of the bounding box is in the bounding box of the paths.\n        // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n        // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points);\n\n          intersections.forEach((p) => {\n            allIntersections.push({\n              identifier: path.identifier,\n              isCW: path.isCW,\n              point: p,\n            });\n          });\n        }\n      });\n\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n\n      return allIntersections;\n    }\n\n    function isHoleTo(\n      simplePath,\n      allPaths,\n      scanlineMinX,\n      scanlineMaxX,\n      _fillRule\n    ) {\n      if (_fillRule === null || _fillRule === undefined || _fillRule === \"\") {\n        _fillRule = \"nonzero\";\n      }\n\n      const centerBoundingBox = new Vector2();\n      simplePath.boundingBox.getCenter(centerBoundingBox);\n\n      const scanline = [\n        new Vector2(scanlineMinX, centerBoundingBox.y),\n        new Vector2(scanlineMaxX, centerBoundingBox.y),\n      ];\n\n      const scanlineIntersections = getScanlineIntersections(\n        scanline,\n        simplePath.boundingBox,\n        allPaths\n      );\n\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n\n      const baseIntersections = [];\n      const otherIntersections = [];\n\n      scanlineIntersections.forEach((i) => {\n        if (i.identifier === simplePath.identifier) {\n          baseIntersections.push(i);\n        } else {\n          otherIntersections.push(i);\n        }\n      });\n\n      const firstXOfPath = baseIntersections[0].point.x;\n\n      // build up the path hierarchy\n      const stack = [];\n      let i = 0;\n\n      while (\n        i < otherIntersections.length &&\n        otherIntersections[i].point.x < firstXOfPath\n      ) {\n        if (\n          stack.length > 0 &&\n          stack[stack.length - 1] === otherIntersections[i].identifier\n        ) {\n          stack.pop();\n        } else {\n          stack.push(otherIntersections[i].identifier);\n        }\n\n        i++;\n      }\n\n      stack.push(simplePath.identifier);\n\n      if (_fillRule === \"evenodd\") {\n        const isHole = stack.length % 2 === 0 ? true : false;\n        const isHoleFor = stack[stack.length - 2];\n\n        return {\n          identifier: simplePath.identifier,\n          isHole: isHole,\n          for: isHoleFor,\n        };\n      } else if (_fillRule === \"nonzero\") {\n        // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n        let isHole = true;\n        let isHoleFor = null;\n        let lastCWValue = null;\n\n        for (let i = 0; i < stack.length; i++) {\n          const identifier = stack[i];\n          if (isHole) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = false;\n            isHoleFor = identifier;\n          } else if (lastCWValue !== allPaths[identifier].isCW) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = true;\n          }\n        }\n\n        return {\n          identifier: simplePath.identifier,\n          isHole: isHole,\n          for: isHoleFor,\n        };\n      } else {\n        console.warn(\n          'fill-rule: \"' + _fillRule + '\" is currently not implemented.'\n        );\n      }\n    }\n\n    // check for self intersecting paths\n    // TO_DO\n\n    // check intersecting paths\n    // TO_DO\n\n    // prepare paths for hole detection\n    let identifier = 0;\n\n    let scanlineMinX = BIGNUMBER;\n    let scanlineMaxX = -BIGNUMBER;\n\n    let simplePaths = shapePath.subPaths.map((p) => {\n      const points = p.getPoints();\n      let maxY = -BIGNUMBER;\n      let minY = BIGNUMBER;\n      let maxX = -BIGNUMBER;\n      let minX = BIGNUMBER;\n\n      //points.forEach(p => p.y *= -1);\n\n      for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n\n        if (p.y > maxY) {\n          maxY = p.y;\n        }\n\n        if (p.y < minY) {\n          minY = p.y;\n        }\n\n        if (p.x > maxX) {\n          maxX = p.x;\n        }\n\n        if (p.x < minX) {\n          minX = p.x;\n        }\n      }\n\n      //\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1;\n      }\n\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1;\n      }\n\n      return {\n        points: points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: identifier++,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)),\n      };\n    });\n\n    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);\n\n    // check if path is solid or a hole\n    // TO_DO: need to fix fillRule since it's not captured\n    // const isAHole = simplePaths.map(p => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule));\n    const isAHole = simplePaths.map((p) =>\n      isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, undefined)\n    );\n\n    const shapesToReturn: THREE.Shape[] = [];\n    simplePaths.forEach((p) => {\n      const amIAHole = isAHole[p.identifier];\n\n      if (!amIAHole.isHole) {\n        const shape = new Shape(p.points);\n        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);\n        holes.forEach((h) => {\n          const path = simplePaths[h.identifier];\n          shape.holes.push(new Path(path.points));\n        });\n        shapesToReturn.push(shape);\n      }\n    });\n\n    return shapesToReturn;\n  }\n\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    // Param width: Stroke width\n    // Param color: As returned by THREE.Color.getStyle()\n    // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n    // Param lineCap: One of \"round\", \"square\" or \"butt\"\n    // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n    // Returns style object\n\n    width = width !== undefined ? width : 1;\n    color = color !== undefined ? color : \"#000\";\n    lineJoin = lineJoin !== undefined ? lineJoin : \"miter\";\n    lineCap = lineCap !== undefined ? lineCap : \"butt\";\n    miterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit,\n    };\n  }\n\n  static pointsToStroke(points, style, arcDivisions = 12, minDistance = 0.001) {\n    // Generates a stroke with some witdh around the given path.\n    // The path can be open or closed (last point equals to first point)\n    // Param points: Array of Vector2D (the path). Minimum 2 points.\n    // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n    // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n    // Param minDistance: Points closer to this distance will be merged. (Optional)\n    // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    if (\n      SVGLoader.pointsToStrokeWithBuffers(\n        points,\n        style,\n        arcDivisions,\n        minDistance,\n        vertices,\n        normals,\n        uvs\n      ) === 0\n    ) {\n      return null;\n    }\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n\n    return geometry;\n  }\n\n  static pointsToStrokeWithBuffers(\n    points,\n    style,\n    arcDivisions,\n    minDistance,\n    vertices = undefined,\n    normals = undefined,\n    uvs = undefined,\n    vertexOffset = 0\n  ) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n\n    const tempV2_1 = new Vector2();\n    const tempV2_2 = new Vector2();\n    const tempV2_3 = new Vector2();\n    const tempV2_4 = new Vector2();\n    const tempV2_5 = new Vector2();\n    const tempV2_6 = new Vector2();\n    const tempV2_7 = new Vector2();\n    const lastPointL = new Vector2();\n    const lastPointR = new Vector2();\n    const point0L = new Vector2();\n    const point0R = new Vector2();\n    const currentPointL = new Vector2();\n    const currentPointR = new Vector2();\n    const nextPointL = new Vector2();\n    const nextPointR = new Vector2();\n    const innerPoint = new Vector2();\n    const outerPoint = new Vector2();\n\n    // First ensure there are no duplicated points\n    points = removeDuplicatedPoints(points);\n\n    const numPoints = points.length;\n\n    if (numPoints < 2) return 0;\n\n    const isClosed = points[0].equals(points[numPoints - 1]);\n\n    let currentPoint;\n    let previousPoint = points[0];\n    let nextPoint;\n\n    const strokeWidth2 = style.strokeWidth / 2;\n\n    const deltaU = 1 / (numPoints - 1);\n    let u0 = 0,\n      u1;\n\n    let innerSideModified;\n    let joinIsOnLeftSide;\n    let isMiter;\n    let initialJoinIsOnLeftSide = false;\n\n    let numVertices = 0;\n    let currentCoordinate = vertexOffset * 3;\n    let currentCoordinateUV = vertexOffset * 2;\n\n    // Get initial left and right stroke points\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint];\n\n      // Get next point\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1];\n        } else nextPoint = undefined;\n      } else {\n        nextPoint = points[iPoint + 1];\n      }\n\n      // Normal of previous segment in tempV2_1\n      const normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n\n      u1 = u0 + deltaU;\n\n      innerSideModified = false;\n\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2);\n\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        const dot = Math.abs(normal1.dot(tempV2_3));\n\n        // If path is straight, don't create join\n        if (dot !== 0) {\n          // Compute inner and outer segment intersections\n          const miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          const miterLength2 = tempV2_5.length();\n          const segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          const segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext);\n          // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n          if (\n            tempV2_4.dot(innerPoint) < segmentLengthPrev &&\n            tempV2_6.dot(innerPoint) < segmentLengthNext\n          ) {\n            innerSideModified = true;\n          }\n\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n\n          isMiter = false;\n\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n\n            makeSegmentTriangles();\n          }\n\n          switch (style.strokeLineJoin) {\n            case \"bevel\":\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n\n              break;\n\n            case \"round\":\n              // Segment triangles\n\n              createSegmentTrianglesWithMiddleSection(\n                joinIsOnLeftSide,\n                innerSideModified\n              );\n\n              // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(\n                  currentPoint,\n                  currentPointL,\n                  nextPointL,\n                  u1,\n                  0\n                );\n              } else {\n                makeCircularSector(\n                  currentPoint,\n                  nextPointR,\n                  currentPointR,\n                  u1,\n                  1\n                );\n              }\n\n              break;\n\n            case \"miter\":\n            case \"miter-clip\":\n            default:\n              const miterFraction =\n                (strokeWidth2 * style.strokeMiterLimit) / miterLength2;\n\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n\n                if (style.strokeLineJoin !== \"miter-clip\") {\n                  makeSegmentWithBevelJoin(\n                    joinIsOnLeftSide,\n                    innerSideModified,\n                    u1\n                  );\n                  break;\n                } else {\n                  // Segment triangles\n\n                  createSegmentTrianglesWithMiddleSection(\n                    joinIsOnLeftSide,\n                    innerSideModified\n                  );\n\n                  // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6\n                      .subVectors(outerPoint, currentPointL)\n                      .multiplyScalar(miterFraction)\n                      .add(currentPointL);\n                    tempV2_7\n                      .subVectors(outerPoint, nextPointL)\n                      .multiplyScalar(miterFraction)\n                      .add(nextPointL);\n\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6\n                      .subVectors(outerPoint, currentPointR)\n                      .multiplyScalar(miterFraction)\n                      .add(currentPointR);\n                    tempV2_7\n                      .subVectors(outerPoint, nextPointR)\n                      .multiplyScalar(miterFraction)\n                      .add(nextPointR);\n\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  // Add extra miter join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n\n                isMiter = true;\n              }\n\n              break;\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n\n          makeSegmentTriangles();\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n\n        makeSegmentTriangles();\n      }\n\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      }\n\n      // Increment loop variables\n\n      u0 = u1;\n\n      previousPoint = currentPoint;\n\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(\n        currentPoint,\n        currentPointL,\n        currentPointR,\n        joinIsOnLeftSide,\n        false,\n        u1\n      );\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n      let lastOuter = outerPoint;\n      let lastInner = innerPoint;\n\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n\n    return numVertices;\n\n    // -- End of algorithm\n\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n\n        currentCoordinate += 3;\n\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n\n          currentCoordinateUV += 2;\n        }\n      }\n\n      numVertices += 3;\n    }\n\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n\n      let angle = Math.PI;\n      const dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n\n      angle /= arcDivisions;\n\n      tempV2_3.copy(p1);\n\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n\n        tempV2_3.copy(tempV2_4);\n      }\n\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n\n          // Bevel join triangle\n\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n\n          // Bevel join triangle\n\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the Component loop\n\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n\n    function createSegmentTrianglesWithMiddleSection(\n      joinIsOnLeftSide,\n      innerSideModified\n    ) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n\n      switch (style.strokeLineCap) {\n        case \"round\":\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n\n          break;\n\n        case \"square\":\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n\n            const vl = vertices.length;\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n\n          break;\n\n        case \"butt\":\n        default:\n          // Nothing to do here\n          break;\n      }\n    }\n\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n\n      let dupPoints = false;\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n\n      if (!dupPoints) return points;\n\n      const newPoints = [];\n      newPoints.push(points[0]);\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i]);\n        }\n      }\n\n      newPoints.push(points[points.length - 1]);\n\n      return newPoints;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}