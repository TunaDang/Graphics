{"ast":null,"code":"import { BoundingBox } from \"./BoundingBox\";\nimport { Mat3, V2, Vec3 } from \"../math\";\nimport { VertexArray2D } from \"./VertexArray2D\";\nexport class BoundingBox2D extends BoundingBox {\n  clone() {\n    var _this$minPoint, _this$maxPoint;\n    let cfunc = this.constructor;\n    let clone = new cfunc();\n    clone.minPoint = (_this$minPoint = this.minPoint) === null || _this$minPoint === void 0 ? void 0 : _this$minPoint.clone();\n    clone.maxPoint = (_this$maxPoint = this.maxPoint) === null || _this$maxPoint === void 0 ? void 0 : _this$maxPoint.clone();\n    clone.transform = this.transform.clone();\n    return clone;\n  }\n  static FromVec2s(verts) {\n    let va = VertexArray2D.FromLists(verts);\n    return BoundingBox2D.FromVertexArray2D(va);\n  }\n  static FromVertexArray2D(verts) {\n    let rval = new BoundingBox2D();\n    rval.boundVertexPositionArrray(verts.position);\n    return rval;\n  }\n  boundVertexPositionArrray(va) {\n    let nverts = va.nVerts;\n    for (let vi = 0; vi < nverts; vi++) {\n      this.boundPoint(va.getAt(vi));\n    }\n  }\n  constructor() {\n    super();\n    this.transform = new Mat3();\n  }\n  randomPointObjectSpace() {\n    let rand1 = Math.random();\n    let rand2 = Math.random();\n    if (!this.minPoint || !this.maxPoint) {\n      return V2();\n    }\n    return V2(this.minPoint.x * rand1 + this.maxPoint.x * (1 - rand1), this.minPoint.y * rand2 + this.maxPoint.y * (1 - rand2));\n  }\n  randomTransformedPoint() {\n    return this.transform.getMatrix().times(this.randomPointObjectSpace());\n  }\n  get center() {\n    if (!this.minPoint || !this.maxPoint) {\n      return;\n    }\n    return this.transform.getMatrix().times(this.minPoint.plus(this.maxPoint).times(0.5));\n  }\n  get localWidth() {\n    // @ts-ignore\n    return this.maxPoint.x - this.minPoint.x;\n  }\n  get localHeight() {\n    // @ts-ignore\n    return this.maxPoint.y - this.minPoint.y;\n  }\n  boundPoint(p) {\n    let p2d;\n    if (p instanceof Vec3) {\n      p2d = p.Point2D;\n    } else {\n      p2d = p;\n    }\n    if (!this.minPoint || !this.maxPoint) {\n      this.minPoint = p2d.clone();\n      this.maxPoint = p2d.clone();\n      return;\n    }\n    let ndim = this.minPoint.nDimensions;\n    for (let c = 0; c < ndim; c++) {\n      if (p2d.elements[c] < this.minPoint.elements[c]) {\n        this.minPoint.elements[c] = p2d.elements[c];\n      }\n      if (p2d.elements[c] > this.maxPoint.elements[c]) {\n        this.maxPoint.elements[c] = p2d.elements[c];\n      }\n    }\n  }\n  get corners() {\n    let tmat = this.transform.getMatrix();\n    if (!this.minPoint || !this.maxPoint) {\n      return [];\n    }\n    return [tmat.times(this.minPoint), tmat.times(V2(this.maxPoint.x, this.minPoint.y)), tmat.times(this.maxPoint), tmat.times(V2(this.minPoint.x, this.maxPoint.y))];\n  }\n  GetBoundaryLinesVertexArray() {\n    let va = new VertexArray2D();\n    let corners = this.corners;\n    if (!corners.length) {\n      return va;\n    }\n    // va.addVertex(corners[0]);\n    // va.addVertex(corners[1]);\n    // va.addVertex(corners[1]);\n    // va.addVertex(corners[2]);\n    // va.addVertex(corners[2]);\n    // va.addVertex(corners[3]);\n    // va.addVertex(corners[3]);\n    // va.addVertex(corners[0]);\n\n    va.addVertex(corners[0]);\n    va.addVertex(corners[1]);\n    // va.addVertex(corners[1]);\n    va.addVertex(corners[2]);\n    // va.addVertex(corners[2]);\n    va.addVertex(corners[3]);\n    // va.addVertex(corners[3]);\n    va.addVertex(corners[0]);\n    return va;\n  }\n  boundBounds(b) {\n    let corners = b.corners;\n    for (let c of corners) {\n      this.boundPoint(c);\n    }\n  }\n}","map":{"version":3,"names":["BoundingBox","Mat3","V2","Vec3","VertexArray2D","BoundingBox2D","clone","_this$minPoint","_this$maxPoint","cfunc","constructor","minPoint","maxPoint","transform","FromVec2s","verts","va","FromLists","FromVertexArray2D","rval","boundVertexPositionArrray","position","nverts","nVerts","vi","boundPoint","getAt","randomPointObjectSpace","rand1","Math","random","rand2","x","y","randomTransformedPoint","getMatrix","times","center","plus","localWidth","localHeight","p","p2d","Point2D","ndim","nDimensions","c","elements","corners","tmat","GetBoundaryLinesVertexArray","length","addVertex","boundBounds","b"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/geometry/BoundingBox2D.ts"],"sourcesContent":["import { BoundingBox } from \"./BoundingBox\";\nimport { NodeTransform2D} from \"../math\";\nimport {Mat3, V2, Vec2, Vec3} from \"../math\";\nimport { VertexArray2D } from \"./VertexArray2D\";\nimport { VertexAttributeArray } from \"./VertexAttributeArray\";\n\nexport class BoundingBox2D extends BoundingBox<Vec2, Mat3> {\n  clone(): this {\n    let cfunc: any = this.constructor as any;\n    let clone = new cfunc();\n    clone.minPoint = this.minPoint?.clone();\n    clone.maxPoint = this.maxPoint?.clone();\n    clone.transform = this.transform.clone();\n    return clone;\n  }\n\n  static FromVec2s(verts: Vec2[]) {\n    let va = VertexArray2D.FromLists(verts);\n    return BoundingBox2D.FromVertexArray2D(va);\n  }\n\n  static FromVertexArray2D(verts: VertexArray2D) {\n    let rval = new BoundingBox2D();\n    rval.boundVertexPositionArrray(verts.position);\n    return rval;\n  }\n\n  boundVertexPositionArrray(va: VertexAttributeArray<any>) {\n    let nverts = va.nVerts;\n    for (let vi = 0; vi < nverts; vi++) {\n      this.boundPoint(va.getAt(vi));\n    }\n  }\n\n  constructor() {\n    super();\n    this.transform = new Mat3();\n  }\n\n  randomPointObjectSpace() {\n    let rand1 = Math.random();\n    let rand2 = Math.random();\n    if (!this.minPoint || !this.maxPoint) {\n      return V2();\n    }\n    return V2(\n      this.minPoint.x * rand1 + this.maxPoint.x * (1 - rand1),\n      this.minPoint.y * rand2 + this.maxPoint.y * (1 - rand2)\n    );\n  }\n\n  randomTransformedPoint() {\n    return this.transform.getMatrix().times(this.randomPointObjectSpace());\n  }\n\n  get center() {\n    if (!this.minPoint || !this.maxPoint) {\n      return;\n    }\n    return this.transform\n      .getMatrix()\n      .times(this.minPoint.plus(this.maxPoint).times(0.5));\n  }\n\n  get localWidth() {\n    // @ts-ignore\n    return this.maxPoint.x - this.minPoint.x;\n  }\n  get localHeight() {\n    // @ts-ignore\n    return this.maxPoint.y - this.minPoint.y;\n  }\n\n  public boundPoint(p: Vec2 | Vec3): void {\n    let p2d:Vec2;\n    if (p instanceof Vec3) {\n      p2d = p.Point2D;\n    }else{\n      p2d = p;\n    }\n    if (!this.minPoint || !this.maxPoint) {\n      this.minPoint = p2d.clone();\n      this.maxPoint = p2d.clone();\n      return;\n    }\n    let ndim: number = this.minPoint.nDimensions;\n    for (let c = 0; c < ndim; c++) {\n      if (p2d.elements[c] < this.minPoint.elements[c]) {\n        this.minPoint.elements[c] = p2d.elements[c];\n      }\n      if (p2d.elements[c] > this.maxPoint.elements[c]) {\n        this.maxPoint.elements[c] = p2d.elements[c];\n      }\n    }\n  }\n\n  get corners(): Vec2[] {\n    let tmat = this.transform.getMatrix();\n    if (!this.minPoint || !this.maxPoint) {\n      return [];\n    }\n    return [\n      tmat.times(this.minPoint),\n      tmat.times(V2(this.maxPoint.x, this.minPoint.y)),\n      tmat.times(this.maxPoint),\n      tmat.times(V2(this.minPoint.x, this.maxPoint.y)),\n    ];\n  }\n\n  GetBoundaryLinesVertexArray() {\n    let va = new VertexArray2D();\n    let corners = this.corners;\n    if (!corners.length) {\n      return va;\n    }\n    // va.addVertex(corners[0]);\n    // va.addVertex(corners[1]);\n    // va.addVertex(corners[1]);\n    // va.addVertex(corners[2]);\n    // va.addVertex(corners[2]);\n    // va.addVertex(corners[3]);\n    // va.addVertex(corners[3]);\n    // va.addVertex(corners[0]);\n\n    va.addVertex(corners[0]);\n    va.addVertex(corners[1]);\n    // va.addVertex(corners[1]);\n    va.addVertex(corners[2]);\n    // va.addVertex(corners[2]);\n    va.addVertex(corners[3]);\n    // va.addVertex(corners[3]);\n    va.addVertex(corners[0]);\n    return va;\n  }\n\n  boundBounds(b: BoundingBox<any, any>) {\n    let corners = b.corners;\n    for (let c of corners) {\n      this.boundPoint(c);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}