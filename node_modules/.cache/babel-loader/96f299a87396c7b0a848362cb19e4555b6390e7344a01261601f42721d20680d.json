{"ast":null,"code":"import { ANodeModel } from \"./ANodeModel\";\nexport class ANodeModelSubclass extends ANodeModel {\n  get transform() {\n    return this._transform;\n  }\n  set transform(t) {\n    this.setTransform(t);\n  }\n  get verts() {\n    return this._geometry.verts;\n  }\n  _setVerts(verts) {\n    this._geometry.verts = verts;\n  }\n  setVerts(verts) {\n    this._setVerts(verts);\n    this.signalGeometryUpdate();\n  }\n  constructor(verts, transform) {\n    super();\n    if (transform !== undefined) {\n      this.setTransform(transform);\n      // this._transform = transform;\n    } else {\n      //setTransform can always take a TransformationInterface, so we can use it here regardless of TransformType\n      // this.setTransform();\n      this.setTransformToIdentity();\n    }\n    if (verts !== undefined) {\n      this._setVerts(verts);\n    }\n  }\n\n  // /**\n  //  * Returns the transform from object coordinates (the coordinate system where this.verts is\n  //  * defined) to world coordinates\n  //  * @returns {TransformType}\n  //  */\n  // getWorldTransform():Matrix{\n  //     let parent = this.parent;\n  //     if(parent && parent instanceof ANodeModelSubclass){\n  //         // return parent.getWorldTransform().getMat4().times(this.transform.getMat4());\n  //         return parent.getWorldTransform().times(this.transform.getMatrix());\n  //\n  //     }else{\n  //         return this.transform.getMatrix();\n  //     }\n  // }\n}","map":{"version":3,"names":["ANodeModel","ANodeModelSubclass","transform","_transform","t","setTransform","verts","_geometry","_setVerts","setVerts","signalGeometryUpdate","constructor","undefined","setTransformToIdentity"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/scene/nodeModel/NodeModelSubclass.ts"],"sourcesContent":["import {Mat4, Matrix, TransformationInterface} from \"../../math\";\nimport {VertexArray} from \"../../geometry\";\nimport {ANodeModel} from \"./ANodeModel\";\n\nexport abstract class ANodeModelSubclass<TransformType extends TransformationInterface, VertexArrayType extends VertexArray<any>> extends ANodeModel{\n    get transform():TransformType{\n        return this._transform as TransformType;\n    };\n    abstract setTransform(transform:TransformType):void;\n    abstract setTransformToIdentity():void;\n    abstract getWorldTransform():TransformationInterface;\n\n    protected set transform(t:TransformType){\n        this.setTransform(t);\n    }\n\n    get verts(): VertexArrayType{\n        return this._geometry.verts as VertexArrayType;\n    }\n\n    _setVerts(verts: VertexArrayType) {\n        this._geometry.verts=verts;\n    }\n    setVerts(verts: VertexArrayType) {\n        this._setVerts(verts);\n        this.signalGeometryUpdate();\n    }\n\n    constructor(verts?:VertexArrayType, transform?:TransformType) {\n        super();\n        if(transform !== undefined){\n            this.setTransform(transform);\n            // this._transform = transform;\n        }else{\n            //setTransform can always take a TransformationInterface, so we can use it here regardless of TransformType\n            // this.setTransform();\n            this.setTransformToIdentity();\n        }\n        if(verts !== undefined){\n            this._setVerts(verts);\n        }\n    }\n\n    // /**\n    //  * Returns the transform from object coordinates (the coordinate system where this.verts is\n    //  * defined) to world coordinates\n    //  * @returns {TransformType}\n    //  */\n    // getWorldTransform():Matrix{\n    //     let parent = this.parent;\n    //     if(parent && parent instanceof ANodeModelSubclass){\n    //         // return parent.getWorldTransform().getMat4().times(this.transform.getMat4());\n    //         return parent.getWorldTransform().times(this.transform.getMatrix());\n    //\n    //     }else{\n    //         return this.transform.getMatrix();\n    //     }\n    // }\n\n\n\n}\n"],"mappings":"AAEA,SAAQA,UAAU,QAAO,cAAc;AAEvC,OAAO,MAAeC,kBAAkB,SAAkGD,UAAU;EAChJ,IAAIE,SAASA,CAAA,EAAgB;IACzB,OAAO,IAAI,CAACC,UAAU;EAC1B;EAKA,IAAcD,SAASA,CAACE,CAAe,EAAC;IACpC,IAAI,CAACC,YAAY,CAACD,CAAC,CAAC;EACxB;EAEA,IAAIE,KAAKA,CAAA,EAAmB;IACxB,OAAO,IAAI,CAACC,SAAS,CAACD,KAAK;EAC/B;EAEAE,SAASA,CAACF,KAAsB,EAAE;IAC9B,IAAI,CAACC,SAAS,CAACD,KAAK,GAACA,KAAK;EAC9B;EACAG,QAAQA,CAACH,KAAsB,EAAE;IAC7B,IAAI,CAACE,SAAS,CAACF,KAAK,CAAC;IACrB,IAAI,CAACI,oBAAoB,CAAC,CAAC;EAC/B;EAEAC,WAAWA,CAACL,KAAsB,EAAEJ,SAAwB,EAAE;IAC1D,KAAK,CAAC,CAAC;IACP,IAAGA,SAAS,KAAKU,SAAS,EAAC;MACvB,IAAI,CAACP,YAAY,CAACH,SAAS,CAAC;MAC5B;IACJ,CAAC,MAAI;MACD;MACA;MACA,IAAI,CAACW,sBAAsB,CAAC,CAAC;IACjC;IACA,IAAGP,KAAK,KAAKM,SAAS,EAAC;MACnB,IAAI,CAACJ,SAAS,CAACF,KAAK,CAAC;IACzB;EACJ;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AAIJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}