{"ast":null,"code":"var _dec, _class;\nimport { NodeTransform3D } from \"../../math\";\nimport { VertexArray3D } from \"../../geometry\";\nimport { ANodeModelSubclass } from \"./NodeModelSubclass\";\nimport { ASerializable } from \"../../base\";\nexport let ANodeModel3D = (_dec = ASerializable(\"ANodeModel3D\"), _dec(_class = class ANodeModel3D extends ANodeModelSubclass {\n  constructor(verts, transform, ...args) {\n    super(verts, transform);\n    this._setVerts(new VertexArray3D());\n  }\n\n  /**\n   * Bounds are only transformed by the model's current (local) transform\n   * @returns {BoundingBox3D}\n   */\n  getBounds() {\n    return this.getBounds3D();\n  }\n  get zValue() {\n    return this.transform.getPosition().z;\n  }\n\n  /**\n   * Bounds are only transformed by the model's current (local) transform\n   * @returns {BoundingBox2D}\n   */\n  getBounds2D() {\n    let tpoint = new VertexArray3D();\n    tpoint.position = this.verts.position.GetTransformedByMatrix(this.transform.getMatrix());\n    return tpoint.getBounds().getBoundsXY();\n  }\n\n  /**\n   * Bounds are only transformed by the model's current (local) transform\n   * @returns {BoundingBox3D}\n   */\n  getBounds3D() {\n    // let b = this.verts.getBounds();\n    let b = this.geometry.getBounds();\n    b.transform = this.transform.getMat4();\n    return b;\n  }\n\n  /**\n   * Bounds are only transformed by the model's current (local) transform\n   * @returns {BoundingBox3D}\n   */\n  getBoundsXY() {\n    return this.getBounds3D().getBoundsXY();\n  }\n  setTransformToIdentity() {\n    // this._transform = Mat4.Identity();\n    this._transform = new NodeTransform3D();\n  }\n  setTransform(transform) {\n    if (transform instanceof NodeTransform3D) {\n      this._transform = transform;\n    } else {\n      this._transform = NodeTransform3D.FromPoseMatrix(transform.getMat4());\n    }\n  }\n\n  /**\n   * Returns the transform from object coordinates (the coordinate system where this.verts is\n   * defined) to world coordinates\n   * @returns {TransformType}\n   */\n  getWorldTransform() {\n    let parent = this.parent;\n    if (parent && parent instanceof ANodeModelSubclass) {\n      return parent.getWorldTransform().getMat4().times(this.transform.getMat4());\n    } else {\n      return this.transform.getMat4();\n    }\n  }\n}) || _class);","map":{"version":3,"names":["NodeTransform3D","VertexArray3D","ANodeModelSubclass","ASerializable","ANodeModel3D","_dec","_class","constructor","verts","transform","args","_setVerts","getBounds","getBounds3D","zValue","getPosition","z","getBounds2D","tpoint","position","GetTransformedByMatrix","getMatrix","getBoundsXY","b","geometry","getMat4","setTransformToIdentity","_transform","setTransform","FromPoseMatrix","getWorldTransform","parent","times"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/scene/nodeModel/ANodeModel3D.ts"],"sourcesContent":["import {Mat3, Mat4, NodeTransform3D, TransformationInterface} from \"../../math\";\nimport {VertexArray3D, BoundingBox2D, BoundingBox3D, HasBounds} from \"../../geometry\";\nimport {ANodeModelSubclass} from \"./NodeModelSubclass\";\nimport {ASerializable} from \"../../base\";\nimport {ANodeTransformModel2D} from \"./ANodeTransformModel2D\";\n\n@ASerializable(\"ANodeModel3D\")\nexport class ANodeModel3D extends ANodeModelSubclass<NodeTransform3D, VertexArray3D> implements HasBounds {\n    constructor(verts?:VertexArray3D, transform?:NodeTransform3D, ...args:any) {\n        super(verts, transform);\n        this._setVerts(new VertexArray3D());\n    }\n\n    /**\n     * Bounds are only transformed by the model's current (local) transform\n     * @returns {BoundingBox3D}\n     */\n    getBounds(): BoundingBox3D {\n        return this.getBounds3D();\n    }\n\n    get zValue(){\n        return this.transform.getPosition().z;\n    }\n\n    /**\n     * Bounds are only transformed by the model's current (local) transform\n     * @returns {BoundingBox2D}\n     */\n    getBounds2D(): BoundingBox2D {\n        let tpoint = new VertexArray3D()\n        tpoint.position = this.verts.position.GetTransformedByMatrix(this.transform.getMatrix());\n        return tpoint.getBounds().getBoundsXY();\n    }\n\n    /**\n     * Bounds are only transformed by the model's current (local) transform\n     * @returns {BoundingBox3D}\n     */\n    getBounds3D(): BoundingBox3D {\n        // let b = this.verts.getBounds();\n        let b = this.geometry.getBounds()\n        b.transform = this.transform.getMat4();\n        return b;\n    }\n\n    /**\n     * Bounds are only transformed by the model's current (local) transform\n     * @returns {BoundingBox3D}\n     */\n    getBoundsXY(): BoundingBox2D {\n        return this.getBounds3D().getBoundsXY();\n    }\n\n    setTransformToIdentity(){\n        // this._transform = Mat4.Identity();\n        this._transform = new NodeTransform3D();\n    }\n\n    setTransform(transform: TransformationInterface): void {\n        if(transform instanceof NodeTransform3D){\n            this._transform = transform;\n        }else {\n            this._transform = NodeTransform3D.FromPoseMatrix(transform.getMat4())\n        }\n    }\n\n    /**\n     * Returns the transform from object coordinates (the coordinate system where this.verts is\n     * defined) to world coordinates\n     * @returns {TransformType}\n     */\n    getWorldTransform():Mat4{\n        let parent = this.parent;\n        if(parent && parent instanceof ANodeModelSubclass){\n            return parent.getWorldTransform().getMat4().times(this.transform.getMat4());\n        }else{\n            return this.transform.getMat4();\n        }\n    }\n\n}\n\n\n\n"],"mappings":";AAAA,SAAoBA,eAAe,QAAgC,YAAY;AAC/E,SAAQC,aAAa,QAAgD,gBAAgB;AACrF,SAAQC,kBAAkB,QAAO,qBAAqB;AACtD,SAAQC,aAAa,QAAO,YAAY;AAGxC,WACaC,YAAY,IAAAC,IAAA,GADxBF,aAAa,CAAC,cAAc,CAAC,EAAAE,IAAA,CAAAC,MAAA,GAA9B,MACaF,YAAY,SAASF,kBAAkB,CAAsD;EACtGK,WAAWA,CAACC,KAAoB,EAAEC,SAA0B,EAAE,GAAGC,IAAQ,EAAE;IACvE,KAAK,CAACF,KAAK,EAAEC,SAAS,CAAC;IACvB,IAAI,CAACE,SAAS,CAAC,IAAIV,aAAa,CAAC,CAAC,CAAC;EACvC;;EAEA;AACJ;AACA;AACA;EACIW,SAASA,CAAA,EAAkB;IACvB,OAAO,IAAI,CAACC,WAAW,CAAC,CAAC;EAC7B;EAEA,IAAIC,MAAMA,CAAA,EAAE;IACR,OAAO,IAAI,CAACL,SAAS,CAACM,WAAW,CAAC,CAAC,CAACC,CAAC;EACzC;;EAEA;AACJ;AACA;AACA;EACIC,WAAWA,CAAA,EAAkB;IACzB,IAAIC,MAAM,GAAG,IAAIjB,aAAa,CAAC,CAAC;IAChCiB,MAAM,CAACC,QAAQ,GAAG,IAAI,CAACX,KAAK,CAACW,QAAQ,CAACC,sBAAsB,CAAC,IAAI,CAACX,SAAS,CAACY,SAAS,CAAC,CAAC,CAAC;IACxF,OAAOH,MAAM,CAACN,SAAS,CAAC,CAAC,CAACU,WAAW,CAAC,CAAC;EAC3C;;EAEA;AACJ;AACA;AACA;EACIT,WAAWA,CAAA,EAAkB;IACzB;IACA,IAAIU,CAAC,GAAG,IAAI,CAACC,QAAQ,CAACZ,SAAS,CAAC,CAAC;IACjCW,CAAC,CAACd,SAAS,GAAG,IAAI,CAACA,SAAS,CAACgB,OAAO,CAAC,CAAC;IACtC,OAAOF,CAAC;EACZ;;EAEA;AACJ;AACA;AACA;EACID,WAAWA,CAAA,EAAkB;IACzB,OAAO,IAAI,CAACT,WAAW,CAAC,CAAC,CAACS,WAAW,CAAC,CAAC;EAC3C;EAEAI,sBAAsBA,CAAA,EAAE;IACpB;IACA,IAAI,CAACC,UAAU,GAAG,IAAI3B,eAAe,CAAC,CAAC;EAC3C;EAEA4B,YAAYA,CAACnB,SAAkC,EAAQ;IACnD,IAAGA,SAAS,YAAYT,eAAe,EAAC;MACpC,IAAI,CAAC2B,UAAU,GAAGlB,SAAS;IAC/B,CAAC,MAAK;MACF,IAAI,CAACkB,UAAU,GAAG3B,eAAe,CAAC6B,cAAc,CAACpB,SAAS,CAACgB,OAAO,CAAC,CAAC,CAAC;IACzE;EACJ;;EAEA;AACJ;AACA;AACA;AACA;EACIK,iBAAiBA,CAAA,EAAO;IACpB,IAAIC,MAAM,GAAG,IAAI,CAACA,MAAM;IACxB,IAAGA,MAAM,IAAIA,MAAM,YAAY7B,kBAAkB,EAAC;MAC9C,OAAO6B,MAAM,CAACD,iBAAiB,CAAC,CAAC,CAACL,OAAO,CAAC,CAAC,CAACO,KAAK,CAAC,IAAI,CAACvB,SAAS,CAACgB,OAAO,CAAC,CAAC,CAAC;IAC/E,CAAC,MAAI;MACD,OAAO,IAAI,CAAChB,SAAS,CAACgB,OAAO,CAAC,CAAC;IACnC;EACJ;AAEJ,CAAC,KAAAnB,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}