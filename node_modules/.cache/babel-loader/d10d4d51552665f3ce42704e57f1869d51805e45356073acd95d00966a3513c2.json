{"ast":null,"code":"/**\n * For defining interactions with graphics.\n * If you want to subclass to cover a different class of interactions (e.g., not using three.interaction) you just need to change the addEventListener call to use\n */\nimport { V2, Vec2 } from \"../math\";\nimport { ACallbackSwitch } from \"../base\";\nexport let PointerEvents = /*#__PURE__*/function (PointerEvents) {\n  PointerEvents[\"POINTER_UP\"] = \"pointerup\";\n  PointerEvents[\"POINTER_DOWN\"] = \"pointerdown\";\n  PointerEvents[\"POINTER_MOVE\"] = \"pointermove\";\n  PointerEvents[\"POINTER_CLICK\"] = \"click\";\n  PointerEvents[\"POINTER_WHEEL\"] = \"wheel\";\n  PointerEvents[\"POINTER_OVER\"] = \"pointerover\";\n  return PointerEvents;\n}({});\nexport let DOMPointerEvents = /*#__PURE__*/function (DOMPointerEvents) {\n  DOMPointerEvents[\"POINTER_CLICK\"] = \"pointertap\";\n  DOMPointerEvents[\"POINTER_MOVE\"] = \"pointermove\";\n  return DOMPointerEvents;\n}({});\n\n// interface ReceivesOnOffInteractionsInterface{\n//     on(eventType:string, callback:(...args:any[])=>any):any;\n//     off(eventType:string, callback:(...args:any[])=>any):any;\n//     once(eventType:string, callback:(...args:any[])=>any):any;\n// }\n\n// ReceivesEventListenerInteractionsInterface|ReceivesOnOffInteractionsInterface;\n\nexport class AInteractionEvent {\n  constructor() {\n    this.interaction = void 0;\n    this._event = void 0;\n  } // abstract get targetModel():AModelInterface;\n}\nexport class AMockInteractionEvent extends AInteractionEvent {\n  static GetMockElement() {\n    return {\n      addEventListener: (eventType, callback, ...args) => {\n        return;\n      },\n      removeEventListener: (eventType, callback, ...args) => {}\n    };\n  }\n  get onFirstIntersection() {\n    return true;\n  }\n  constructor(interaction, cursorPosition, shiftKey = false, altKey = false, ctrlKey = false, event) {\n    super();\n    this._cursorPosition = void 0;\n    this._shiftKey = void 0;\n    this._altKey = void 0;\n    this._ctrlKey = void 0;\n    this._key = void 0;\n    this._event = void 0;\n    this._event = event;\n    if (!this._event) {\n      this._event = new PointerEvent(PointerEvents.POINTER_MOVE);\n      //new Event();\n    }\n    this._key = '';\n    this.interaction = interaction;\n    this._cursorPosition = cursorPosition;\n    this._shiftKey = shiftKey;\n    this._altKey = altKey;\n    this._ctrlKey = ctrlKey;\n  }\n  get key() {\n    return this._key;\n  }\n  get DOMEvent() {\n    return this._event;\n  }\n  preventDefault() {}\n  elementIsTarget(event) {\n    return true;\n  }\n  get eventIsOnTarget() {\n    return true;\n  }\n  get positionInContext() {\n    return this._cursorPosition;\n  }\n  get cursorPosition() {\n    return this._cursorPosition;\n  }\n  get cursorPositionCenterOrigin() {\n    console.warn(\"Cursor position center origin not implemented in mock events\");\n    return this._cursorPosition;\n  }\n  get ndcCursor() {\n    console.warn(\"NDC Cursor position not implemented in mock events\");\n    return this._cursorPosition;\n  }\n\n  // get targetModel(){\n  //     return (this.interaction.owner as ASceneNodeController<any>).sceneController.model;\n  // }\n  get shiftKey() {\n    return this._shiftKey;\n  }\n  get altKey() {\n    return this._altKey;\n  }\n  get ctrlKey() {\n    return this._ctrlKey;\n  }\n}\nexport class ADOMInteractionEvent extends AInteractionEvent {\n  constructor(event, interaction) {\n    super();\n    this._event = void 0;\n    this._event = event;\n    this.interaction = interaction;\n  }\n  get onFirstIntersection() {\n    return true;\n  }\n  get DOMEvent() {\n    return this._event;\n  }\n  get shiftKey() {\n    return this._event.shiftKey;\n  }\n  get altKey() {\n    return this._event.altKey;\n  }\n  get ctrlKey() {\n    return this._event.ctrlKey;\n  }\n  preventDefault() {\n    this._event.preventDefault();\n  }\n  elementIsTarget(element) {\n    return this._event.target === element;\n  }\n  get positionInContext() {\n    const contextElement = this.interaction.owner.eventTarget;\n    if (contextElement instanceof Element) {\n      const svgrect = contextElement.getBoundingClientRect();\n      // @ts-ignore\n      return new Vec2(this._event.clientX - svgrect.left, this._event.clientY - svgrect.top);\n    } else return null;\n  }\n  get cursorPosition() {\n    return this.positionInContext;\n  }\n  get cursorPositionCenterOrigin() {\n    const contextElement = this.interaction.owner.eventTarget;\n    if (contextElement instanceof HTMLElement) {\n      const contextRect = contextElement.getBoundingClientRect();\n      let midpoint = V2(contextRect.right - contextRect.left, contextRect.bottom - contextRect.top).times(0.5);\n      // @ts-ignore\n      return new Vec2(this._event.clientX - contextRect.left - midpoint.x, contextRect.top - this._event.clientY + midpoint.y);\n    } else {\n      return null;\n    }\n  }\n  get ndcCursor() {\n    const contextElement = this.interaction.owner.eventTarget;\n    if (contextElement instanceof HTMLElement) {\n      const contextRect = contextElement.getBoundingClientRect();\n      let contextw = contextRect.right - contextRect.left;\n      let contexth = contextRect.bottom - contextRect.top;\n      let midpoint = V2(contextw * 0.5, contexth * 0.5);\n      // @ts-ignore\n      let cunnormalized = new Vec2(this._event.clientX - contextRect.left - midpoint.x, contextRect.top - this._event.clientY + midpoint.y);\n      return new Vec2(cunnormalized.x / contextw, cunnormalized.y / contexth).times(2);\n    } else {\n      return null;\n    }\n  }\n  // get targetModel(){\n  //     return (this.interaction.owner as ASceneNodeController<any>).sceneController.model;\n  // }\n  get eventIsOnTarget() {\n    return this._event.target === this._event.currentTarget;\n  }\n  get key() {\n    return this.DOMEvent.key;\n  }\n}\nexport class AInteraction extends ACallbackSwitch {\n  setInteractionState(name, value) {\n    this.interactionState[name] = value;\n  }\n  getInteractionState(name) {\n    return this.interactionState[name];\n  }\n  clearInteractionState() {\n    this.interactionState = {};\n  }\n  _shouldIgnoreEvent(event) {\n    return false;\n  }\n\n  // static Create(element:any, clickCallback?:CallbackType, handle?:string, ...args:any[]);\n\n  getWindowElement() {\n    return window;\n  }\n\n  // getSceneElement(){\n  //     // return this.owner.sceneController.view._backgroundElement;\n  //     if(!('sceneController' in this.owner)){throw new Error(\"Tried to get scene element on controller class without a sceneController property...\");}\n  //     // return (this.owner as ASceneNodeController<any>).sceneController.view.backgroundThreeJSObject;\n  //     return this.owner.sceneController.view.threejs;\n  // }\n\n  /**\n   * Event listeners is a list of event listeners associated with the interaction. Often this may just be a single event listener, but in the case of, for example, dragging, it may contain multiple event listeners.\n   * And event listener is one call of [...].on(...).\n   * @type {any[]}\n   * @private\n   */\n  /** Get eventListeners */\n  get eventListeners() {\n    return this._eventListeners;\n  }\n  /**\n   *\n   * @param element\n   * @param eventListeners\n   * @param onlyMouseDownOnTarget - should this trigger only when the element is the target of the interaction. Defaults to true.\n   * @param handle\n   */\n  constructor(element, eventListeners, handle) {\n    super(handle);\n    this.interactionState = {};\n    this._eventListeners = void 0;\n    /**\n     * `owner` is whatever holds the interactions.\n     * @type {HasInteractions}\n     */\n    this.owner = void 0;\n    /**\n     * `element` is typically the thing being interacted with. For example, if you are adding a click interaction to a THREE.Mesh, then the element would be the THREE.Mesh.\n     * @type {any}\n     */\n    // public element: AReceivesInteractionsInterface;\n    this.element = void 0;\n    this.onlyOnFirstIntersection = true;\n    this.element = element;\n    this._eventListeners = eventListeners ? eventListeners : [];\n  }\n  bindMethods() {}\n  addEventListener(eventType, callback) {\n    const interaction = this;\n    // const modcallbackmock = function(event:AInteractionEvent){\n    //     callback(event);\n    // }\n    const modcallback = function (event) {\n      if (!interaction._shouldIgnoreEvent(event)) {\n        callback(new ADOMInteractionEvent(event, interaction));\n      }\n    };\n    function addListener() {\n      interaction.element.addEventListener(eventType, modcallback);\n    }\n    function removeListener() {\n      interaction.element.removeEventListener(eventType, modcallback);\n    }\n    const eventListener = {\n      eventType: eventType,\n      addListener: addListener,\n      removeListener: removeListener\n    };\n    eventListener.addListener = eventListener.addListener.bind(eventListener);\n    eventListener.removeListener = eventListener.removeListener.bind(eventListener);\n    this.eventListeners.push(eventListener);\n    return eventListener;\n  }\n  addDOMEventListener(eventType, callback, options) {\n    const interaction = this;\n    // @ts-ignore\n    const once = options !== undefined && typeof options !== \"boolean\" ? options.once : false;\n    // @ts-ignore\n    const capture = options !== undefined && typeof options !== \"boolean\" ? options.capture : false;\n    let modcallback = function (event) {\n      // if(!interaction._shouldIgnoreEvent(event)) {\n      callback(new ADOMInteractionEvent(event, interaction));\n      // }\n    };\n    function addListener() {\n      // this.active = true;\n      // @ts-ignore\n      interaction.element.addEventListener(eventType, modcallback, {\n        once: once,\n        capture: capture\n      });\n    }\n    function removeListener() {\n      // this.active=false;\n      // @ts-ignore\n      interaction.element.removeEventListener(eventType, modcallback, {\n        once: once,\n        capture: capture\n      });\n    }\n    const eventListener = {\n      eventType: eventType,\n      addListener: addListener,\n      removeListener: removeListener\n    };\n    eventListener.addListener = eventListener.addListener.bind(eventListener);\n    eventListener.removeListener = eventListener.removeListener.bind(eventListener);\n    this.eventListeners.push(eventListener);\n    return eventListener;\n  }\n  activate() {\n    // if(!this.isActive) {\n    this.deactivate();\n    for (let eventListener of this.eventListeners) {\n      eventListener.addListener();\n    }\n    this.active = true;\n    // }\n  }\n  _deactivateEventListeners() {\n    for (let eventListener of this.eventListeners) {\n      eventListener.removeListener();\n    }\n  }\n  clearEventListeners() {\n    this._deactivateEventListeners();\n    this._eventListeners = [];\n  }\n  deactivate() {\n    // if(this.isActive){\n    this._deactivateEventListeners();\n    this.active = false;\n    // }\n  }\n  dispose() {\n    this.deactivate();\n    this._eventListeners = [];\n    // super.dispose();\n  }\n}","map":{"version":3,"names":["V2","Vec2","ACallbackSwitch","PointerEvents","DOMPointerEvents","AInteractionEvent","constructor","interaction","_event","AMockInteractionEvent","GetMockElement","addEventListener","eventType","callback","args","removeEventListener","onFirstIntersection","cursorPosition","shiftKey","altKey","ctrlKey","event","_cursorPosition","_shiftKey","_altKey","_ctrlKey","_key","PointerEvent","POINTER_MOVE","key","DOMEvent","preventDefault","elementIsTarget","eventIsOnTarget","positionInContext","cursorPositionCenterOrigin","console","warn","ndcCursor","ADOMInteractionEvent","element","target","contextElement","owner","eventTarget","Element","svgrect","getBoundingClientRect","clientX","left","clientY","top","HTMLElement","contextRect","midpoint","right","bottom","times","x","y","contextw","contexth","cunnormalized","currentTarget","AInteraction","setInteractionState","name","value","interactionState","getInteractionState","clearInteractionState","_shouldIgnoreEvent","getWindowElement","window","eventListeners","_eventListeners","handle","onlyOnFirstIntersection","bindMethods","modcallback","addListener","removeListener","eventListener","bind","push","addDOMEventListener","options","once","undefined","capture","activate","deactivate","active","_deactivateEventListeners","clearEventListeners","dispose"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/interaction/AInteraction.ts"],"sourcesContent":["/**\n * For defining interactions with graphics.\n * If you want to subclass to cover a different class of interactions (e.g., not using three.interaction) you just need to change the addEventListener call to use\n */\nimport {V2, Vec2} from \"../math\";\nimport {ACallbackSwitch} from \"../base\";\nimport {HasInteractions} from \"../base/amvc/HasInteractions\";\n\nexport const enum PointerEvents{\n    POINTER_UP = 'pointerup',\n    POINTER_DOWN='pointerdown',\n    POINTER_MOVE = 'pointermove',\n    POINTER_CLICK = 'click',\n    POINTER_WHEEL='wheel',\n    POINTER_OVER='pointerover'\n}\n\nexport const enum DOMPointerEvents{\n    POINTER_CLICK = 'pointertap',\n    POINTER_MOVE = 'pointermove',\n}\n\n\n// interface ReceivesOnOffInteractionsInterface{\n//     on(eventType:string, callback:(...args:any[])=>any):any;\n//     off(eventType:string, callback:(...args:any[])=>any):any;\n//     once(eventType:string, callback:(...args:any[])=>any):any;\n// }\n\ninterface ReceivesEventListenerInteractionsInterface{\n    addEventListener(eventType:string, callback:(event:any)=>any, ...args:any[]):any;\n    removeEventListener(eventType:string, callback:(event:any)=>any, ...args:any[]):any;\n}\n\nexport type AReceivesInteractionsInterface =ReceivesEventListenerInteractionsInterface;\n    // ReceivesEventListenerInteractionsInterface|ReceivesOnOffInteractionsInterface;\n\nexport interface AInteractionEventListener{\n    eventType: string;\n    addListener: () => void;\n    removeListener: () => void;\n}\n\nexport interface InteractionEventInterface extends Event{\n    clientX?:number;\n    clientY?:number;\n    key?:string;\n    code?:string;\n}\n\n\nexport abstract class AInteractionEvent{\n    public interaction!:AInteraction;\n    abstract _event:InteractionEventInterface;\n    abstract get DOMEvent():Event;\n    abstract preventDefault():void;\n    abstract elementIsTarget(event:AReceivesInteractionsInterface):boolean;\n    abstract get eventIsOnTarget():boolean;\n    abstract get positionInContext():Vec2|null;\n    abstract get cursorPosition():Vec2|null;\n    abstract get cursorPositionCenterOrigin():Vec2|null;\n    abstract get ndcCursor():Vec2|null;\n    // abstract get targetModel():AModelInterface;\n    abstract get shiftKey():boolean;\n    abstract get altKey():boolean;\n    abstract get ctrlKey():boolean;\n    abstract get onFirstIntersection():boolean;\n    abstract get key():string;\n}\n\nexport class AMockInteractionEvent extends AInteractionEvent{\n    public _cursorPosition:Vec2;\n    _shiftKey:boolean;\n    _altKey:boolean;\n    _ctrlKey:boolean;\n    _key:string;\n    static GetMockElement(){\n        return {\n            addEventListener:(eventType:string, callback:(event:any)=>any, ...args:any[])=>{return;},\n            removeEventListener:(eventType:string, callback:(event:any)=>any, ...args:any[])=>{}\n        }\n    }\n    get onFirstIntersection(){return true;}\n    public _event!:InteractionEventInterface;\n    constructor(interaction:AInteraction, cursorPosition:Vec2, shiftKey:boolean=false, altKey:boolean=false, ctrlKey:boolean=false, event?:InteractionEventInterface){\n        super();\n        this._event = (event as InteractionEventInterface);\n        if(!this._event){\n            this._event = new PointerEvent(PointerEvents.POINTER_MOVE);\n            //new Event();\n        }\n        this._key = '';\n        this.interaction=interaction;\n        this._cursorPosition = cursorPosition;\n        this._shiftKey = shiftKey;\n        this._altKey = altKey;\n        this._ctrlKey=ctrlKey;\n    }\n    get key(){return this._key;}\n    get DOMEvent(){return this._event;}\n    preventDefault(){}\n    elementIsTarget(event:AReceivesInteractionsInterface){return true;};\n    get eventIsOnTarget(){return true;}\n    get positionInContext() {return this._cursorPosition;};\n    get cursorPosition(){return this._cursorPosition;};\n    get cursorPositionCenterOrigin(){\n        console.warn(\"Cursor position center origin not implemented in mock events\")\n        return this._cursorPosition;\n    }\n    get ndcCursor(){\n        console.warn(\"NDC Cursor position not implemented in mock events\")\n        return this._cursorPosition;\n    }\n\n    // get targetModel(){\n    //     return (this.interaction.owner as ASceneNodeController<any>).sceneController.model;\n    // }\n    get shiftKey(){return this._shiftKey};\n    get altKey(){return this._altKey;};\n    get ctrlKey(){return this._ctrlKey;}\n}\n\n\nexport class ADOMInteractionEvent extends AInteractionEvent{\n    public _event:InteractionEventInterface;\n    constructor(event:InteractionEventInterface, interaction:AInteraction){\n        super();\n        this._event = event;\n        this.interaction=interaction;\n    }\n    get onFirstIntersection(){return true;}\n    get DOMEvent() {\n        return this._event;\n    }\n    get shiftKey(){\n        return (this._event as PointerEvent).shiftKey;\n    }\n    get altKey(){\n        return (this._event as PointerEvent).altKey;\n    }\n    get ctrlKey(){\n        return (this._event as PointerEvent).ctrlKey;\n    }\n\n    preventDefault(){\n        this._event.preventDefault();\n    }\n    elementIsTarget(element:AReceivesInteractionsInterface){\n        return this._event.target===element;\n    }\n    get positionInContext(){\n        const contextElement = this.interaction.owner.eventTarget;\n        if(contextElement instanceof Element) {\n            const svgrect = contextElement.getBoundingClientRect();\n            // @ts-ignore\n            return new Vec2(this._event.clientX-svgrect.left, this._event.clientY-svgrect.top);\n        }\n        else return null;\n\n    }\n    get cursorPosition(){\n        return this.positionInContext;\n    }\n\n    get cursorPositionCenterOrigin(){\n        const contextElement = this.interaction.owner.eventTarget;\n        if(contextElement instanceof HTMLElement) {\n            const contextRect = contextElement.getBoundingClientRect();\n            let midpoint = V2(contextRect.right - contextRect.left, contextRect.bottom - contextRect.top).times(0.5);\n            // @ts-ignore\n            return new Vec2(this._event.clientX - contextRect.left - midpoint.x, contextRect.top - this._event.clientY + midpoint.y\n            );\n        }else{\n            return null;\n        }\n    }\n\n    get ndcCursor(){\n        const contextElement = this.interaction.owner.eventTarget;\n        if(contextElement instanceof HTMLElement) {\n            const contextRect = contextElement.getBoundingClientRect();\n            let contextw = contextRect.right - contextRect.left;\n            let contexth = contextRect.bottom - contextRect.top;\n            let midpoint = V2(contextw*0.5, contexth*0.5);\n            // @ts-ignore\n            let cunnormalized = new Vec2(this._event.clientX - contextRect.left - midpoint.x, contextRect.top - this._event.clientY + midpoint.y\n            );\n            return new Vec2(cunnormalized.x/contextw, cunnormalized.y/contexth).times(2);\n        }else{\n            return null;\n        }\n    }\n    // get targetModel(){\n    //     return (this.interaction.owner as ASceneNodeController<any>).sceneController.model;\n    // }\n    get eventIsOnTarget(){\n        return this._event.target===this._event.currentTarget;\n    }\n\n    get key(){\n        return (this.DOMEvent as KeyboardEvent).key;\n    }\n}\n\n\nexport class AInteraction extends ACallbackSwitch {\n    public interactionState:{[name:string]:any}={};\n    setInteractionState(name:string, value:any){\n        this.interactionState[name]=value;\n    }\n    getInteractionState(name:string){\n        return this.interactionState[name];\n    }\n    clearInteractionState(){\n        this.interactionState={};\n    }\n    protected _eventListeners:AInteractionEventListener[];\n\n    /**\n     * `owner` is whatever holds the interactions.\n     * @type {HasInteractions}\n     */\n    public owner!: HasInteractions;\n    /**\n     * `element` is typically the thing being interacted with. For example, if you are adding a click interaction to a THREE.Mesh, then the element would be the THREE.Mesh.\n     * @type {any}\n     */\n    // public element: AReceivesInteractionsInterface;\n    public element:AReceivesInteractionsInterface;\n\n    public onlyOnFirstIntersection:boolean=true;\n\n    _shouldIgnoreEvent(event:Event|AInteractionEvent){\n            return false;\n    }\n\n    // static Create(element:any, clickCallback?:CallbackType, handle?:string, ...args:any[]);\n\n    getWindowElement(){\n        return window;\n    }\n\n    // getSceneElement(){\n    //     // return this.owner.sceneController.view._backgroundElement;\n    //     if(!('sceneController' in this.owner)){throw new Error(\"Tried to get scene element on controller class without a sceneController property...\");}\n    //     // return (this.owner as ASceneNodeController<any>).sceneController.view.backgroundThreeJSObject;\n    //     return this.owner.sceneController.view.threejs;\n    // }\n\n    /**\n     * Event listeners is a list of event listeners associated with the interaction. Often this may just be a single event listener, but in the case of, for example, dragging, it may contain multiple event listeners.\n     * And event listener is one call of [...].on(...).\n     * @type {any[]}\n     * @private\n     */\n    /** Get eventListeners */\n    get eventListeners(){return this._eventListeners;};\n\n    /**\n     *\n     * @param element\n     * @param eventListeners\n     * @param onlyMouseDownOnTarget - should this trigger only when the element is the target of the interaction. Defaults to true.\n     * @param handle\n     */\n    constructor(element:AReceivesInteractionsInterface, eventListeners?:AInteractionEventListener[], handle?:string){\n        super(handle);\n        this.element = element;\n        this._eventListeners = eventListeners?eventListeners:[];\n    }\n\n    bindMethods(){\n\n    }\n\n    addEventListener(eventType:string, callback:(...args:any[])=>any){\n        const interaction = this;\n        // const modcallbackmock = function(event:AInteractionEvent){\n        //     callback(event);\n        // }\n        const modcallback = function(event:Event){\n            if(!interaction._shouldIgnoreEvent(event)) {\n                callback(new ADOMInteractionEvent(event, interaction));\n            }\n        }\n        function addListener(this:AInteractionEventListener){\n            interaction.element.addEventListener(eventType, modcallback);\n        }\n\n        function removeListener(this:AInteractionEventListener){\n            interaction.element.removeEventListener(eventType, modcallback);\n        }\n        const eventListener = {eventType:eventType, addListener: addListener, removeListener: removeListener};\n        eventListener.addListener = eventListener.addListener.bind(eventListener);\n        eventListener.removeListener = eventListener.removeListener.bind(eventListener)\n        this.eventListeners.push(eventListener);\n        return eventListener;\n    }\n\n    addDOMEventListener(eventType: string, callback: (...args: any[]) => any, options?: boolean | AddEventListenerOptions){\n        const interaction = this;\n        // @ts-ignore\n        const once:boolean = ((options!==undefined) && ((typeof options)!==\"boolean\"))?options.once:false;\n        // @ts-ignore\n        const capture:boolean = ((options!==undefined) && ((typeof options)!==\"boolean\"))?options.capture:false;\n\n        let modcallback = function(event:InteractionEventInterface){\n            // if(!interaction._shouldIgnoreEvent(event)) {\n                callback(new ADOMInteractionEvent(event, interaction));\n            // }\n        }\n        function addListener(){\n            // this.active = true;\n            // @ts-ignore\n            interaction.element.addEventListener(eventType, modcallback, {once:once, capture:capture});\n        }\n        function removeListener(){\n            // this.active=false;\n            // @ts-ignore\n            interaction.element.removeEventListener(eventType, modcallback, {once:once, capture:capture});\n        }\n        const eventListener = {eventType:eventType, addListener: addListener, removeListener: removeListener};\n        eventListener.addListener = eventListener.addListener.bind(eventListener);\n        eventListener.removeListener = eventListener.removeListener.bind(eventListener)\n        this.eventListeners.push(eventListener);\n        return eventListener;\n    };\n\n\n    activate() {\n        // if(!this.isActive) {\n        this.deactivate();\n        for (let eventListener of this.eventListeners) {\n            eventListener.addListener();\n        }\n        this.active = true;\n        // }\n    }\n\n    _deactivateEventListeners() {\n        for (let eventListener of this.eventListeners) {\n            eventListener.removeListener();\n        }\n    }\n\n    clearEventListeners() {\n        this._deactivateEventListeners();\n        this._eventListeners = [];\n    }\n\n    deactivate() {\n        // if(this.isActive){\n        this._deactivateEventListeners();\n        this.active = false;\n        // }\n    }\n\n    dispose() {\n        this.deactivate();\n        this._eventListeners = [];\n        // super.dispose();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}