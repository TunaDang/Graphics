{"ast":null,"code":"import { AObjectNode } from \"../aobject\";\nimport { AClock } from \"../../time\";\nimport { AInteractionModeMap, BasicInteractionModes } from \"../../interaction\";\nimport { v4 as uuidv4 } from \"uuid\";\nexport class AController extends AObjectNode {\n  get time() {\n    return this._clock.time;\n  }\n  /**\n   * Interaction mode map. Has a .modes property that maps mode names to AInteractionModes.\n   * @type {AInteractionModeMap}\n   * @protected\n   */\n\n  /**\n   * Getter for the current interaction mode.\n   * @returns {AInteractionMode}\n   */\n  get interactionMode() {\n    return this._interactions.modes[this._currentInteractionModeName];\n  }\n  constructor() {\n    super();\n    this._model = void 0;\n    this._clock = void 0;\n    this._interactions = void 0;\n    /**\n     * Right now, controllers are restricted to having one or zero active modes at a time. The name of the current mode, which can be active or inactive, is stored here.\n     * @type {string}\n     * @protected\n     */\n    this._currentInteractionModeName = void 0;\n    this._clock = new AClock();\n    this._clock.play();\n    this._interactions = new AInteractionModeMap(this);\n    this._currentInteractionModeName = BasicInteractionModes.default;\n  }\n  getContextDOMElement() {\n    return this.sceneController.context.renderer.domElement;\n  }\n\n  /**\n   * Add an interaction to the current mode.\n   * @param interaction\n   */\n  addInteraction(interaction) {\n    this.interactionMode.addInteraction(interaction);\n    // interaction.owner = this;\n    return interaction;\n  }\n  activateInteractions() {\n    this.interactionMode.activate();\n  }\n  setCurrentInteractionMode(name) {\n    this.interactionMode.deactivate();\n    let activeMode = name ? name : BasicInteractionModes.default;\n    this._interactions.setActiveMode(activeMode);\n    this._currentInteractionModeName = activeMode;\n  }\n  defineInteractionMode(name, mode) {\n    this._interactions.defineMode(name, mode);\n  }\n  clearInteractionMode(name) {\n    this._interactions.undefineMode(name);\n  }\n  clearAllInteractionModes() {\n    this._interactions.clearAllModes();\n    this._interactions = new AInteractionModeMap(this);\n  }\n  isInteractionModeDefined(name) {\n    return this._interactions.modeIsDefined(name);\n  }\n\n  /**\n   * If you provide a handle, then the action will not call so long as an existing subscription by that handle exists.\n   * This means that you won't duplicate the action before one has finished previously.\n   * @param callback\n   * @param duration\n   * @param tween\n   * @param actionOverCallback\n   * @param handle\n   */\n  addTimedAction(callback, duration, actionOverCallback, tween, handle) {\n    if (handle && handle in this._subscriptions) {\n      return;\n    }\n    const self = this;\n    const subscriptionHandle = handle !== null && handle !== void 0 ? handle : uuidv4();\n    this.subscribe(this._clock.CreateTimedAction(callback, duration, () => {\n      self.unsubscribe(subscriptionHandle);\n      if (actionOverCallback) {\n        actionOverCallback();\n      }\n    }, tween), subscriptionHandle);\n  }\n  release(...args) {\n    this.dispose();\n    super.release(...args);\n  }\n  dispose() {\n    this._interactions.dispose();\n  }\n}","map":{"version":3,"names":["AObjectNode","AClock","AInteractionModeMap","BasicInteractionModes","v4","uuidv4","AController","time","_clock","interactionMode","_interactions","modes","_currentInteractionModeName","constructor","_model","play","default","getContextDOMElement","sceneController","context","renderer","domElement","addInteraction","interaction","activateInteractions","activate","setCurrentInteractionMode","name","deactivate","activeMode","setActiveMode","defineInteractionMode","mode","defineMode","clearInteractionMode","undefineMode","clearAllInteractionModes","clearAllModes","isInteractionModeDefined","modeIsDefined","addTimedAction","callback","duration","actionOverCallback","tween","handle","_subscriptions","self","subscriptionHandle","subscribe","CreateTimedAction","unsubscribe","release","args","dispose"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/base/amvc/AController.ts"],"sourcesContent":["import {AModel} from \"./AModel\";\nimport {AObjectNode} from \"../aobject\";\nimport {AClock} from \"../../time\";\nimport {AInteraction, AInteractionMode, AInteractionModeMap, BasicInteractionModes} from \"../../interaction\";\nimport {CallbackType} from \"../../basictypes\";\nimport {BezierTween} from \"../../geometry\";\nimport {AGLContext, AGLRenderWindow} from \"../../rendering\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {HasInteractions} from \"./HasInteractions\";\n\nexport interface AControllerInterface{\n    sceneController:SceneControllerInterface;\n    get eventTarget():HTMLElement;\n}\n\nexport interface SceneControllerInterface extends AControllerInterface{\n    get isReadyToRender():boolean;\n    initRendering(contextView:AGLRenderWindow):Promise<void>;\n    onAnimationFrameCallback(context:AGLContext):void;\n    onWindowResize(renderWindow:AGLRenderWindow):void;\n    get renderWindow():AGLRenderWindow;\n    get context():AGLContext;\n}\n\nexport abstract class AController extends AObjectNode implements AControllerInterface, HasInteractions{\n    protected _model!:AModel;\n    protected _clock: AClock;\n    get time(){\n        return this._clock.time;\n    }\n    abstract get sceneController():SceneControllerInterface;\n    abstract get eventTarget():HTMLElement;\n\n    /**\n     * Interaction mode map. Has a .modes property that maps mode names to AInteractionModes.\n     * @type {AInteractionModeMap}\n     * @protected\n     */\n    protected _interactions!: AInteractionModeMap;\n    /**\n     * Right now, controllers are restricted to having one or zero active modes at a time. The name of the current mode, which can be active or inactive, is stored here.\n     * @type {string}\n     * @protected\n     */\n    protected _currentInteractionModeName: string;\n\n\n    /**\n     * Getter for the current interaction mode.\n     * @returns {AInteractionMode}\n     */\n    get interactionMode() {\n        return this._interactions.modes[this._currentInteractionModeName];\n    }\n\n    constructor() {\n        super();\n        this._clock = new AClock();\n        this._clock.play();\n        this._interactions = new AInteractionModeMap(this);\n        this._currentInteractionModeName = BasicInteractionModes.default;\n    }\n\n    getContextDOMElement(){\n        return this.sceneController.context.renderer.domElement;\n    }\n\n    /**\n     * Add an interaction to the current mode.\n     * @param interaction\n     */\n    addInteraction(interaction: AInteraction) {\n        this.interactionMode.addInteraction(interaction);\n        // interaction.owner = this;\n        return interaction;\n    }\n\n    activateInteractions() {\n        this.interactionMode.activate();\n    }\n\n    setCurrentInteractionMode(name?: string) {\n        this.interactionMode.deactivate();\n        let activeMode = name ? name : BasicInteractionModes.default;\n        this._interactions.setActiveMode(activeMode);\n        this._currentInteractionModeName = activeMode;\n    }\n\n    defineInteractionMode(name: string, mode?: AInteractionMode) {\n        this._interactions.defineMode(name, mode);\n    }\n\n    clearInteractionMode(name: string) {\n        this._interactions.undefineMode(name)\n    }\n\n    clearAllInteractionModes(){\n        this._interactions.clearAllModes();\n        this._interactions = new AInteractionModeMap(this);\n    }\n\n    isInteractionModeDefined(name: string):boolean {\n        return this._interactions.modeIsDefined(name);\n    }\n\n\n    /**\n     * If you provide a handle, then the action will not call so long as an existing subscription by that handle exists.\n     * This means that you won't duplicate the action before one has finished previously.\n     * @param callback\n     * @param duration\n     * @param tween\n     * @param actionOverCallback\n     * @param handle\n     */\n    addTimedAction(callback: (actionProgress: number) => any, duration: number, actionOverCallback?: CallbackType, tween?: BezierTween, handle?: string) {\n        if (handle && (handle in this._subscriptions)) {\n            return;\n        }\n        const self = this;\n        const subscriptionHandle = handle ?? uuidv4();\n        this.subscribe(this._clock.CreateTimedAction(callback, duration, () => {\n                self.unsubscribe(subscriptionHandle);\n                if (actionOverCallback) {\n                    actionOverCallback();\n                }\n            }, tween),\n            subscriptionHandle);\n    }\n\n    release(...args: undefined[]) {\n        this.dispose();\n        super.release(...args);\n    }\n\n    dispose() {\n        this._interactions.dispose();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}