{"ast":null,"code":"import { Mat4, Vec4 } from \"../../../anigraph\";\n\n/*\nThe function below is technically optional, in that we won't grade it directly, but implementing it may save you some repeated effort on other parts.\nFor the curious, it also provides a convenient way to explore other types of splines.\n */\n\n/**\n * Calculates the value of a cubic spline segment at a given parameter alpha using a transformation matrix.\n *\n * This function blends four control points (p0, p1, p2, p3) based on the parameter alpha and a 4x4 matrix.\n * The matrix influences the shape of the spline, allowing for different types of splines like Bezier or Catmull-Rom.\n *\n * @param {number} alpha - A value between 0 and 1 representing the position along the spline segment.\n * @param {Mat4} matrix - A 4x4 transformation matrix that dictates the blending of the control points.\n    (Hint: the Mat4 class has many useful helper getters for you to get specific elements of a Matrix.\n    e.g. you can get any column or row of a matrix easily)\n * @param {VectorBase} p0 - The first control point of the spline segment.\n * @param {VectorBase} p1 - The second control point of the spline segment.\n * @param {VectorBase} p2 - The third control point of the spline segment.\n * @param {VectorBase} p3 - The fourth control point of the spline segment.\n *\n * @returns {VectorBase} - The calculated position on the spline at the specified alpha.\n *\n * Example:\n * - For alpha = 0, the function returns the position at p0.\n * - For alpha = 1, the function returns the position at p3.\n * - For values between 0 and 1, the function interpolates between the control points based on the matrix configuration.\n */\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha, matrix, p0, p1, p2, p3) {\n  let alphaV = new Vec4(1, alpha, alpha * alpha, alpha * alpha * alpha);\n  let transform = matrix.times(alphaV);\n  return p0.times(transform.elements[0]).plus(p1.times(transform.elements[1])).plus(p2.times(transform.elements[2])).plus(p3.times(transform.elements[3]));\n  // let xCoord = p0.elements[0] * transform.x + p1.elements[0] * transform.y + p2.elements[0] * transform.z + p3.elements[0] * transform.h;\n  // let yCoord = p0.elements[1] * transform.x + p1.elements[1] * transform.y + p2.elements[1] * transform.z + p3.elements[1] * transform.h;\n  // let zCoord = 0;\n  // let hCoord = 0;\n  // if (p0.nDimensions == 2){\n  //     return new VectorBase([xCoord, yCoord]);}\n  // else if (p0.nDimensions == 3) {\n  //     zCoord = p0.elements[2] * transform.x + p1.elements[2] * transform.y + p2.elements[2] * transform.z + p3.elements[2] * transform.h;\n  //     return new VectorBase([xCoord, yCoord, zCoord]);}\n  // else {\n  //     zCoord = p0.elements[2] * transform.x + p1.elements[2] * transform.y + p2.elements[2] * transform.z + p3.elements[2] * transform.h;\n  //     hCoord = p0.elements[3] * transform.x + p1.elements[3] * transform.y + p2.elements[3] * transform.z + p3.elements[3] * transform.h;\n  //     return new VectorBase([xCoord, yCoord, zCoord, hCoord]);}\n  // TODO: Replace the line above with your own code (technically optional, but suggested)\n}\n\n/**\n * This function takes in a progress parameter alpha and four points representing the control points of a Bezier spline segment. Return the point corresponding to alpha along the segment.\n * @param alpha\n * @param p0\n * @param p1\n * @param p2\n * @param p3\n * @returns {VectorBase}\n * @constructor\n */\n_c = GetSplineSegmentValueForAlphaAndMatrix;\nexport function GetCubicBezierSplineSegmentValueForAlpha(alpha, p0, p1, p2, p3) {\n  let cubicBezier = new Mat4(1, 3, 3, -1, 0, 3, -6, 3, 0, 0, 3, -3, 0, 0, 0, 1);\n  return GetSplineSegmentValueForAlphaAndMatrix(alpha, cubicBezier, p0, p1, p2, p3); // TODO: Replace the line above with your own code\n}\n\n/**\n *\n * @param alpha\n * @param p0\n * @param p1\n * @param p2\n * @param p3\n * @constructor\n */\n_c2 = GetCubicBezierSplineSegmentValueForAlpha;\nexport function GetCubicBezierSplineSegmentDerivativeForAlpha(alpha, p0, p1, p2, p3) {\n  throw new Error(\"GetCubicBezierSplineSegmentDerivativeForAlpha not implemented!\");\n  // TODO: Replace the line above with your own code\n}\n_c3 = GetCubicBezierSplineSegmentDerivativeForAlpha;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"GetSplineSegmentValueForAlphaAndMatrix\");\n$RefreshReg$(_c2, \"GetCubicBezierSplineSegmentValueForAlpha\");\n$RefreshReg$(_c3, \"GetCubicBezierSplineSegmentDerivativeForAlpha\");","map":{"version":3,"names":["Mat4","Vec4","GetSplineSegmentValueForAlphaAndMatrix","alpha","matrix","p0","p1","p2","p3","alphaV","transform","times","elements","plus","_c","GetCubicBezierSplineSegmentValueForAlpha","cubicBezier","_c2","GetCubicBezierSplineSegmentDerivativeForAlpha","Error","_c3","$RefreshReg$"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/A1/nodes/Spline/CubicBezierFunctions.ts"],"sourcesContent":["import {Color, Mat4, Vec2, Vec3, Vec4, VectorBase} from \"../../../anigraph\";\n\n/*\nThe function below is technically optional, in that we won't grade it directly, but implementing it may save you some repeated effort on other parts.\nFor the curious, it also provides a convenient way to explore other types of splines.\n */\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha: number, matrix: Mat4, p0: VectorBase, p1: VectorBase, p2: VectorBase, p3: VectorBase):Vec2;\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha: number, matrix: Mat4, p0: VectorBase, p1: VectorBase, p2: VectorBase, p3: VectorBase):Vec3;\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha: number, matrix: Mat4, p0: VectorBase, p1: VectorBase, p2: VectorBase, p3: VectorBase):Color;\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha: number, matrix: Mat4, p0: VectorBase, p1: VectorBase, p2: VectorBase, p3: VectorBase):Vec4;\n/**\n * Calculates the value of a cubic spline segment at a given parameter alpha using a transformation matrix.\n *\n * This function blends four control points (p0, p1, p2, p3) based on the parameter alpha and a 4x4 matrix.\n * The matrix influences the shape of the spline, allowing for different types of splines like Bezier or Catmull-Rom.\n *\n * @param {number} alpha - A value between 0 and 1 representing the position along the spline segment.\n * @param {Mat4} matrix - A 4x4 transformation matrix that dictates the blending of the control points.\n    (Hint: the Mat4 class has many useful helper getters for you to get specific elements of a Matrix.\n    e.g. you can get any column or row of a matrix easily)\n * @param {VectorBase} p0 - The first control point of the spline segment.\n * @param {VectorBase} p1 - The second control point of the spline segment.\n * @param {VectorBase} p2 - The third control point of the spline segment.\n * @param {VectorBase} p3 - The fourth control point of the spline segment.\n *\n * @returns {VectorBase} - The calculated position on the spline at the specified alpha.\n *\n * Example:\n * - For alpha = 0, the function returns the position at p0.\n * - For alpha = 1, the function returns the position at p3.\n * - For values between 0 and 1, the function interpolates between the control points based on the matrix configuration.\n */\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha:number, matrix:Mat4, p0:VectorBase, p1:VectorBase, p2:VectorBase, p3:VectorBase):VectorBase{\n    let alphaV = new Vec4(1, alpha, alpha*alpha, alpha*alpha*alpha);\n    let transform = matrix.times(alphaV)\n    return p0.times(transform.elements[0]).plus(p1.times(transform.elements[1])).plus(p2.times(transform.elements[2])).plus(p3.times(transform.elements[3]));\n    // let xCoord = p0.elements[0] * transform.x + p1.elements[0] * transform.y + p2.elements[0] * transform.z + p3.elements[0] * transform.h;\n    // let yCoord = p0.elements[1] * transform.x + p1.elements[1] * transform.y + p2.elements[1] * transform.z + p3.elements[1] * transform.h;\n    // let zCoord = 0;\n    // let hCoord = 0;\n    // if (p0.nDimensions == 2){\n    //     return new VectorBase([xCoord, yCoord]);}\n    // else if (p0.nDimensions == 3) {\n    //     zCoord = p0.elements[2] * transform.x + p1.elements[2] * transform.y + p2.elements[2] * transform.z + p3.elements[2] * transform.h;\n    //     return new VectorBase([xCoord, yCoord, zCoord]);}\n    // else {\n    //     zCoord = p0.elements[2] * transform.x + p1.elements[2] * transform.y + p2.elements[2] * transform.z + p3.elements[2] * transform.h;\n    //     hCoord = p0.elements[3] * transform.x + p1.elements[3] * transform.y + p2.elements[3] * transform.z + p3.elements[3] * transform.h;\n    //     return new VectorBase([xCoord, yCoord, zCoord, hCoord]);}\n    // TODO: Replace the line above with your own code (technically optional, but suggested)\n}\n\n\n\n/**\n * This function takes in a progress parameter alpha and four points representing the control points of a Bezier spline segment. Return the point corresponding to alpha along the segment.\n * @param alpha\n * @param p0\n * @param p1\n * @param p2\n * @param p3\n * @returns {VectorBase}\n * @constructor\n */\nexport function GetCubicBezierSplineSegmentValueForAlpha(alpha:number, p0:Vec2, p1:Vec2, p2:Vec2, p3:Vec2):Vec2;\nexport function GetCubicBezierSplineSegmentValueForAlpha(alpha:number, p0:Color, p1:Color, p2:Color, p3:Color):Color;\nexport function GetCubicBezierSplineSegmentValueForAlpha(alpha:number, p0:VectorBase, p1:VectorBase, p2:VectorBase, p3:VectorBase):VectorBase{\n    let cubicBezier = new Mat4(1, 3, 3, -1, 0, 3, -6, 3, 0, 0, 3, -3, 0, 0, 0, 1);\n    return GetSplineSegmentValueForAlphaAndMatrix(alpha, cubicBezier, p0, p1, p2, p3);    // TODO: Replace the line above with your own code\n}\n\n/**\n *\n * @param alpha\n * @param p0\n * @param p1\n * @param p2\n * @param p3\n * @constructor\n */\nexport function GetCubicBezierSplineSegmentDerivativeForAlpha(alpha:number, p0:Vec2, p1:Vec2, p2:Vec2, p3:Vec2):Vec2;\nexport function GetCubicBezierSplineSegmentDerivativeForAlpha(alpha:number, p0:VectorBase, p1:VectorBase, p2:VectorBase, p3:VectorBase):VectorBase{\n    throw new Error(\"GetCubicBezierSplineSegmentDerivativeForAlpha not implemented!\")\n    // TODO: Replace the line above with your own code\n}\n"],"mappings":"AAAA,SAAeA,IAAI,EAAcC,IAAI,QAAmB,mBAAmB;;AAE3E;AACA;AACA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,sCAAsCA,CAACC,KAAY,EAAEC,MAAW,EAAEC,EAAa,EAAEC,EAAa,EAAEC,EAAa,EAAEC,EAAa,EAAY;EACpJ,IAAIC,MAAM,GAAG,IAAIR,IAAI,CAAC,CAAC,EAAEE,KAAK,EAAEA,KAAK,GAACA,KAAK,EAAEA,KAAK,GAACA,KAAK,GAACA,KAAK,CAAC;EAC/D,IAAIO,SAAS,GAAGN,MAAM,CAACO,KAAK,CAACF,MAAM,CAAC;EACpC,OAAOJ,EAAE,CAACM,KAAK,CAACD,SAAS,CAACE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,CAACP,EAAE,CAACK,KAAK,CAACD,SAAS,CAACE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,CAACN,EAAE,CAACI,KAAK,CAACD,SAAS,CAACE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,CAACL,EAAE,CAACG,KAAK,CAACD,SAAS,CAACE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;EACxJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATAE,EAAA,GAtBgBZ,sCAAsC;AAkCtD,OAAO,SAASa,wCAAwCA,CAACZ,KAAY,EAAEE,EAAa,EAAEC,EAAa,EAAEC,EAAa,EAAEC,EAAa,EAAY;EACzI,IAAIQ,WAAW,GAAG,IAAIhB,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC7E,OAAOE,sCAAsC,CAACC,KAAK,EAAEa,WAAW,EAAEX,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,CAAC,CAAI;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARAS,GAAA,GALgBF,wCAAwC;AAexD,OAAO,SAASG,6CAA6CA,CAACf,KAAY,EAAEE,EAAa,EAAEC,EAAa,EAAEC,EAAa,EAAEC,EAAa,EAAY;EAC9I,MAAM,IAAIW,KAAK,CAAC,gEAAgE,CAAC;EACjF;AACJ;AAACC,GAAA,GAHeF,6CAA6C;AAAA,IAAAJ,EAAA,EAAAG,GAAA,EAAAG,GAAA;AAAAC,YAAA,CAAAP,EAAA;AAAAO,YAAA,CAAAJ,GAAA;AAAAI,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}