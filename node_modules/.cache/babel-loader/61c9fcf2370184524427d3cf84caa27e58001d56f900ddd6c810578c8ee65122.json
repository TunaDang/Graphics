{"ast":null,"code":"import * as THREE from \"three\";\nimport { SVGLoader } from \"./SVGLoader\";\n\n/**\n * set position, scale, rotation of @param object\n * specified by the 4x4 homogeneous matrix @param m4\n * @param object object to set its position, scale and rotation\n * @param m4 4x4 homogeneous matrix m4\n */\nexport function setAttributesFromMatrix(object, m4) {\n  object.position.add(new THREE.Vector3().setFromMatrixPosition(m4));\n  object.scale.copy(new THREE.Vector3().setFromMatrixScale(m4));\n  object.rotation.copy(new THREE.Euler().setFromRotationMatrix(new THREE.Matrix4().extractRotation(m4)));\n}\n\n/** move ThreeJs obeject @param object to the center\n * of world coordinate\n */\nexport function moveObjectToWorldCenter(object) {\n  let center = new THREE.Vector3();\n  let boundingBox = new THREE.Box3().setFromObject(object);\n  boundingBox.getCenter(center);\n  object.position.sub(center);\n}\nexport function createMeshesFromPath(path) {\n  const meshes = [];\n  addFillMeshes(meshes);\n  addStrokeMeshes(meshes);\n  return meshes;\n  function addFillMeshes(meshes) {\n    const fillColor = path.userData.style.fill;\n    if (fillColor !== undefined && fillColor !== \"none\") {\n      // const material = new THREE.MeshBasicMaterial({\n      //   color: new THREE.Color().setStyle(fillColor),\n      //   opacity: path.userData.style.fillOpacity,\n      //   transparent:\n      //     path.userData.style.strokeOpacity &&\n      //     path.userData.style.strokeOpacity < 1\n      //       ? true\n      //       : false,\n      //   side: THREE.DoubleSide,\n      //   depthWrite: false,\n      //   wireframe: false,\n      // });\n\n      const material = new THREE.MeshBasicMaterial({\n        color: new THREE.Color().setStyle(fillColor),\n        opacity: path.userData.style.fillOpacity,\n        transparent: path.userData.style.strokeOpacity && path.userData.style.strokeOpacity < 1 ? true : false,\n        side: THREE.DoubleSide,\n        depthWrite: true,\n        wireframe: false\n      });\n      const shapes = SVGLoader.createShapes(path);\n      for (let j = 0; j < shapes.length; j++) {\n        const shape = shapes[j];\n        const geometry = new THREE.ShapeGeometry(shape);\n        const mesh = new THREE.Mesh(geometry, material);\n        meshes.push(mesh);\n      }\n    }\n  }\n  function addStrokeMeshes(meshes) {\n    const strokeColor = path.userData.style.stroke;\n    if (strokeColor !== undefined && strokeColor !== \"none\") {\n      // const material = new THREE.MeshBasicMaterial({\n      //   color: new THREE.Color().setStyle(strokeColor),\n      //   opacity: path.userData.style.strokeOpacity,\n      //   transparent:\n      //     path.userData.style.strokeOpacity &&\n      //     path.userData.style.strokeOpacity < 1\n      //       ? true\n      //       : false,\n      //   side: THREE.DoubleSide,\n      //   depthWrite: false,\n      //   wireframe: false,\n      // });\n      const material = new THREE.MeshBasicMaterial({\n        color: new THREE.Color().setStyle(strokeColor),\n        opacity: path.userData.style.strokeOpacity,\n        transparent: path.userData.style.strokeOpacity && path.userData.style.strokeOpacity < 1 ? true : false,\n        side: THREE.DoubleSide,\n        depthWrite: true,\n        wireframe: false\n      });\n      for (let j = 0, jl = path.subPaths.length; j < jl; j++) {\n        const subPath = path.subPaths[j];\n        const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style);\n        if (geometry) {\n          const mesh = new THREE.Mesh(geometry, material);\n          meshes.push(mesh);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Convert 1d position list (x1,y1,z1,x2,y2...)\n * to vertices array [[x1,y1,z1],[x2,y2,z2]]\n * @example\n * const vertices = verticesFromPositionList(positions)\n * vertices = [[1,2,0], [2,3,0]]\n */\nexport function verticesFromPositionList(positions) {\n  const vertices = [];\n  let index = 0;\n  while (index < positions.array.length) {\n    const vertex = [];\n    for (let i = 0; i < 3; i++) {\n      vertex.push(positions.array[index]);\n      index++;\n    }\n    vertices.push(vertex);\n  }\n  return vertices;\n}\n\n/**\n * make vertices of @param mesh\n * centered around its local origin\n * while perserving its position in\n * world coordinate (parent coordinate)\n * @param mesh\n * @implements\n * vertices -= center\n * mesh.position += center\n */\nexport function makeOriginCenterForMesh(mesh) {\n  const center = getCenter(mesh);\n  centerWithoutMove(mesh, center);\n}\n\n/** @returns center point of @params mesh */\nexport function getCenter(mesh) {\n  mesh.geometry.computeBoundingBox();\n  let center = new THREE.Vector3();\n  mesh.geometry.boundingBox.getCenter(center);\n  return center;\n}\n\n/**\n * make vertices of @param mesh\n * centered around local origin\n * specified as @param center\n * while perserving its position in\n * world coordinate (parent coordinate)\n * @param mesh\n * @param center\n */\nexport function centerWithoutMove(mesh, center) {\n  /**\n   * @return [vertex1, vertex2,...] or [[x1,y1,z1],[x2,y2,z2],...]\n   * @example return [[1,2,0], [2,3,0]]\n   */\n  function getVertices(mesh) {\n    const positions = mesh.geometry.getAttribute(\"position\");\n    const vertices = verticesFromPositionList(positions);\n    return vertices;\n  }\n  const vertices = getVertices(mesh);\n  // center vertices\n  vertices.forEach(vertex => {\n    vertex[0] -= center.x;\n    vertex[1] -= center.y;\n  });\n  mesh.geometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices.flat(), 3));\n  // update position of matrix to make sure it doesn't move\n  mesh.position.set(center.x, center.y, 0);\n  mesh.updateMatrix();\n  // make sure future references of bounding box is correct\n  mesh.geometry.computeBoundingBox();\n}\n\n/**\n * move local origin of @param group to the center of\n * all of its children (i.e. center of its bounding box)\n * while maintaining its world position\n * @param group\n * @implements\n * eachChild.position -= center\n * group.position += center\n */\nexport function makeOriginCenterForGroup(group) {\n  let center = new THREE.Vector3();\n  let boundingBox = new THREE.Box3().setFromObject(group);\n  boundingBox.getCenter(center);\n  for (const child of group.children) {\n    child.position.sub(center);\n  }\n  group.position.add(center);\n}\nfunction matrix4FromMatrix3(matrix3) {\n  function from1Dto2DArray(list) {\n    let m = [[], [], []];\n    let index = 0;\n    for (let j = 0; j < 3; j++) {\n      for (let i = 0; i < 3; i++) {\n        m[i].push(list[index]);\n        index++;\n      }\n    }\n    return m;\n  }\n  const m = from1Dto2DArray(matrix3.toArray());\n  const m4 = [[m[0][0], m[0][1], 0, m[0][2]], [m[1][0], m[1][1], 0, m[1][2]], [0, 0, 1, 0], [0, 0, 0, 1]];\n  return new THREE.Matrix4().fromArray(m4.flat()).transpose();\n}\n\n/**\n * @returns a Hierarchical THREE.Group object from\n * svg specified by @param svgUrl\n * @param svgUrl url for the svg file\n * @example\n * loadSVG('./sbsp.svg')\n */\nexport async function SvgToThreeJsObject(svgUrl) {\n  const svgParsedData = await loadSvgData(svgUrl);\n  const svgRootThreeJSObject = generateThreeJSGroupForSVG(svgParsedData);\n  moveObjectToWorldCenter(svgRootThreeJSObject);\n  svgRootThreeJSObject.scale.multiplyScalar(0.3);\n  svgRootThreeJSObject.scale.y *= -1;\n  return svgRootThreeJSObject;\n}\n_c = SvgToThreeJsObject;\nasync function loadSvgData(svgUrl) {\n  const loader = new SVGLoader();\n  const svgParsedData = await loader.load(svgUrl);\n  return svgParsedData;\n}\nexport function SvgTextToThreeJsObject(svgText) {\n  const svgParsedData = parseSVG(svgText);\n  const svgRootThreeJSObject = generateThreeJSGroupForSVG(svgParsedData);\n  moveObjectToWorldCenter(svgRootThreeJSObject);\n  svgRootThreeJSObject.scale.multiplyScalar(1.0);\n  svgRootThreeJSObject.scale.y *= -1;\n  return svgRootThreeJSObject;\n}\n_c2 = SvgTextToThreeJsObject;\nexport function ThreeJSObjectFromParsedSVG(svgParsedData) {\n  const svgRootThreeJSObject = generateThreeJSGroupForSVG(svgParsedData);\n  // moveObjectToWorldCenter(svgRootThreeJSObject);\n  // svgRootThreeJSObject.scale.multiplyScalar(1.0);\n  // svgRootThreeJSObject.scale.y *= -1;\n  // svgRootThreeJSObject.updateMatrix();\n  svgRootThreeJSObject.matrixAutoUpdate = false;\n  return svgRootThreeJSObject;\n}\n_c3 = ThreeJSObjectFromParsedSVG;\nexport function getSVGTextFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = event => {\n      var _event$target;\n      resolve((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);\n    };\n    reader.onerror = err => {\n      alert(\"failed to upload file with err\" + err);\n    };\n    reader.readAsText(file);\n  });\n}\nfunction parseSVG(svgText) {\n  const loader = new SVGLoader();\n  const svgParsedData = loader.parse(svgText);\n  return svgParsedData;\n}\nfunction generateThreeJSGroupForSVG(svgData) {\n  const rootSvgNode = svgData.rootSvgNode;\n  const svgThreeJsRootObject = createThreeJSObject(rootSvgNode)[0];\n  return svgThreeJsRootObject;\n}\n\n/**\n * create an array of ThreeJS object\n * with root being current SVG node\n * @implements\n * Create mesh for primitive types like path, rect.\n * Create group for g.\n * Convert localTransform into position, scale, rotation\n * attributes of ThreeJS object\n * @param root {SvgNode} tree structure\n * parsed from SVG containing path and svg node information\n * @returns [THREE.Group] or [THREE.Mesh] or []\n */\nfunction createThreeJSObject(root) {\n  // decide if root is a group by seeting whether length > 0\n  if (root.children.length > 0) {\n    var _root$id;\n    const group = new THREE.Group();\n    group.name = (_root$id = root.id) !== null && _root$id !== void 0 ? _root$id : root.node.nodeName;\n    for (const child of root.children) {\n      const childSceneArray = createThreeJSObject(child);\n      if (childSceneArray) {\n        childSceneArray.forEach(scene => group.add(scene));\n      }\n    }\n    makeOriginCenterForGroup(group);\n    setAttributesFromMatrix(group, matrix4FromMatrix3(root.localTransform));\n    return [group];\n  } else if (root.originPath) {\n    const meshes = createMeshesFromPath(root.originPath);\n    meshes.forEach(mesh => {\n      var _root$id2;\n      mesh.name = (_root$id2 = root.id) !== null && _root$id2 !== void 0 ? _root$id2 : root.node.nodeName;\n      makeOriginCenterForMesh(mesh);\n      setAttributesFromMatrix(mesh, matrix4FromMatrix3(root.localTransform));\n    });\n    return meshes;\n  } else return [];\n}\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"SvgToThreeJsObject\");\n$RefreshReg$(_c2, \"SvgTextToThreeJsObject\");\n$RefreshReg$(_c3, \"ThreeJSObjectFromParsedSVG\");","map":{"version":3,"names":["THREE","SVGLoader","setAttributesFromMatrix","object","m4","position","add","Vector3","setFromMatrixPosition","scale","copy","setFromMatrixScale","rotation","Euler","setFromRotationMatrix","Matrix4","extractRotation","moveObjectToWorldCenter","center","boundingBox","Box3","setFromObject","getCenter","sub","createMeshesFromPath","path","meshes","addFillMeshes","addStrokeMeshes","fillColor","userData","style","fill","undefined","material","MeshBasicMaterial","color","Color","setStyle","opacity","fillOpacity","transparent","strokeOpacity","side","DoubleSide","depthWrite","wireframe","shapes","createShapes","j","length","shape","geometry","ShapeGeometry","mesh","Mesh","push","strokeColor","stroke","jl","subPaths","subPath","pointsToStroke","getPoints","verticesFromPositionList","positions","vertices","index","array","vertex","i","makeOriginCenterForMesh","centerWithoutMove","computeBoundingBox","getVertices","getAttribute","forEach","x","y","setAttribute","Float32BufferAttribute","flat","set","updateMatrix","makeOriginCenterForGroup","group","child","children","matrix4FromMatrix3","matrix3","from1Dto2DArray","list","m","toArray","fromArray","transpose","SvgToThreeJsObject","svgUrl","svgParsedData","loadSvgData","svgRootThreeJSObject","generateThreeJSGroupForSVG","multiplyScalar","_c","loader","load","SvgTextToThreeJsObject","svgText","parseSVG","_c2","ThreeJSObjectFromParsedSVG","matrixAutoUpdate","_c3","getSVGTextFromFile","file","Promise","resolve","reject","reader","FileReader","onload","event","_event$target","target","result","onerror","err","alert","readAsText","parse","svgData","rootSvgNode","svgThreeJsRootObject","createThreeJSObject","root","_root$id","Group","name","id","node","nodeName","childSceneArray","scene","localTransform","originPath","_root$id2","$RefreshReg$"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/fileio/svg/SvgToThreeJsObject.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport type { SvgNode, SVGParsedData } from \"./SVGLoader\";\nimport { SVGLoader, SVGPath } from \"./SVGLoader\";\n\n/**\n * set position, scale, rotation of @param object\n * specified by the 4x4 homogeneous matrix @param m4\n * @param object object to set its position, scale and rotation\n * @param m4 4x4 homogeneous matrix m4\n */\nexport function setAttributesFromMatrix(\n  object: THREE.Object3D,\n  m4: THREE.Matrix4\n) {\n  object.position.add(new THREE.Vector3().setFromMatrixPosition(m4));\n  object.scale.copy(new THREE.Vector3().setFromMatrixScale(m4));\n  object.rotation.copy(\n    new THREE.Euler().setFromRotationMatrix(\n      new THREE.Matrix4().extractRotation(m4)\n    )\n  );\n}\n\n/** move ThreeJs obeject @param object to the center\n * of world coordinate\n */\nexport function moveObjectToWorldCenter(object: THREE.Object3D) {\n  let center = new THREE.Vector3();\n  let boundingBox = new THREE.Box3().setFromObject(object);\n  boundingBox.getCenter(center);\n  object.position.sub(center);\n}\n\nexport function createMeshesFromPath(path: SVGPath) {\n  const meshes: THREE.Mesh[] = [];\n  addFillMeshes(meshes);\n  addStrokeMeshes(meshes);\n  return meshes;\n\n  function addFillMeshes(meshes: THREE.Mesh[]) {\n    const fillColor = path.userData.style.fill;\n    if (fillColor !== undefined && fillColor !== \"none\") {\n      // const material = new THREE.MeshBasicMaterial({\n      //   color: new THREE.Color().setStyle(fillColor),\n      //   opacity: path.userData.style.fillOpacity,\n      //   transparent:\n      //     path.userData.style.strokeOpacity &&\n      //     path.userData.style.strokeOpacity < 1\n      //       ? true\n      //       : false,\n      //   side: THREE.DoubleSide,\n      //   depthWrite: false,\n      //   wireframe: false,\n      // });\n\n      const material = new THREE.MeshBasicMaterial({\n        color: new THREE.Color().setStyle(fillColor),\n        opacity: path.userData.style.fillOpacity,\n        transparent:\n          path.userData.style.strokeOpacity &&\n          path.userData.style.strokeOpacity < 1\n            ? true\n            : false,\n        side: THREE.DoubleSide,\n        depthWrite: true,\n        wireframe: false,\n      });\n\n      const shapes: THREE.Shape[] = SVGLoader.createShapes(path);\n\n      for (let j = 0; j < shapes.length; j++) {\n        const shape = shapes[j];\n        const geometry = new THREE.ShapeGeometry(shape);\n        const mesh = new THREE.Mesh(geometry, material);\n        meshes.push(mesh);\n      }\n    }\n  }\n  function addStrokeMeshes(meshes: THREE.Mesh[]) {\n    const strokeColor = path.userData.style.stroke;\n\n    if (strokeColor !== undefined && strokeColor !== \"none\") {\n      // const material = new THREE.MeshBasicMaterial({\n      //   color: new THREE.Color().setStyle(strokeColor),\n      //   opacity: path.userData.style.strokeOpacity,\n      //   transparent:\n      //     path.userData.style.strokeOpacity &&\n      //     path.userData.style.strokeOpacity < 1\n      //       ? true\n      //       : false,\n      //   side: THREE.DoubleSide,\n      //   depthWrite: false,\n      //   wireframe: false,\n      // });\n      const material = new THREE.MeshBasicMaterial({\n        color: new THREE.Color().setStyle(strokeColor),\n        opacity: path.userData.style.strokeOpacity,\n        transparent:\n          path.userData.style.strokeOpacity &&\n          path.userData.style.strokeOpacity < 1\n            ? true\n            : false,\n        side: THREE.DoubleSide,\n        depthWrite: true,\n        wireframe: false,\n      });\n\n      for (let j = 0, jl = path.subPaths.length; j < jl; j++) {\n        const subPath = path.subPaths[j];\n\n        const geometry = SVGLoader.pointsToStroke(\n          subPath.getPoints(),\n          path.userData.style\n        );\n\n        if (geometry) {\n          const mesh = new THREE.Mesh(geometry, material);\n\n          meshes.push(mesh);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Convert 1d position list (x1,y1,z1,x2,y2...)\n * to vertices array [[x1,y1,z1],[x2,y2,z2]]\n * @example\n * const vertices = verticesFromPositionList(positions)\n * vertices = [[1,2,0], [2,3,0]]\n */\nexport function verticesFromPositionList(\n  positions: THREE.BufferAttribute | THREE.InterleavedBufferAttribute\n): number[][] {\n  const vertices = [];\n  let index = 0;\n  while (index < positions.array.length) {\n    const vertex = [];\n    for (let i = 0; i < 3; i++) {\n      vertex.push(positions.array[index]);\n      index++;\n    }\n    vertices.push(vertex);\n  }\n  return vertices;\n}\n\n/**\n * make vertices of @param mesh\n * centered around its local origin\n * while perserving its position in\n * world coordinate (parent coordinate)\n * @param mesh\n * @implements\n * vertices -= center\n * mesh.position += center\n */\nexport function makeOriginCenterForMesh(mesh: THREE.Mesh) {\n  const center = getCenter(mesh);\n  centerWithoutMove(mesh, center);\n}\n\n/** @returns center point of @params mesh */\nexport function getCenter(mesh: THREE.Mesh): THREE.Vector3 {\n  mesh.geometry.computeBoundingBox();\n  let center = new THREE.Vector3();\n  mesh.geometry.boundingBox!.getCenter(center);\n  return center;\n}\n\n/**\n * make vertices of @param mesh\n * centered around local origin\n * specified as @param center\n * while perserving its position in\n * world coordinate (parent coordinate)\n * @param mesh\n * @param center\n */\nexport function centerWithoutMove(mesh: THREE.Mesh, center: THREE.Vector3) {\n  /**\n   * @return [vertex1, vertex2,...] or [[x1,y1,z1],[x2,y2,z2],...]\n   * @example return [[1,2,0], [2,3,0]]\n   */\n  function getVertices(mesh: THREE.Mesh) {\n    const positions = mesh.geometry.getAttribute(\"position\");\n    const vertices = verticesFromPositionList(positions);\n    return vertices;\n  }\n  const vertices = getVertices(mesh);\n  // center vertices\n  vertices.forEach((vertex) => {\n    vertex[0] -= center.x;\n    vertex[1] -= center.y;\n  });\n  mesh.geometry.setAttribute(\n    \"position\",\n    new THREE.Float32BufferAttribute(vertices.flat(), 3)\n  );\n  // update position of matrix to make sure it doesn't move\n  mesh.position.set(center.x, center.y, 0);\n  mesh.updateMatrix();\n  // make sure future references of bounding box is correct\n  mesh.geometry.computeBoundingBox();\n}\n\n/**\n * move local origin of @param group to the center of\n * all of its children (i.e. center of its bounding box)\n * while maintaining its world position\n * @param group\n * @implements\n * eachChild.position -= center\n * group.position += center\n */\nexport function makeOriginCenterForGroup(group: THREE.Group) {\n  let center = new THREE.Vector3();\n  let boundingBox = new THREE.Box3().setFromObject(group);\n  boundingBox.getCenter(center);\n  for (const child of group.children) {\n    child.position.sub(center);\n  }\n  group.position.add(center);\n}\n\nfunction matrix4FromMatrix3(matrix3: THREE.Matrix3): THREE.Matrix4 {\n  function from1Dto2DArray(list: number[]) {\n    let m: number[][] = [[], [], []];\n    let index = 0;\n    for (let j = 0; j < 3; j++) {\n      for (let i = 0; i < 3; i++) {\n        m[i].push(list[index]);\n        index++;\n      }\n    }\n    return m;\n  }\n  const m = from1Dto2DArray(matrix3.toArray());\n  const m4 = [\n    [m[0][0], m[0][1], 0, m[0][2]],\n    [m[1][0], m[1][1], 0, m[1][2]],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1],\n  ];\n  return new THREE.Matrix4().fromArray(m4.flat()).transpose();\n}\n\n/**\n * @returns a Hierarchical THREE.Group object from\n * svg specified by @param svgUrl\n * @param svgUrl url for the svg file\n * @example\n * loadSVG('./sbsp.svg')\n */\nexport async function SvgToThreeJsObject(\n  svgUrl: string\n): Promise<THREE.Object3D> {\n  const svgParsedData = await loadSvgData(svgUrl);\n  const svgRootThreeJSObject = generateThreeJSGroupForSVG(svgParsedData);\n  moveObjectToWorldCenter(svgRootThreeJSObject);\n  svgRootThreeJSObject.scale.multiplyScalar(0.3);\n  svgRootThreeJSObject.scale.y *= -1;\n  return svgRootThreeJSObject;\n}\n\nasync function loadSvgData(svgUrl: string) {\n  const loader = new SVGLoader();\n  const svgParsedData: SVGParsedData = await loader.load(svgUrl);\n  return svgParsedData;\n}\n\nexport function SvgTextToThreeJsObject(svgText: string): THREE.Object3D {\n  const svgParsedData = parseSVG(svgText);\n  const svgRootThreeJSObject = generateThreeJSGroupForSVG(svgParsedData);\n  moveObjectToWorldCenter(svgRootThreeJSObject);\n  svgRootThreeJSObject.scale.multiplyScalar(1.0);\n  svgRootThreeJSObject.scale.y *= -1;\n  return svgRootThreeJSObject;\n}\n\nexport function ThreeJSObjectFromParsedSVG(\n  svgParsedData: SVGParsedData\n): THREE.Object3D {\n  const svgRootThreeJSObject = generateThreeJSGroupForSVG(svgParsedData);\n  // moveObjectToWorldCenter(svgRootThreeJSObject);\n  // svgRootThreeJSObject.scale.multiplyScalar(1.0);\n  // svgRootThreeJSObject.scale.y *= -1;\n  // svgRootThreeJSObject.updateMatrix();\n  svgRootThreeJSObject.matrixAutoUpdate = false;\n  return svgRootThreeJSObject;\n}\n\nexport function getSVGTextFromFile(file: File) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      resolve(event.target?.result);\n    };\n    reader.onerror = (err) => {\n      alert(\"failed to upload file with err\" + err);\n    };\n    reader.readAsText(file);\n  });\n}\n\nfunction parseSVG(svgText: string) {\n  const loader = new SVGLoader();\n  const svgParsedData: SVGParsedData = loader.parse(svgText);\n  return svgParsedData;\n}\n\nfunction generateThreeJSGroupForSVG(svgData: SVGParsedData): THREE.Object3D {\n  const rootSvgNode = svgData.rootSvgNode;\n  const svgThreeJsRootObject: THREE.Object3D =\n    createThreeJSObject(rootSvgNode)[0];\n  return svgThreeJsRootObject;\n}\n\n/**\n * create an array of ThreeJS object\n * with root being current SVG node\n * @implements\n * Create mesh for primitive types like path, rect.\n * Create group for g.\n * Convert localTransform into position, scale, rotation\n * attributes of ThreeJS object\n * @param root {SvgNode} tree structure\n * parsed from SVG containing path and svg node information\n * @returns [THREE.Group] or [THREE.Mesh] or []\n */\nfunction createThreeJSObject(root: SvgNode): THREE.Object3D[] {\n  // decide if root is a group by seeting whether length > 0\n  if (root.children.length > 0) {\n    const group = new THREE.Group();\n    group.name = root.id ?? root.node.nodeName;\n    for (const child of root.children) {\n      const childSceneArray = createThreeJSObject(child);\n      if (childSceneArray) {\n        childSceneArray.forEach((scene) => group.add(scene));\n      }\n    }\n    makeOriginCenterForGroup(group);\n    setAttributesFromMatrix(group, matrix4FromMatrix3(root.localTransform));\n    return [group];\n  } else if (root.originPath) {\n    const meshes = createMeshesFromPath(root.originPath);\n    meshes.forEach((mesh: THREE.Mesh) => {\n      mesh.name = root.id ?? root.node.nodeName;\n      makeOriginCenterForMesh(mesh);\n      setAttributesFromMatrix(mesh, matrix4FromMatrix3(root.localTransform));\n    });\n    return meshes;\n  } else return [];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}