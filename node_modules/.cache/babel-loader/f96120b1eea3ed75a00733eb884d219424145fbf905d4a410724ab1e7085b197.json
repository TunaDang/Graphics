{"ast":null,"code":"var _dec, _class;\nimport { ASerializable } from \"../../base\";\nimport { V3, Vec3, Mat4, V4, Quaternion, Mat3 } from \"../linalg\";\nimport { Precision } from \"../Precision\";\nimport { NodeTransform2D } from \"./NodeTransform2D\";\nexport let NodeTransform3D = (_dec = ASerializable(\"NodeTransform3D\"), _dec(_class = class NodeTransform3D {\n  get scale() {\n    return this._scale;\n  }\n  set scale(value) {\n    if (value instanceof Vec3) {\n      this._scale = value;\n    } else {\n      this._scale = new Vec3(value, value, value);\n    }\n  }\n  constructor(...args) {\n    this.position = void 0;\n    this.anchor = void 0;\n    this._scale = void 0;\n    this.rotation = void 0;\n    if (args[0] instanceof Mat4) {\n      let pos = args.length > 1 ? args[1] : undefined;\n      let rotation = args.length > 2 ? args[2] : undefined;\n      this.setWithMatrix(args[0], pos, rotation);\n      if (!this.position) {\n        this.position = new Vec3(0, 0, 0);\n      }\n    } else {\n      var _args$, _args$2, _args$3, _args$4;\n      this.position = args.length > 0 ? (_args$ = args[0]) !== null && _args$ !== void 0 ? _args$ : new Vec3(0, 0, 0) : new Vec3(0, 0, 0);\n      this.rotation = args.length > 1 ? (_args$2 = args[1]) !== null && _args$2 !== void 0 ? _args$2 : new Quaternion() : new Quaternion();\n      this.scale = args.length > 2 ? (_args$3 = args[2]) !== null && _args$3 !== void 0 ? _args$3 : new Vec3(1, 1, 1) : new Vec3(1, 1, 1);\n      this.anchor = args.length > 3 ? (_args$4 = args[3]) !== null && _args$4 !== void 0 ? _args$4 : new Vec3(0, 0, 0) : new Vec3(0, 0, 0);\n    }\n  }\n  getPosition() {\n    return this.position;\n  }\n  _getQuaternionRotation() {\n    return this.rotation;\n  }\n  _setQuaternionRotation(q) {\n    this.rotation = q;\n  }\n  setPosition(position) {\n    this.position = position;\n  }\n  clone() {\n    return new NodeTransform3D(this.position.clone(), this.rotation.clone(), this.scale.clone(), this.anchor.clone());\n  }\n  NodeTransform3D() {\n    return this.clone();\n  }\n  static FromPoseMatrix(mat) {\n    let translation = mat.c3;\n    let rotationM = mat.clone();\n    rotationM.c3 = V4(0, 0, 0, 1);\n    let rotationQ = Quaternion.FromMatrix(rotationM);\n    return new NodeTransform3D(translation.Point3D, rotationQ);\n  }\n  appliedToPoint(p) {\n    return this.getMat4().times(p.Point3DH).Point3D;\n  }\n  times(other) {\n    // @ts-ignore\n    return this.getMat4().times(other);\n  }\n\n  /**\n   * Returns the transformation matrix for this set of transform properties.\n   *\n   * @returns the transformation matrix\n   */\n  getMatrix() {\n    // return Mat4.Translation3D(this.position)\n    //     .times(this.rotation.Mat4())\n    //     .times(Mat4.Scale3D(this.scale))\n    //     .times(Mat4.Translation3D(this.anchor.times(-1)));\n\n    let P = Mat4.Translation3D(this.position);\n    let R = this.rotation.Mat4();\n    let S = Mat4.Scale3D(this.scale);\n    let A = Mat4.Translation3D(this.anchor.times(-1));\n    return P.times(R).times(S).times(A);\n    // let m = new Matrix4();\n    // m.compose(this.position.asThreeJS(),this.rotation, this.scale.asThreeJS());\n    // let mobj = Mat4.FromThreeJS(m).getTranspose();\n    // const anchor = Mat4.Translation3D(this.anchor.times(-1));\n    // return mobj.times(anchor);\n  }\n  assignTo(threejsMat) {\n    this.getMat4().assignTo(threejsMat);\n  }\n  getMat4() {\n    return this.getMatrix();\n  }\n  static PoseProduct(lhs, rhs) {\n    let nt = lhs.rotation.appliedTo(rhs.position).plus(lhs.position);\n    let nr = lhs.rotation.times(rhs.rotation);\n    return new NodeTransform3D(nt, nr);\n  }\n  getInverse() {\n    let inv = new NodeTransform3D();\n    inv.scale = V3(1 / this.scale.x, 1 / this.scale.y, 1 / this.scale.z);\n    inv.rotation = this.rotation.getInverse();\n    inv.position = inv.rotation.appliedTo(this.position.times(-1)).timesElementWise(inv.scale);\n    return inv;\n  }\n  getRightMultipliedByRotation(r) {\n    return new NodeTransform3D(this.position.clone(), this.rotation.times(r));\n  }\n  getLeftMultipliedByRotation(r) {\n    return new NodeTransform3D(r.appliedTo(this.position), r.times(this.rotation));\n  }\n  NodeTransform2D(cameraMatrix) {\n    let P = cameraMatrix ? cameraMatrix : Mat4.Identity();\n    let thisxvec = P.times(this.rotation.Mat4().c0);\n    let p3d = P.times(this.position.Point3DH).Point3D;\n    // let thisM = this.getMat4();\n    return new NodeTransform2D(p3d.XY, Math.atan2(thisxvec.y, thisxvec.x), this.scale.XY, this.anchor.XY);\n  }\n\n  /**\n   * Sets the transform properties based on the given affine transformation\n   * matrix and optional position.\n   *\n   * This function should set the transform based on an input matrix and\n   * (optionally) a starting position. Calling T.getMatrix() on the resulting\n   * transform should produce the input matrix `m`. Position should\n   * be the point where changes to rotation or scale will rotate and scale around.\n   * Meanings of position, rotation, scale, and anchor match those used in Adobe\n   * standards (e.g., After Effects). The corresponding matrix is calculated\n   * as shown in getMatrix() above: (P)*(R)*(S)*(-A). Position is specified as\n   * a constraint because the two translations in the above equation create a\n   * redundancy.\n   *\n   * We recommend familiarizing yourself with the available methods in\n   * `src/anigraph/amath/Mat3.ts`.\n   *\n   * Also familiarize yourself with the available functions in\n   * `src/anigraph/amath/Precision.ts`. These are useful when dealing with\n   * floating point inaccuracies and other small numbers.\n   *\n   * Note: do not let the scale factor be less than epsilon.\n   *\n   * @param m the affine transformation matrix\n   * @param position the starting positon\n   */\n  setWithMatrix(m, position, rotation) {\n    // throw new Error(\"setWithMatrix not implemented yet! Wait for assignment 2!\")\n\n    if (position !== undefined) {\n      this.position = position;\n    }\n\n    // if(!this.rotation){\n    //     this.rotation = Quaternion.FromMatrix(m).normalize();\n    // }\n    if (rotation) {\n      this.rotation = rotation;\n      // this.rotation.\n      // this.rotation = Quaternion.Identity();\n    } else {\n      this.rotation = Quaternion.FromMatrix(m);\n    }\n    let PRSA = m;\n    let RSA = Mat4.Translation3D(this.position.times(-1)).times(PRSA);\n    let rmat = this.rotation.Mat4();\n    let rimat = rmat.getInverse();\n    const SA = rimat.times(RSA);\n    this.scale = new Vec3(Precision.ClampAbsAboveEpsilon(SA.m00), Precision.ClampAbsAboveEpsilon(SA.m11), Precision.ClampAbsAboveEpsilon(SA.m22));\n    let P = Mat4.Translation3D(this.position);\n    let R = rmat.clone();\n    let S = Mat4.Scale3D(this.scale);\n    let PRS = P.times(R).times(S);\n    let PRSinv = PRS.getInverse();\n    if (PRSinv === null) {\n      throw new Error(`tried to set transform with matrix that has zero determinant: ${m}`);\n      return;\n    }\n    this.anchor = PRSinv.times(m).c3.Point3D.times(-1);\n  }\n  static FromPositionZY(position, x, y) {\n    let z = x.cross(y);\n    let yUse = z.cross(x);\n    let q = Quaternion.FromMatrix(Mat3.FromColumns(x, yUse, z));\n    return new NodeTransform3D(position, q);\n  }\n  static LookAt(location, target, up) {\n    let position = location;\n    let look = target.minus(location).getNormalized();\n    return new NodeTransform3D(position, Quaternion.FromCameraOrientationVectors(look, up));\n\n    // Leaving the code below for reference -- students can ignore\n\n    // let look = target.minus(location);\n    // let zneg = look.getNormalized().times(-1);\n    // let r = zneg.cross(up).getNormalized();\n    // let upn = zneg.cross(r)\n    // let M = Mat4.FromColumns(\n    //     r.Vec3DH,\n    //     upn.Vec3DH,\n    //     zneg.Vec3DH,\n    //     location.Point3DH\n    // )\n    // could extract scale here\n    // let position = location;\n    // let R = Mat4.FromColumns(M.r0, M.r1,M.r2,V4(0,0,0,1));\n    // let rotation = Quaternion.FromMatrix(R);\n    // return new NodeTransform3D(position, rotation);\n  }\n  static FromPositionZUpAndScale(position, z, up, scale) {\n    return new NodeTransform3D(position, Quaternion.FromZAndUp(z, up), scale);\n  }\n  static PointToward(location, target, up) {\n    let position = location;\n    let look = location.minus(target).getNormalized();\n    return new NodeTransform3D(position, Quaternion.FromCameraOrientationVectors(look, up));\n  }\n  static RotationZ(radians) {\n    return new NodeTransform3D(new Vec3(0, 0, 0), Quaternion.RotationZ(radians));\n  }\n  static RotationX(radians) {\n    return new NodeTransform3D(new Vec3(0, 0, 0), Quaternion.RotationX(radians));\n  }\n  static RotationY(radians) {\n    return new NodeTransform3D(new Vec3(0, 0, 0), Quaternion.RotationY(radians));\n  }\n  static FromMatrix(mat, position, rotation) {\n    let T = new NodeTransform3D();\n    T.setWithMatrix(mat, position, rotation);\n    return T;\n  }\n  static FromThreeJSObject(obj) {\n    return new NodeTransform3D(Vec3.FromThreeJS(obj.position), Quaternion.FromQuaternion(obj.quaternion), Vec3.FromThreeJS(obj.scale));\n  }\n  assignToObject3DPose(obj) {\n    obj.position.set(this.position.x, this.position.y, this.position.z);\n    obj.quaternion.set(this.rotation.x, this.rotation.y, this.rotation.z, this.rotation.w);\n    obj.scale.set(this.scale.x, this.scale.y, this.scale.z);\n    this.getMatrix().assignTo(obj.matrix);\n  }\n  getObjectSpaceOrigin() {\n    return this.getMatrix().times(V4(0, 0, 0, 1)).getHomogenized().Point3D;\n  }\n}) || _class);","map":{"version":3,"names":["ASerializable","V3","Vec3","Mat4","V4","Quaternion","Mat3","Precision","NodeTransform2D","NodeTransform3D","_dec","_class","scale","_scale","value","constructor","args","position","anchor","rotation","pos","length","undefined","setWithMatrix","_args$","_args$2","_args$3","_args$4","getPosition","_getQuaternionRotation","_setQuaternionRotation","q","setPosition","clone","FromPoseMatrix","mat","translation","c3","rotationM","rotationQ","FromMatrix","Point3D","appliedToPoint","p","getMat4","times","Point3DH","other","getMatrix","P","Translation3D","R","S","Scale3D","A","assignTo","threejsMat","PoseProduct","lhs","rhs","nt","appliedTo","plus","nr","getInverse","inv","x","y","z","timesElementWise","getRightMultipliedByRotation","r","getLeftMultipliedByRotation","cameraMatrix","Identity","thisxvec","c0","p3d","XY","Math","atan2","m","PRSA","RSA","rmat","rimat","SA","ClampAbsAboveEpsilon","m00","m11","m22","PRS","PRSinv","Error","FromPositionZY","cross","yUse","FromColumns","LookAt","location","target","up","look","minus","getNormalized","FromCameraOrientationVectors","FromPositionZUpAndScale","FromZAndUp","PointToward","RotationZ","radians","RotationX","RotationY","T","FromThreeJSObject","obj","FromThreeJS","FromQuaternion","quaternion","assignToObject3DPose","set","w","matrix","getObjectSpaceOrigin","getHomogenized"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/math/nodetransforms/NodeTransform3D.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { ASerializable } from \"../../base\";\nimport { NodeTransform } from \"./NodeTransform\";\nimport {V3, Vec3, Mat4, V4, Quaternion, Vec4, Mat3} from \"../linalg\";\nimport { Precision } from \"../Precision\";\nimport { NodeTransform2D } from \"./NodeTransform2D\";\nimport {Color} from \"../Color\";\n\n@ASerializable(\"NodeTransform3D\")\nexport class NodeTransform3D implements NodeTransform<Vec3, Mat4> {\n  public position!: Vec3;\n  public anchor!: Vec3;\n  public _scale!: Vec3;\n  public rotation!: Quaternion;\n\n  get scale(): Vec3 {\n    return this._scale;\n  }\n  set scale(value: Vec3 | number) {\n    if (value instanceof Vec3) {\n      this._scale = value;\n    } else {\n      this._scale = new Vec3(value, value, value);\n    }\n  }\n\n  constructor(\n    position?: Vec3,\n    rotation?: Quaternion,\n    scale?: Vec3|number,\n    anchor?: Vec3\n  );\n  constructor(matrix: Mat4, position?: Vec3, rotation?: Quaternion);\n  constructor(...args: any[]) {\n    if (args[0] instanceof Mat4) {\n      let pos = args.length > 1 ? args[1] : undefined;\n      let rotation = args.length > 2 ? args[2] : undefined;\n      this.setWithMatrix(args[0], pos, rotation);\n      if (!this.position) {\n        this.position = new Vec3(0, 0, 0);\n      }\n    } else {\n      this.position = args.length > 0 ? args[0]??new Vec3(0, 0, 0) : new Vec3(0, 0, 0);\n      this.rotation = args.length > 1 ? args[1]??new Quaternion() : new Quaternion();\n      this.scale = args.length > 2 ? args[2]??new Vec3(1, 1, 1) : new Vec3(1, 1, 1);\n      this.anchor = args.length > 3 ? args[3]??new Vec3(0, 0, 0) : new Vec3(0, 0, 0);\n    }\n  }\n\n\n  getPosition(): Vec3 {\n    return this.position;\n  }\n  _getQuaternionRotation(): Quaternion {\n    return this.rotation;\n    }\n  _setQuaternionRotation(q: Quaternion): void {\n    this.rotation = q;\n  }\n  setPosition(position: Vec3): void {\n    this.position = position;\n  }\n\n  clone() {\n    return new NodeTransform3D(\n      this.position.clone(),\n      this.rotation.clone(),\n      this.scale.clone(),\n      this.anchor.clone()\n    );\n  }\n\n  NodeTransform3D() {\n    return this.clone();\n  }\n\n  static FromPoseMatrix(mat: Mat4) {\n    let translation = mat.c3;\n    let rotationM = mat.clone();\n    rotationM.c3 = V4(0, 0, 0, 1);\n    let rotationQ = Quaternion.FromMatrix(rotationM);\n    return new NodeTransform3D(translation.Point3D, rotationQ);\n  }\n\n\n  appliedToPoint(p:Vec3){\n    return this.getMat4().times(p.Point3DH).Point3D;\n  }\n\n  times(other:Vec4):Vec4;\n  times(other:Mat4):Mat4;\n  times(other:Vec4|Mat4|number):Vec4|Mat4{\n    // @ts-ignore\n    return this.getMat4().times(other);\n  }\n\n\n  /**\n   * Returns the transformation matrix for this set of transform properties.\n   *\n   * @returns the transformation matrix\n   */\n  getMatrix() {\n    // return Mat4.Translation3D(this.position)\n    //     .times(this.rotation.Mat4())\n    //     .times(Mat4.Scale3D(this.scale))\n    //     .times(Mat4.Translation3D(this.anchor.times(-1)));\n\n    let P = Mat4.Translation3D(this.position);\n    let R = this.rotation.Mat4();\n    let S = Mat4.Scale3D(this.scale);\n    let A = Mat4.Translation3D(this.anchor.times(-1));\n    return P.times(R).times(S).times(A);\n    // let m = new Matrix4();\n    // m.compose(this.position.asThreeJS(),this.rotation, this.scale.asThreeJS());\n    // let mobj = Mat4.FromThreeJS(m).getTranspose();\n    // const anchor = Mat4.Translation3D(this.anchor.times(-1));\n    // return mobj.times(anchor);\n  }\n\n  assignTo(threejsMat: THREE.Matrix4) {\n    this.getMat4().assignTo(threejsMat);\n  }\n\n  getMat4(): Mat4 {\n    return this.getMatrix();\n  }\n\n  static PoseProduct(lhs: NodeTransform3D, rhs: NodeTransform3D) {\n    let nt = lhs.rotation.appliedTo(rhs.position).plus(lhs.position);\n    let nr = lhs.rotation.times(rhs.rotation);\n    return new NodeTransform3D(nt, nr);\n  }\n\n  getInverse() {\n    let inv = new NodeTransform3D();\n    inv.scale = V3(1 / this.scale.x, 1 / this.scale.y, 1 / this.scale.z);\n    inv.rotation = this.rotation.getInverse();\n    inv.position = inv.rotation\n      .appliedTo(this.position.times(-1))\n      .timesElementWise(inv.scale);\n    return inv;\n  }\n\n  getRightMultipliedByRotation(r: Quaternion) {\n    return new NodeTransform3D(this.position.clone(), this.rotation.times(r));\n  }\n\n  getLeftMultipliedByRotation(r: Quaternion) {\n    return new NodeTransform3D(\n      r.appliedTo(this.position),\n      r.times(this.rotation)\n    );\n  }\n\n  NodeTransform2D(cameraMatrix?: Mat4) {\n    let P = cameraMatrix ? cameraMatrix : Mat4.Identity();\n    let thisxvec = P.times(this.rotation.Mat4().c0);\n    let p3d = P.times(this.position.Point3DH).Point3D;\n    // let thisM = this.getMat4();\n    return new NodeTransform2D(\n      p3d.XY,\n      Math.atan2(thisxvec.y, thisxvec.x),\n      this.scale.XY,\n      this.anchor.XY\n    );\n  }\n\n  /**\n   * Sets the transform properties based on the given affine transformation\n   * matrix and optional position.\n   *\n   * This function should set the transform based on an input matrix and\n   * (optionally) a starting position. Calling T.getMatrix() on the resulting\n   * transform should produce the input matrix `m`. Position should\n   * be the point where changes to rotation or scale will rotate and scale around.\n   * Meanings of position, rotation, scale, and anchor match those used in Adobe\n   * standards (e.g., After Effects). The corresponding matrix is calculated\n   * as shown in getMatrix() above: (P)*(R)*(S)*(-A). Position is specified as\n   * a constraint because the two translations in the above equation create a\n   * redundancy.\n   *\n   * We recommend familiarizing yourself with the available methods in\n   * `src/anigraph/amath/Mat3.ts`.\n   *\n   * Also familiarize yourself with the available functions in\n   * `src/anigraph/amath/Precision.ts`. These are useful when dealing with\n   * floating point inaccuracies and other small numbers.\n   *\n   * Note: do not let the scale factor be less than epsilon.\n   *\n   * @param m the affine transformation matrix\n   * @param position the starting positon\n   */\n  setWithMatrix(m: Mat4, position?: Vec3, rotation?: Quaternion) {\n    // throw new Error(\"setWithMatrix not implemented yet! Wait for assignment 2!\")\n\n    if (position !== undefined) {\n      this.position = position;\n    }\n\n    // if(!this.rotation){\n    //     this.rotation = Quaternion.FromMatrix(m).normalize();\n    // }\n    if (rotation) {\n      this.rotation = rotation;\n      // this.rotation.\n      // this.rotation = Quaternion.Identity();\n    } else {\n      this.rotation = Quaternion.FromMatrix(m);\n    }\n\n    let PRSA = m;\n    let RSA = Mat4.Translation3D(this.position.times(-1)).times(PRSA);\n    let rmat = this.rotation.Mat4();\n    let rimat = rmat.getInverse();\n\n    const SA = rimat.times(RSA);\n    this.scale = new Vec3(\n      Precision.ClampAbsAboveEpsilon(SA.m00),\n      Precision.ClampAbsAboveEpsilon(SA.m11),\n      Precision.ClampAbsAboveEpsilon(SA.m22)\n    );\n\n    let P = Mat4.Translation3D(this.position);\n    let R = rmat.clone();\n    let S = Mat4.Scale3D(this.scale);\n    let PRS = P.times(R).times(S);\n    let PRSinv = PRS.getInverse();\n\n    if (PRSinv === null) {\n      throw new Error(\n        `tried to set transform with matrix that has zero determinant: ${m}`\n      );\n      return;\n    }\n    this.anchor = PRSinv.times(m).c3.Point3D.times(-1);\n  }\n\n  static FromPositionZY(position:Vec3, x:Vec3, y:Vec3){\n    let z = x.cross(y);\n    let yUse = z.cross(x);\n    let q = Quaternion.FromMatrix(\n        Mat3.FromColumns(x, yUse, z)\n    );\n    return new NodeTransform3D(position, q);\n  }\n\n  static LookAt(location: Vec3, target: Vec3, up: Vec3) {\n    let position = location;\n    let look = target.minus(location).getNormalized();\n    return new NodeTransform3D(position, Quaternion.FromCameraOrientationVectors(look, up));\n\n    // Leaving the code below for reference -- students can ignore\n\n    // let look = target.minus(location);\n    // let zneg = look.getNormalized().times(-1);\n    // let r = zneg.cross(up).getNormalized();\n    // let upn = zneg.cross(r)\n    // let M = Mat4.FromColumns(\n    //     r.Vec3DH,\n    //     upn.Vec3DH,\n    //     zneg.Vec3DH,\n    //     location.Point3DH\n    // )\n    // could extract scale here\n    // let position = location;\n    // let R = Mat4.FromColumns(M.r0, M.r1,M.r2,V4(0,0,0,1));\n    // let rotation = Quaternion.FromMatrix(R);\n    // return new NodeTransform3D(position, rotation);\n  }\n\n  static FromPositionZUpAndScale(position: Vec3, z: Vec3, up: Vec3, scale:Vec3|number) {\n    return new NodeTransform3D(position, Quaternion.FromZAndUp(z, up), scale);\n  }\n\n\n  static PointToward(location: Vec3, target: Vec3, up: Vec3) {\n    let position = location;\n    let look = location.minus(target).getNormalized();\n    return new NodeTransform3D(position, Quaternion.FromCameraOrientationVectors(look, up));\n  }\n\n  static RotationZ(radians: number) {\n    return new NodeTransform3D(\n      new Vec3(0, 0, 0),\n      Quaternion.RotationZ(radians)\n    );\n  }\n  static RotationX(radians: number) {\n    return new NodeTransform3D(\n        new Vec3(0, 0, 0),\n        Quaternion.RotationX(radians)\n    );\n  }\n\n  static RotationY(radians: number) {\n    return new NodeTransform3D(\n        new Vec3(0, 0, 0),\n        Quaternion.RotationY(radians)\n    );\n  }\n\n  static FromMatrix(mat: Mat4, position?: Vec3, rotation?: Quaternion) {\n    let T = new NodeTransform3D();\n    T.setWithMatrix(mat, position, rotation);\n    return T;\n  }\n\n  static FromThreeJSObject(obj: THREE.Object3D) {\n    return new NodeTransform3D(\n      Vec3.FromThreeJS(obj.position),\n      Quaternion.FromQuaternion(obj.quaternion),\n      Vec3.FromThreeJS(obj.scale)\n    );\n  }\n\n  assignToObject3DPose(obj: THREE.Object3D) {\n    obj.position.set(this.position.x, this.position.y, this.position.z);\n    obj.quaternion.set(\n      this.rotation.x,\n      this.rotation.y,\n      this.rotation.z,\n      this.rotation.w\n    );\n    obj.scale.set(this.scale.x, this.scale.y, this.scale.z);\n    this.getMatrix().assignTo(obj.matrix);\n  }\n\n  getObjectSpaceOrigin() {\n    return this.getMatrix().times(V4(0, 0, 0, 1)).getHomogenized().Point3D;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}