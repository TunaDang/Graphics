{"ast":null,"code":"import { Mat4, Vec4, VectorBase } from \"../../../anigraph\";\n\n/*\nThe function below is technically optional, in that we won't grade it directly, but implementing it may save you some repeated effort on other parts.\nFor the curious, it also provides a convenient way to explore other types of splines.\n */\n\n/**\n * Calculates the value of a cubic spline segment at a given parameter alpha using a transformation matrix.\n *\n * This function blends four control points (p0, p1, p2, p3) based on the parameter alpha and a 4x4 matrix.\n * The matrix influences the shape of the spline, allowing for different types of splines like Bezier or Catmull-Rom.\n *\n * @param {number} alpha - A value between 0 and 1 representing the position along the spline segment.\n * @param {Mat4} matrix - A 4x4 transformation matrix that dictates the blending of the control points.\n    (Hint: the Mat4 class has many useful helper getters for you to get specific elements of a Matrix.\n    e.g. you can get any column or row of a matrix easily)\n * @param {VectorBase} p0 - The first control point of the spline segment.\n * @param {VectorBase} p1 - The second control point of the spline segment.\n * @param {VectorBase} p2 - The third control point of the spline segment.\n * @param {VectorBase} p3 - The fourth control point of the spline segment.\n *\n * @returns {VectorBase} - The calculated position on the spline at the specified alpha.\n *\n * Example:\n * - For alpha = 0, the function returns the position at p0.\n * - For alpha = 1, the function returns the position at p3.\n * - For values between 0 and 1, the function interpolates between the control points based on the matrix configuration.\n */\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha, matrix, p0, p1, p2, p3) {\n  let alphaV = new Vec4(1, alpha, alpha * alpha, alpha * alpha * alpha);\n  let transform = matrix.times(alphaV);\n  let xCoord = p0.x * transform.x + p1.x * transform.y + p2.x * transform.z + p3.x * transform.h;\n  let yCoord = p0.y * transform.x + p1.y * transform.y + p2.y * transform.z + p3.y * transform.h;\n  let zCoord = 0;\n  let hCoord = 0;\n  if (p0.nDimensions == 2) {\n    return new VectorBase([xCoord, yCoord]);\n  } else if (p0.nDimensions == 3) {\n    zCoord = p0.elements[2] * transform.x + p1.elements[2] * transform.y + p2.elements[2] * transform.z + p3.elements[2] * transform.h;\n    return new VectorBase([xCoord, yCoord, zCoord]);\n  } else {\n    zCoord = p0.elements[2] * transform.x + p1.elements[2] * transform.y + p2.elements[2] * transform.z + p3.elements[2] * transform.h;\n    hCoord = p0.elements[4] * transform.x + p1.elements[3] * transform.y + p2.elements[3] * transform.z + p3.elements[3] * transform.h;\n    return new VectorBase([xCoord, yCoord, zCoord, hCoord]);\n  }\n  // TODO: Replace the line above with your own code (technically optional, but suggested)\n}\n\n/**\n * This function takes in a progress parameter alpha and four points representing the control points of a Bezier spline segment. Return the point corresponding to alpha along the segment.\n * @param alpha\n * @param p0\n * @param p1\n * @param p2\n * @param p3\n * @returns {VectorBase}\n * @constructor\n */\n_c = GetSplineSegmentValueForAlphaAndMatrix;\nexport function GetCubicBezierSplineSegmentValueForAlpha(alpha, p0, p1, p2, p3) {\n  let cubicBezier = new Mat4(1, 3, 3, -1, 0, 3, -6, 3, 0, 0, 3, -3, 0, 0, 0, 1);\n  return GetSplineSegmentValueForAlphaAndMatrix(alpha, cubicBezier, p0, p1, p2, p3); // TODO: Replace the line above with your own code\n}\n\n/**\n *\n * @param alpha\n * @param p0\n * @param p1\n * @param p2\n * @param p3\n * @constructor\n */\n_c2 = GetCubicBezierSplineSegmentValueForAlpha;\nexport function GetCubicBezierSplineSegmentDerivativeForAlpha(alpha, p0, p1, p2, p3) {\n  throw new Error(\"GetCubicBezierSplineSegmentDerivativeForAlpha not implemented!\");\n  // TODO: Replace the line above with your own code\n}\n_c3 = GetCubicBezierSplineSegmentDerivativeForAlpha;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"GetSplineSegmentValueForAlphaAndMatrix\");\n$RefreshReg$(_c2, \"GetCubicBezierSplineSegmentValueForAlpha\");\n$RefreshReg$(_c3, \"GetCubicBezierSplineSegmentDerivativeForAlpha\");","map":{"version":3,"names":["Mat4","Vec4","VectorBase","GetSplineSegmentValueForAlphaAndMatrix","alpha","matrix","p0","p1","p2","p3","alphaV","transform","times","xCoord","x","y","z","h","yCoord","zCoord","hCoord","nDimensions","elements","_c","GetCubicBezierSplineSegmentValueForAlpha","cubicBezier","_c2","GetCubicBezierSplineSegmentDerivativeForAlpha","Error","_c3","$RefreshReg$"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/A1/nodes/Spline/CubicBezierFunctions.ts"],"sourcesContent":["import {Color, Mat4, Vec2, Vec3, Vec4, VectorBase} from \"../../../anigraph\";\n\n/*\nThe function below is technically optional, in that we won't grade it directly, but implementing it may save you some repeated effort on other parts.\nFor the curious, it also provides a convenient way to explore other types of splines.\n */\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha: number, matrix: Mat4, p0: VectorBase, p1: VectorBase, p2: VectorBase, p3: VectorBase):Vec2;\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha: number, matrix: Mat4, p0: VectorBase, p1: VectorBase, p2: VectorBase, p3: VectorBase):Vec3;\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha: number, matrix: Mat4, p0: VectorBase, p1: VectorBase, p2: VectorBase, p3: VectorBase):Color;\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha: number, matrix: Mat4, p0: VectorBase, p1: VectorBase, p2: VectorBase, p3: VectorBase):Vec4;\n/**\n * Calculates the value of a cubic spline segment at a given parameter alpha using a transformation matrix.\n *\n * This function blends four control points (p0, p1, p2, p3) based on the parameter alpha and a 4x4 matrix.\n * The matrix influences the shape of the spline, allowing for different types of splines like Bezier or Catmull-Rom.\n *\n * @param {number} alpha - A value between 0 and 1 representing the position along the spline segment.\n * @param {Mat4} matrix - A 4x4 transformation matrix that dictates the blending of the control points.\n    (Hint: the Mat4 class has many useful helper getters for you to get specific elements of a Matrix.\n    e.g. you can get any column or row of a matrix easily)\n * @param {VectorBase} p0 - The first control point of the spline segment.\n * @param {VectorBase} p1 - The second control point of the spline segment.\n * @param {VectorBase} p2 - The third control point of the spline segment.\n * @param {VectorBase} p3 - The fourth control point of the spline segment.\n *\n * @returns {VectorBase} - The calculated position on the spline at the specified alpha.\n *\n * Example:\n * - For alpha = 0, the function returns the position at p0.\n * - For alpha = 1, the function returns the position at p3.\n * - For values between 0 and 1, the function interpolates between the control points based on the matrix configuration.\n */\nexport function GetSplineSegmentValueForAlphaAndMatrix(alpha:number, matrix:Mat4, p0:VectorBase, p1:VectorBase, p2:VectorBase, p3:VectorBase):VectorBase{\n    let alphaV = new Vec4(1, alpha, alpha*alpha, alpha*alpha*alpha);\n    let transform = matrix.times(alphaV)\n    let xCoord = p0.x * transform.x + p1.x * transform.y + p2.x * transform.z + p3.x * transform.h;\n    let yCoord = p0.y * transform.x + p1.y * transform.y + p2.y * transform.z + p3.y * transform.h;\n    let zCoord = 0;\n    let hCoord = 0;\n    if (p0.nDimensions == 2){\n        return new VectorBase([xCoord, yCoord]);}\n    else if (p0.nDimensions == 3) {\n        zCoord = p0.elements[2] * transform.x + p1.elements[2] * transform.y + p2.elements[2] * transform.z + p3.elements[2] * transform.h;\n        return new VectorBase([xCoord, yCoord, zCoord]);}\n    else {\n        zCoord = p0.elements[2] * transform.x + p1.elements[2] * transform.y + p2.elements[2] * transform.z + p3.elements[2] * transform.h;\n        hCoord = p0.elements[4] * transform.x + p1.elements[3] * transform.y + p2.elements[3] * transform.z + p3.elements[3] * transform.h;\n        return new VectorBase([xCoord, yCoord, zCoord, hCoord]);}\n    // TODO: Replace the line above with your own code (technically optional, but suggested)\n}\n\n\n\n/**\n * This function takes in a progress parameter alpha and four points representing the control points of a Bezier spline segment. Return the point corresponding to alpha along the segment.\n * @param alpha\n * @param p0\n * @param p1\n * @param p2\n * @param p3\n * @returns {VectorBase}\n * @constructor\n */\nexport function GetCubicBezierSplineSegmentValueForAlpha(alpha:number, p0:Vec2, p1:Vec2, p2:Vec2, p3:Vec2):Vec2;\nexport function GetCubicBezierSplineSegmentValueForAlpha(alpha:number, p0:Color, p1:Color, p2:Color, p3:Color):Color;\nexport function GetCubicBezierSplineSegmentValueForAlpha(alpha:number, p0:VectorBase, p1:VectorBase, p2:VectorBase, p3:VectorBase):VectorBase{\n    let cubicBezier = new Mat4(1, 3, 3, -1, 0, 3, -6, 3, 0, 0, 3, -3, 0, 0, 0, 1);\n    return GetSplineSegmentValueForAlphaAndMatrix(alpha, cubicBezier, p0, p1, p2, p3);    // TODO: Replace the line above with your own code\n}\n\n/**\n *\n * @param alpha\n * @param p0\n * @param p1\n * @param p2\n * @param p3\n * @constructor\n */\nexport function GetCubicBezierSplineSegmentDerivativeForAlpha(alpha:number, p0:Vec2, p1:Vec2, p2:Vec2, p3:Vec2):Vec2;\nexport function GetCubicBezierSplineSegmentDerivativeForAlpha(alpha:number, p0:VectorBase, p1:VectorBase, p2:VectorBase, p3:VectorBase):VectorBase{\n    throw new Error(\"GetCubicBezierSplineSegmentDerivativeForAlpha not implemented!\")\n    // TODO: Replace the line above with your own code\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}