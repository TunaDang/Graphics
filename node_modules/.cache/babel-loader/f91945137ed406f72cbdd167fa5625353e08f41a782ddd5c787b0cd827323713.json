{"ast":null,"code":"/***\n * This is almost entirely based on the leva implementation\n */\nimport { V2, Vec2 } from \"../math\";\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\nconst NEWTON_ITERATIONS = 4;\nconst NEWTON_MIN_SLOPE = 0.001;\nconst SUBDIVISION_PRECISION = 0.0000001;\nconst SUBDIVISION_MAX_ITERATIONS = 10;\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nconst A = (aA1, aA2) => 1.0 - 3.0 * aA2 + 3.0 * aA1;\n_c = A;\nconst B = (aA1, aA2) => 3.0 * aA2 - 6.0 * aA1;\n_c2 = B;\nconst C = aA1 => 3.0 * aA1;\n_c3 = C;\nconst calcBezier = (aT, aA1, aA2) => {\n  throw new Error(\"Not Implemented in A1!\");\n};\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nconst getSlope = (aT, aA1, aA2) => {\n  throw new Error(\"Not Implemented in A1!\");\n};\n\n/**\n * @param {number} aX\n * @param {number} aA\n * @param {number} aB\n * @param {number} mX1\n * @param {number} mX2\n * @returns {any}\n */\nconst binarySubdivide = (aX, aA, aB, mX1, mX2) => {\n  let currentX,\n    currentT,\n    i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n};\nconst newtonRaphsonIterate = (aX, aGuessT, mX1, mX2) => {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n};\nconst LinearEasing = x => {\n  return x;\n};\n_c4 = LinearEasing;\nexport class BezierTween {\n  static get Linear() {\n    return new BezierTween(0.5, 0.5, 0.5, 0.5);\n  }\n  p0() {\n    return V2(this.x1y1x2y2[0], this.x1y1x2y2[1]);\n  }\n  p1() {\n    return V2(this.x1y1x2y2[2], this.x1y1x2y2[3]);\n  }\n  get x0() {\n    return this.x1y1x2y2[0];\n  }\n  get y0() {\n    return this.x1y1x2y2[1];\n  }\n  get x1() {\n    return this.x1y1x2y2[2];\n  }\n  get y1() {\n    return this.x1y1x2y2[3];\n  }\n  get sampleValues() {\n    return this._sampleValues;\n  }\n  constructor(...args) {\n    this.x1y1x2y2 = void 0;\n    this._sampleValues = void 0;\n    if (args[0] === undefined) {\n      this.x1y1x2y2 = [0.5, 0.5, 0.5, 0.5];\n    } else {\n      this.x1y1x2y2 = [0, 0, 0, 0];\n      if (Array.isArray(args[0])) {\n        if (args[0].length == 4) {\n          // @ts-ignore\n          this.x1y1x2y2 = args[0];\n        } else {\n          this.x1y1x2y2[0] = args[0][0];\n          this.x1y1x2y2[1] = args[0][1];\n          this.x1y1x2y2[2] = args[1][0];\n          this.x1y1x2y2[3] = args[1][1];\n        }\n      } else if (args[0] instanceof Vec2) {\n        this.x1y1x2y2[0] = args[0].x;\n        this.x1y1x2y2[1] = args[0].y;\n        this.x1y1x2y2[2] = args[1].x;\n        this.x1y1x2y2[3] = args[1].y;\n      } else {\n        this.x1y1x2y2[0] = args[0];\n        this.x1y1x2y2[1] = args[1];\n        this.x1y1x2y2[2] = args[2];\n        this.x1y1x2y2[3] = args[3];\n      }\n    }\n    if (!(0 <= this.x0 && this.x0 <= 1 && 0 <= this.x1 && this.x1 <= 1)) {\n      throw new Error(\"bezier x values must be in [0, 1] range\");\n    }\n\n    // Precompute samples table\n    this._sampleValues = new Float32Array(kSplineTableSize);\n    for (let i = 0; i < kSplineTableSize; ++i) {\n      this.sampleValues[i] = calcBezier(i * kSampleStepSize, this.x0, this.x1);\n    }\n  }\n  _getTForX(aX) {\n    let intervalStart = 0.0;\n    let currentSample = 1;\n    let lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && this.sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    const dist = (aX - this.sampleValues[currentSample]) / (this.sampleValues[currentSample + 1] - this.sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, this.x0, this.x1);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, this.x0, this.x1);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, this.x0, this.x1);\n    }\n  }\n  eval(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0 || x === 1) {\n      return x;\n    }\n    return calcBezier(this._getTForX(x), this.y0, this.y1);\n  }\n}\nvar _c, _c2, _c3, _c4;\n$RefreshReg$(_c, \"A\");\n$RefreshReg$(_c2, \"B\");\n$RefreshReg$(_c3, \"C\");\n$RefreshReg$(_c4, \"LinearEasing\");","map":{"version":3,"names":["V2","Vec2","NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","A","aA1","aA2","_c","B","_c2","C","_c3","calcBezier","aT","Error","getSlope","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","i","Math","abs","newtonRaphsonIterate","aGuessT","currentSlope","LinearEasing","x","_c4","BezierTween","Linear","p0","x1y1x2y2","p1","x0","y0","x1","y1","sampleValues","_sampleValues","constructor","args","undefined","Array","isArray","length","y","Float32Array","_getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope","eval","$RefreshReg$"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/geometry/BezierTween.ts"],"sourcesContent":["/***\n * This is almost entirely based on the leva implementation\n */\nimport { V2, Vec2} from \"../math\";\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\nconst NEWTON_ITERATIONS = 4;\nconst NEWTON_MIN_SLOPE = 0.001;\nconst SUBDIVISION_PRECISION = 0.0000001;\nconst SUBDIVISION_MAX_ITERATIONS = 10;\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nconst A = (aA1: number, aA2: number) => 1.0 - 3.0 * aA2 + 3.0 * aA1;\nconst B = (aA1: number, aA2: number) => 3.0 * aA2 - 6.0 * aA1;\nconst C = (aA1: number) => 3.0 * aA1;\n\nconst calcBezier = (aT: number, aA1: number, aA2: number) => {\n  throw new Error(\"Not Implemented in A1!\")\n};\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nconst getSlope = (aT: number, aA1: number, aA2: number) => {\n  throw new Error(\"Not Implemented in A1!\")\n};\n\n/**\n * @param {number} aX\n * @param {number} aA\n * @param {number} aB\n * @param {number} mX1\n * @param {number} mX2\n * @returns {any}\n */\nconst binarySubdivide = (\n  aX: number,\n  aA: number,\n  aB: number,\n  mX1: number,\n  mX2: number\n) => {\n  let currentX,\n    currentT,\n    i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (\n    Math.abs(currentX) > SUBDIVISION_PRECISION &&\n    ++i < SUBDIVISION_MAX_ITERATIONS\n  );\n  return currentT;\n};\n\nconst newtonRaphsonIterate = (\n  aX: number,\n  aGuessT: number,\n  mX1: number,\n  mX2: number\n) => {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n};\n\nconst LinearEasing = (x: number) => {\n  return x;\n};\n\nexport class BezierTween {\n  static get Linear() {\n    return new BezierTween(0.5, 0.5, 0.5, 0.5);\n  }\n\n  x1y1x2y2: [number, number, number, number];\n  p0() {\n    return V2(this.x1y1x2y2[0], this.x1y1x2y2[1]);\n  }\n  p1() {\n    return V2(this.x1y1x2y2[2], this.x1y1x2y2[3]);\n  }\n  get x0() {\n    return this.x1y1x2y2[0];\n  }\n  get y0() {\n    return this.x1y1x2y2[1];\n  }\n  get x1() {\n    return this.x1y1x2y2[2];\n  }\n  get y1() {\n    return this.x1y1x2y2[3];\n  }\n\n  protected _sampleValues: Float32Array;\n  get sampleValues() {\n    return this._sampleValues;\n  }\n\n  constructor();\n  constructor(xyxy: [number, number, number, number]);\n  constructor(x1: number, y1: number, x2: number, y2: number);\n  constructor(p0: Vec2, p1: Vec2);\n  constructor(p0: [number, number], p1: [number, number]);\n  constructor(...args: any[]) {\n    if (args[0] === undefined) {\n      this.x1y1x2y2 = [0.5, 0.5, 0.5, 0.5];\n    } else {\n      this.x1y1x2y2 = [0, 0, 0, 0];\n      if (Array.isArray(args[0])) {\n        if (args[0].length == 4) {\n          // @ts-ignore\n          this.x1y1x2y2 = args[0];\n        } else {\n          this.x1y1x2y2[0] = args[0][0];\n          this.x1y1x2y2[1] = args[0][1];\n          this.x1y1x2y2[2] = args[1][0];\n          this.x1y1x2y2[3] = args[1][1];\n        }\n      } else if (args[0] instanceof Vec2) {\n        this.x1y1x2y2[0] = args[0].x;\n        this.x1y1x2y2[1] = args[0].y;\n        this.x1y1x2y2[2] = args[1].x;\n        this.x1y1x2y2[3] = args[1].y;\n      } else {\n        this.x1y1x2y2[0] = args[0];\n        this.x1y1x2y2[1] = args[1];\n        this.x1y1x2y2[2] = args[2];\n        this.x1y1x2y2[3] = args[3];\n      }\n    }\n\n    if (!(0 <= this.x0 && this.x0 <= 1 && 0 <= this.x1 && this.x1 <= 1)) {\n      throw new Error(\"bezier x values must be in [0, 1] range\");\n    }\n\n    // Precompute samples table\n    this._sampleValues = new Float32Array(kSplineTableSize);\n    for (let i = 0; i < kSplineTableSize; ++i) {\n      this.sampleValues[i] = calcBezier(i * kSampleStepSize, this.x0, this.x1);\n    }\n  }\n\n  _getTForX(aX: number) {\n    let intervalStart = 0.0;\n    let currentSample = 1;\n    let lastSample = kSplineTableSize - 1;\n\n    for (\n      ;\n      currentSample !== lastSample && this.sampleValues[currentSample] <= aX;\n      ++currentSample\n    ) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    const dist =\n      (aX - this.sampleValues[currentSample]) /\n      (this.sampleValues[currentSample + 1] - this.sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n\n    const initialSlope = getSlope(guessForT, this.x0, this.x1);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, this.x0, this.x1);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(\n        aX,\n        intervalStart,\n        intervalStart + kSampleStepSize,\n        this.x0,\n        this.x1\n      );\n    }\n  }\n\n  eval(x: number) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0 || x === 1) {\n      return x;\n    }\n    return calcBezier(this._getTForX(x), this.y0, this.y1);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}