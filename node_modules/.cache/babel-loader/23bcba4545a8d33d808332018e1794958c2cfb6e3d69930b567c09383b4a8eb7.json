{"ast":null,"code":"var _dec, _class, _AAppState;\nimport { ASerializable } from \"../base\";\nimport { AHandlesEvents } from \"../base/aobject/AHandlesEvents\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { proxy } from \"valtio/vanilla\";\nimport { Mutex } from \"async-mutex\";\nimport { GUISpecs } from \"../GUISpecs\";\nimport { AniGraphDefines } from \"../defines\";\nvar _appState;\nexport function SetAppState(appState) {\n  if (_appState !== undefined) {\n    throw new Error(`Already set the app state to ${_appState}`);\n  }\n  _appState = appState;\n  _appState.init();\n  return _appState;\n}\n\n// enum AppStateKeys{\n//     InteractionMode=\"InteractionMode\",\n//     GUI_KEY=,\n//     AmbientLight=\"ambient\"\n// }\n_c = SetAppState;\nconst _GUI_KEY_KEY_INDEX = \"GUI_KEY\";\nexport let AppStateEvents = /*#__PURE__*/function (AppStateEvents) {\n  AppStateEvents[\"TRIGGER_CONTROL_PANEL_UPDATE\"] = \"TRIGGER_CONTROL_PANEL_UPDATE\";\n  return AppStateEvents;\n}({});\nexport let AAppState = (_dec = ASerializable(\"AAppState\"), _dec(_class = (_AAppState = class AAppState extends AHandlesEvents {\n  init() {}\n  /** Get set guiKey */\n  set _guiKey(value) {\n    this.stateValues[_GUI_KEY_KEY_INDEX] = value;\n  }\n  get _guiKey() {\n    return this.stateValues[_GUI_KEY_KEY_INDEX];\n  }\n  getState(key) {\n    if (key in this.stateValues) {\n      return this.stateValues[key];\n    } else {\n      return undefined;\n    }\n  }\n  setState(name, value) {\n    this.stateValues[name] = value;\n    this.signalEvent(AAppState.GetEventKeyForName(name), value);\n  }\n  constructor() {\n    super();\n    this.name = \"App\";\n    this.stateValues = void 0;\n    this.GUIControlSpecs = {};\n    this._initMutex = void 0;\n    this.globalScale = AniGraphDefines.DefaultGlobalScale;\n    this.zNear = AniGraphDefines.DefaultZNear;\n    this.zFar = AniGraphDefines.DefaultZFar;\n    this.orthoZNear = AniGraphDefines.DefaultOrthoZNear;\n    this.orthoZFar = AniGraphDefines.DefaultOrthoZFar;\n    this._initMutex = new Mutex();\n    this.stateValues = proxy({});\n    this.setState(_GUI_KEY_KEY_INDEX, uuidv4());\n  }\n  get initMutex() {\n    return this._initMutex;\n  }\n  updateControlPanel() {\n    this.signalEvent(AAppState.AppStateEvents.TRIGGER_CONTROL_PANEL_UPDATE);\n  }\n  addControlPanelListener(callback, handle, synchronous = true) {\n    return this.addEventListener(AAppState.AppStateEvents.TRIGGER_CONTROL_PANEL_UPDATE, callback, handle);\n  }\n  _GetOnChangeForName(parameterName) {\n    const self = this;\n    return v => {\n      self.setState(parameterName, v);\n    };\n  }\n  CreateControlPanelCheckboxSpec(stateName, value, otherSpecs) {\n    const self = this;\n    return GUISpecs.CheckboxControl(self._GetOnChangeForName(stateName), value, otherSpecs);\n  }\n  CreateControlPanelSliderSpec(stateName, initialValue, min, max, step, otherSpecs) {\n    const self = this;\n    return GUISpecs.SliderControl(self._GetOnChangeForName(stateName), initialValue, min !== null && min !== void 0 ? min : Math.min(initialValue, 0.0), max !== null && max !== void 0 ? max : Math.max(initialValue, 1.0), step, otherSpecs);\n  }\n  CreateControlPanelColorPickerSpec(stateName, initialValue, otherSpecs) {\n    const self = this;\n    return GUISpecs.ColorControl(self._GetOnChangeForName(stateName), initialValue, otherSpecs);\n  }\n  CreateControlPanelButtonSpec(callback, otherSpecs) {\n    return GUISpecs.ButtonControl(callback, otherSpecs);\n  }\n  CreateControlPanelSelectionSpec(stateName, initialValue, options, otherSpecs) {\n    const self = this;\n    return GUISpecs.SelectionControl(v => {\n      self._GetOnChangeForName(stateName)(v);\n    }, options, initialValue, otherSpecs);\n  }\n  static GetEventKeyForName(name) {\n    return `Parameter_${name}_update_event`;\n  }\n  setGUIControlSpecKey(name, spec) {\n    this.GUIControlSpecs[name] = spec;\n    this.updateControlPanel();\n  }\n\n  // setGUIControlSpecKeyGroup(name:string, spec:GUIControlSpec){\n  //     this.GUIControlSpecs[name]= folder();\n  //     this.updateControlPanel();\n  // }\n\n  addSliderControl(name, initialValue, min, max, step) {\n    this.setGUIControlSpecKey(name, this.CreateControlPanelSliderSpec(name, initialValue, min, max, step));\n  }\n  addCheckboxControl(name, value) {\n    this.setGUIControlSpecKey(name, this.CreateControlPanelCheckboxSpec(name, value));\n    // this.setUniform(TextureProvidedKeyForName(name), !!tex, 'bool');\n  }\n\n  /**\n   * Add a button that triggers a provided callback\n   * @param name\n   * @param callback\n   */\n  addButton(name, callback) {\n    this.setGUIControlSpecKey(name, this.CreateControlPanelButtonSpec(callback));\n  }\n  addColorControl(name, initialValue) {\n    this.setGUIControlSpecKey(name, this.CreateControlPanelColorPickerSpec(name, initialValue));\n  }\n  setSelectionControl(name, initialValue, options, otherSpecs) {\n    this.setGUIControlSpecKey(name, this.CreateControlPanelSelectionSpec(name, initialValue, options, otherSpecs));\n  }\n  addStateValueListener(stateName, callback, handle) {\n    return this.addEventListener(AAppState.GetEventKeyForName(stateName), callback, handle);\n  }\n  addControlSpec(controlSpec) {\n    this.GUIControlSpecs = {\n      ...this.GUIControlSpecs,\n      ...controlSpec\n    };\n  }\n  _GetUniqueFolderName(name) {\n    if (name in this.GUIControlSpecs) {\n      let ntries = 1;\n      let rname = name + `${ntries}`;\n      while (rname in this.GUIControlSpecs) {\n        ntries++;\n        rname = name + `${ntries}`;\n      }\n      return rname;\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Adds a folder of control specs\n   * @param name the name of the folder\n   * @param spec the spec\n   * @param addFolderNameToKeys if true (default) will automatically add the folder name to the end of each individual\n   * spec item. This is because leva expects unique keys for each control, even if they are in different folders\n   * @param collapsed whether the folder is collapsed by default\n   */\n  addControlSpecGroup(name, spec, addFolderNameToKeys = true, collapsed = true) {\n    this.GUIControlSpecs[name] = GUISpecs.MakeFolder(name, spec, addFolderNameToKeys, collapsed);\n    this.updateControlPanel();\n  }\n  updateControlSpecEntry(name, spec) {\n    this.GUIControlSpecs[name] = spec;\n    this.updateControlPanel();\n  }\n\n  /**\n   * A helper function that will check whether the control panel currently has a given slider control in it.\n   * If the control is not there, then we will add it with the provided parameters.\n   * @param name\n   * @param initialValue: initial value for app state\n   * @param min: minimum value of slider\n   * @param max: maximum value of slider\n   * @param step: step size of slider\n   */\n  addSliderIfMissing(name, initialValue, min, max, step) {\n    if (this.getState(name) === undefined) {\n      this.addSliderControl(name, initialValue !== null && initialValue !== void 0 ? initialValue : 1.0, min, max, step);\n    }\n  }\n}, _AAppState.AppStateEvents = AppStateEvents, _AAppState._GUI_KEY_INDEX = _GUI_KEY_KEY_INDEX, _AAppState)) || _class);\nexport function CheckAAppState() {\n  return _appState;\n}\n_c2 = CheckAAppState;\nexport function GetAAppState() {\n  let appState = CheckAAppState();\n  if (appState === undefined) {\n    throw Error(\"No App State!\");\n  }\n  return appState;\n}\n_c3 = GetAAppState;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"SetAppState\");\n$RefreshReg$(_c2, \"CheckAAppState\");\n$RefreshReg$(_c3, \"GetAAppState\");","map":{"version":3,"names":["ASerializable","AHandlesEvents","v4","uuidv4","proxy","Mutex","GUISpecs","AniGraphDefines","_appState","SetAppState","appState","undefined","Error","init","_c","_GUI_KEY_KEY_INDEX","AppStateEvents","AAppState","_dec","_class","_AAppState","_guiKey","value","stateValues","getState","key","setState","name","signalEvent","GetEventKeyForName","constructor","GUIControlSpecs","_initMutex","globalScale","DefaultGlobalScale","zNear","DefaultZNear","zFar","DefaultZFar","orthoZNear","DefaultOrthoZNear","orthoZFar","DefaultOrthoZFar","initMutex","updateControlPanel","TRIGGER_CONTROL_PANEL_UPDATE","addControlPanelListener","callback","handle","synchronous","addEventListener","_GetOnChangeForName","parameterName","self","v","CreateControlPanelCheckboxSpec","stateName","otherSpecs","CheckboxControl","CreateControlPanelSliderSpec","initialValue","min","max","step","SliderControl","Math","CreateControlPanelColorPickerSpec","ColorControl","CreateControlPanelButtonSpec","ButtonControl","CreateControlPanelSelectionSpec","options","SelectionControl","setGUIControlSpecKey","spec","addSliderControl","addCheckboxControl","addButton","addColorControl","setSelectionControl","addStateValueListener","addControlSpec","controlSpec","_GetUniqueFolderName","ntries","rname","addControlSpecGroup","addFolderNameToKeys","collapsed","MakeFolder","updateControlSpecEntry","addSliderIfMissing","_GUI_KEY_INDEX","CheckAAppState","_c2","GetAAppState","_c3","$RefreshReg$"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/appstate/AAppState.ts"],"sourcesContent":["import {ACallbackSwitch, AObject, ASerializable} from \"../base\";\nimport {Color} from \"../math/Color\";\nimport {AHandlesEvents} from \"../base/aobject/AHandlesEvents\";\nimport {v4 as uuidv4} from \"uuid\";\nimport {proxy} from \"valtio/vanilla\";\nimport {folder} from \"leva\";\nimport {ConfirmInitialized} from \"../scene/ConfirmInitialized\";\nimport {Mutex} from \"async-mutex\";\nimport {ClassInterface} from \"../basictypes\";\nimport {AppStateValueChangeCallback} from \"../basictypes\";\nimport {GUISpecs, GUIControlSpec} from \"../GUISpecs\";\nimport {AniGraphDefines, TextureProvidedKeyForName} from \"../defines\";\n\nvar _appState:AAppState;\n\n\n\nexport function SetAppState(appState:AAppState):AAppState{\n    if(_appState !== undefined){\n        throw new Error(`Already set the app state to ${_appState}`);\n    }\n    _appState = appState;\n    _appState.init();\n    return _appState;\n}\n\n// enum AppStateKeys{\n//     InteractionMode=\"InteractionMode\",\n//     GUI_KEY=,\n//     AmbientLight=\"ambient\"\n// }\n\nconst _GUI_KEY_KEY_INDEX=\"GUI_KEY\";\n\nexport enum AppStateEvents{\n    TRIGGER_CONTROL_PANEL_UPDATE='TRIGGER_CONTROL_PANEL_UPDATE'\n}\n\n@ASerializable(\"AAppState\")\nexport abstract class AAppState extends AHandlesEvents{\n    name:string=\"App\";\n    stateValues:{[name:string]:any};\n    GUIControlSpecs:{[name:string]:GUIControlSpec}={};\n    _initMutex:Mutex;\n    static AppStateEvents=AppStateEvents\n    static _GUI_KEY_INDEX = _GUI_KEY_KEY_INDEX;\n\n\n    globalScale:number=AniGraphDefines.DefaultGlobalScale;\n    zNear:number=AniGraphDefines.DefaultZNear;\n    zFar:number=AniGraphDefines.DefaultZFar;\n    orthoZNear:number=AniGraphDefines.DefaultOrthoZNear;\n    orthoZFar:number=AniGraphDefines.DefaultOrthoZFar;\n\n\n\n    init(){}\n    /** Get set guiKey */\n    set _guiKey(value){this.stateValues[_GUI_KEY_KEY_INDEX]=value;}\n    get _guiKey(){return this.stateValues[_GUI_KEY_KEY_INDEX];}\n\n    getState(key:string){\n        if(key in this.stateValues) {\n            return this.stateValues[key];\n        }else{\n            return undefined;\n        }\n    }\n\n    setState(name:string, value:any){\n        this.stateValues[name]=value;\n        this.signalEvent(AAppState.GetEventKeyForName(name), value);\n    }\n\n    constructor() {\n        super();\n        this._initMutex = new Mutex();\n        this.stateValues=proxy({});\n        this.setState(_GUI_KEY_KEY_INDEX, uuidv4());\n    }\n\n    get initMutex(){\n        return this._initMutex;\n    }\n\n\n\n\n    updateControlPanel(){\n        this.signalEvent(AAppState.AppStateEvents.TRIGGER_CONTROL_PANEL_UPDATE);\n    }\n\n    addControlPanelListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true){\n        return this.addEventListener(AAppState.AppStateEvents.TRIGGER_CONTROL_PANEL_UPDATE, callback, handle);\n    }\n\n\n    _GetOnChangeForName(parameterName:string):AppStateValueChangeCallback{\n        const self = this;\n        return (v:any)=>{\n            self.setState(parameterName, v);\n        }\n\n    }\n\n    CreateControlPanelCheckboxSpec(stateName:string, value:boolean, otherSpecs?:{[name:string]:any}){\n        const self = this;\n        return GUISpecs.CheckboxControl(\n            self._GetOnChangeForName(stateName),\n            value,\n            otherSpecs\n        )\n    }\n\n    CreateControlPanelSliderSpec(stateName:string, initialValue:any, min?:number, max?:number, step?:number, otherSpecs?:{[name:string]:any}):GUIControlSpec{\n        const self = this;\n        return GUISpecs.SliderControl(\n            self._GetOnChangeForName(stateName),\n            initialValue,\n            min??Math.min(initialValue, 0.0),\n            max??Math.max(initialValue, 1.0),\n            step,\n            otherSpecs\n        )\n    }\n\n    CreateControlPanelColorPickerSpec(stateName:string, initialValue:Color, otherSpecs?:{[name:string]:any}):GUIControlSpec{\n        const self = this;\n        return GUISpecs.ColorControl(\n            self._GetOnChangeForName(stateName),\n            initialValue,\n            otherSpecs\n        );\n    }\n\n\n    CreateControlPanelButtonSpec(callback:()=>void, otherSpecs?:{[name:string]:any}):GUIControlSpec{\n        return GUISpecs.ButtonControl(callback, otherSpecs);\n    }\n\n    CreateControlPanelSelectionSpec(stateName:string, initialValue:any, options:any[], otherSpecs?:{[name:string]:any}):GUIControlSpec{\n        const self = this;\n        return GUISpecs.SelectionControl(\n            (v: string) => {\n                self._GetOnChangeForName(stateName)(v);\n            },\n            options,\n            initialValue,\n            otherSpecs\n        )\n    }\n\n\n    static GetEventKeyForName(name:string):string{\n        return `Parameter_${name}_update_event`;\n    }\n\n    setGUIControlSpecKey(name:string, spec:GUIControlSpec){\n        this.GUIControlSpecs[name]= spec;\n        this.updateControlPanel();\n    }\n\n    // setGUIControlSpecKeyGroup(name:string, spec:GUIControlSpec){\n    //     this.GUIControlSpecs[name]= folder();\n    //     this.updateControlPanel();\n    // }\n\n    addSliderControl(name:string, initialValue:any, min?:number, max?:number, step?:number){\n        this.setGUIControlSpecKey(name, this.CreateControlPanelSliderSpec(name, initialValue, min, max, step))\n    }\n\n    addCheckboxControl(name:string, value:boolean){\n        this.setGUIControlSpecKey(name, this.CreateControlPanelCheckboxSpec(name, value))\n        // this.setUniform(TextureProvidedKeyForName(name), !!tex, 'bool');\n    }\n\n    /**\n     * Add a button that triggers a provided callback\n     * @param name\n     * @param callback\n     */\n    addButton(name:string, callback:()=>void){\n        this.setGUIControlSpecKey(name, this.CreateControlPanelButtonSpec(callback));\n    }\n\n    addColorControl(name:string, initialValue:Color){\n        this.setGUIControlSpecKey(name,this.CreateControlPanelColorPickerSpec(name, initialValue));\n    }\n\n    setSelectionControl(name:string, initialValue:any, options:any[], otherSpecs?:{[name:string]:any}){\n        this.setGUIControlSpecKey(name,this.CreateControlPanelSelectionSpec(name, initialValue, options, otherSpecs));\n    }\n\n\n    addStateValueListener(\n        stateName: string,\n        callback: AppStateValueChangeCallback,\n        handle?: string\n    ) {\n        return this.addEventListener(\n            AAppState.GetEventKeyForName(stateName),\n            callback,\n            handle,\n            );\n    }\n\n\n\n\n    addControlSpec(controlSpec:{[name:string]:GUIControlSpec}){\n        this.GUIControlSpecs = {\n            ...this.GUIControlSpecs,\n            ...controlSpec\n        };\n    }\n\n    _GetUniqueFolderName(name:string){\n        if(name in this.GUIControlSpecs){\n            let ntries = 1;\n            let rname = name+`${ntries}`\n            while(rname in this.GUIControlSpecs){\n                ntries++;\n                rname = name+`${ntries}`\n            }\n            return rname;\n        }else{\n            return name;\n        }\n    }\n\n    /**\n     * Adds a folder of control specs\n     * @param name the name of the folder\n     * @param spec the spec\n     * @param addFolderNameToKeys if true (default) will automatically add the folder name to the end of each individual\n     * spec item. This is because leva expects unique keys for each control, even if they are in different folders\n     * @param collapsed whether the folder is collapsed by default\n     */\n    addControlSpecGroup(name:string, spec:GUIControlSpec, addFolderNameToKeys=true, collapsed=true){\n        this.GUIControlSpecs[name] = GUISpecs.MakeFolder(name, spec, addFolderNameToKeys, collapsed);\n        this.updateControlPanel();\n    }\n\n    updateControlSpecEntry(name:string, spec:GUIControlSpec){\n        this.GUIControlSpecs[name]=spec;\n        this.updateControlPanel();\n    }\n\n    /**\n     * A helper function that will check whether the control panel currently has a given slider control in it.\n     * If the control is not there, then we will add it with the provided parameters.\n     * @param name\n     * @param initialValue: initial value for app state\n     * @param min: minimum value of slider\n     * @param max: maximum value of slider\n     * @param step: step size of slider\n     */\n    addSliderIfMissing(name:string, initialValue?:number, min?:number, max?:number, step?:number){\n        if(this.getState(name)===undefined){\n            this.addSliderControl(name, initialValue??1.0, min, max, step);\n        }\n    }\n\n}\n\nexport function CheckAAppState():AAppState|undefined{\n    return _appState;\n}\n\nexport function GetAAppState(){\n    let appState = CheckAAppState();\n    if(appState===undefined){\n        throw Error(\"No App State!\")\n    }\n    return appState;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}