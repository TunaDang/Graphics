{"ast":null,"code":"var _dec, _class, _SplineModel;\nimport { ASerializable, Color, Curve2DModel, CurveInterpolationModes, V2, Vec2 } from \"../../../anigraph\";\nimport { GetCubicBezierSplineSegmentValueForAlpha, GetCubicBezierSplineSegmentDerivativeForAlpha } from \"./CubicBezierFunctions\";\nexport let SplineModel = (_dec = ASerializable(\"SplineModel\"), _dec(_class = (_SplineModel = class SplineModel extends Curve2DModel {\n  /**\n   * When the interpolation mode changes, we need to signal an update of the geometry.\n   * @param value\n   */\n  set interpolationMode(value) {\n    this._interpolationMode = value;\n    this.signalGeometryUpdate();\n  }\n  get interpolationMode() {\n    return this._interpolationMode;\n  }\n\n  /**\n   * Width/thickness of the control shape when it is visible\n   * @type {number}\n   */\n\n  /**\n   * The number of control points in our spline.\n   * This is simply the number of vertices in `this.verts`, which is a VertexArray2D inherited from `ANodeModel2D`,\n   * which is a parent class.\n   * @returns {number}\n   */\n  get nControlPoints() {\n    return this.verts.nVerts;\n  }\n  getControlPointLocation(index) {\n    return this.verts.getPoint2DAt(index);\n  }\n  getControlPointColor(index) {\n    return this.verts.color.getAt(index);\n  }\n\n  /**\n   * There are 4 point in a cubic Bezier segment, and when we chain segments together we typically use the last\n   * control point of each segment as the first control point of the subsequent segment.\n   *\n   * Here we give you a function that takes a segment index and returns the 4 corresponding control points.\n   * @param segmentIndex\n   * @returns {[Vec2, Vec2, Vec2, Vec2]}\n   */\n  getSegmentControlPoints(segmentIndex) {\n    let startHandle = segmentIndex * 3;\n    return [this.verts.getPoint2DAt(startHandle), this.verts.getPoint2DAt(startHandle + 1), this.verts.getPoint2DAt(startHandle + 2), this.verts.getPoint2DAt(startHandle + 3)];\n  }\n\n  /**\n   * Similar to `getSegmentControlPoints`, we give you a function to get the colors stored at each of the control\n   * points in the bezier segment with index `segmentIndex`.\n   * @param segmentIndex\n   * @returns {[Color, Color, Color, Color]}\n   */\n  getSegmentControlPointColors(segmentIndex) {\n    let startHandle = segmentIndex * 3;\n    return [this.verts.color.getAt(startHandle), this.verts.color.getAt(startHandle + 1), this.verts.color.getAt(startHandle + 2), this.verts.color.getAt(startHandle + 3)];\n  }\n\n  //###########################################//--Linear Interpolation--\\\\###########################################\n  //<editor-fold desc=\"Linear Interpolation\">\n\n  /**\n   * Returns a point `progress` along the linear interpolation of control points.\n   * Remember, only the first and last point in each segment are interpolated!\n   * @param progress\n   * @returns {Vec2}\n   */\n  getLinearInterpolationPoint(progress) {\n    if (this.nControlPoints < 2) {\n      return V2();\n    }\n    let currentIndex = progress * (this.nControlPoints - 2);\n    let tfloor = Math.floor(currentIndex);\n    let startControlPointIndex = tfloor;\n    let startControlPoint = this.verts.getPoint2DAt(startControlPointIndex);\n    let endControlPointIndex = Math.ceil(currentIndex);\n    let endControlPoint = this.verts.getPoint2DAt(endControlPointIndex);\n    let alpha = currentIndex - tfloor;\n\n    /**\n     * We've given you most of this function as an example of how to get control points by index.\n     * From here, you need to return a point that is interpolated `alpha` along the way from `startControlPoint` to\n     * `endControlPoint`...\n     */\n\n    return new Vec2(startControlPoint.x * (1 - alpha) + alpha * endControlPoint.x, startControlPoint.y * (1 - alpha) + alpha * endControlPoint.y);\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Colors can be represented as a vector of color channels. We can interpolate between these vectors in the same way\n   * we interpolate between the coordinate vector representations of spline control points.\n   *\n   * Hint: AniGraph's Color class represents a 4D vector with channels [red, green, blue, alpha], and is implemented\n   * as a subclass of VectorBase, which has element-wise `.plus()` and `.times()` operators, which can make\n   * implementing this function much shorter.\n   * @param progress\n   * @returns {VectorBase | Vec2}\n   */\n  getLinearInterpolationColor(progress) {\n    if (this.nControlPoints < 2) {\n      if (this.nControlPoints > 0) {\n        return this.verts.color.getAt(0);\n      } else {\n        return Color.FromString(\"#000000\");\n      }\n    }\n    let currentIndex = progress * (this.nControlPoints - 2);\n    let tfloor = Math.floor(currentIndex);\n    let startControlPointIndex = tfloor;\n    let startControlPointColor = this.getControlPointColor(startControlPointIndex);\n    let endControlPointIndex = Math.ceil(currentIndex);\n    let endControlPointColor = this.getControlPointColor(endControlPointIndex);\n    let alpha = currentIndex - tfloor;\n    return startControlPointColor.times(1 - alpha).plus(endControlPointColor.times(alpha));\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Returns a unit vector pointed toward the linearly interpolated shape's positive tangent `progress` along the\n   * length of the shape. Make sure you still return a unit vector at control points, though we won't test you on\n   * the direction of vectors at control points.\n   * @param progress\n   * @returns {Vec2}\n   */\n  getLinearInterpolationVelocity(progress) {\n    if (this.nControlPoints < 2) {\n      return V2();\n    }\n    let currentIndex = progress * (this.nControlPoints - 2);\n    let tfloor = Math.floor(currentIndex);\n    let startControlPointIndex = tfloor;\n    let startControlPoint = this.verts.getPoint2DAt(startControlPointIndex);\n    let endControlPointIndex = Math.ceil(currentIndex);\n    let endControlPoint = this.verts.getPoint2DAt(endControlPointIndex);\n    return new Vec2(endControlPoint.x - startControlPoint.x, endControlPoint.y - startControlPoint.y);\n    // TODO: Replace the line above with your own code\n  }\n  //</editor-fold>\n  //###########################################\\\\--Linear Interpolation--//###########################################\n\n  //###############################################//--Cubic Bezier--\\\\###############################################\n  //<editor-fold desc=\"Cubic Bezier\">\n\n  /**\n   * The number of interpolated control points in the spline.\n   * Review the online documentation for the assignment to figure out how the number of interpolated control points relates to the total number of\n   * control points.\n   * @returns {number}\n   */\n  get nInterpolatedControlPoints() {\n    return Math.ceil(this.nControlPoints / 3);\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * The number of spline segments. This should also be a function of the number of control points.\n   * @returns {number}\n   */\n  get nBezierSegments() {\n    return Math.floor(this.nControlPoints / 3);\n    // TODO: Replace the line above with your own code\n  }\n  constructor() {\n    super();\n    /**\n     * Getter and setter for `interpolationMode`, which wraps the protected variable _interpolationMode holding the\n     * current interpolation mode for the spline.\n     * */\n    this._interpolationMode = CurveInterpolationModes.CubicBezier;\n    this.controlShapeWidth = 0.003;\n    /**\n     * Whether the control shape is visible.\n     * @type {boolean}\n     */\n    this.controlShapeVisible = true;\n  }\n\n  /**\n   * Progress of 0 should map to the first interpolated point of the spline. Progress of 1 should map to the last interpolated point.\n   * A segment index of `n` where `n` is an integer should map to the first interpolated point of the nth segment.\n   * values between n and n+1 should map linearly to progress along the nth segment.\n   * @param progress\n   * @returns {number}\n   */\n  continuousSegmentIndexForProgress(progress) {\n    return progress * this.nBezierSegments;\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Should return the control point index for the kth interpolated point.\n   * Remember that not every control point is an interpolated point.\n   * @param interpolatedPointIndex\n   * @returns {number}\n   */\n  getControlPointIndexForInterpolatedPoint(interpolatedPointIndex) {\n    return interpolatedPointIndex * 3;\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Returns the point `progress` along the bezier spline interpolation of the control points\n   * @param progress\n   * @returns {VectorBase | Vec2}\n   */\n  getCubicBezierInterpolationPoint(progress) {\n    if (this.nControlPoints < 4) {\n      return this.getLinearInterpolationPoint(progress);\n    }\n    let segment = this.continuousSegmentIndexForProgress(progress);\n    let startControlPointIndex = this.getControlPointIndexForInterpolatedPoint(Math.floor(segment));\n    let alpha = segment - Math.floor(segment);\n    let p0 = this.getControlPointLocation(startControlPointIndex);\n    let p1 = this.getControlPointLocation(startControlPointIndex + 1);\n    let p2 = this.getControlPointLocation(startControlPointIndex + 2);\n    let p3 = this.getControlPointLocation(startControlPointIndex + 3);\n    if (progress == 1) {\n      return p0;\n    }\n    //Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha here\n    return GetCubicBezierSplineSegmentValueForAlpha(alpha, p0, p1, p2, p3);\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Returns the point `progress` along the bezier spline interpolation of the control points\n   * @param progress\n   * @returns {VectorBase | Vec2}\n   */\n  getCubicBezierInterpolatedColor(progress) {\n    if (this.nControlPoints < 4) {\n      return this.getLinearInterpolationColor(progress);\n    }\n    // Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha\n    if (this.nControlPoints < 4) {\n      return this.getLinearInterpolationColor(progress);\n    }\n    let segment = this.continuousSegmentIndexForProgress(progress);\n    let startControlPointIndex = this.getControlPointIndexForInterpolatedPoint(Math.floor(segment));\n    let alpha = segment - Math.floor(segment);\n    let c0 = this.getControlPointColor(startControlPointIndex);\n    let c1 = this.getControlPointColor(startControlPointIndex + 1);\n    let c2 = this.getControlPointColor(startControlPointIndex + 2);\n    let c3 = this.getControlPointColor(startControlPointIndex + 3);\n    if (progress == 1) {\n      return c0;\n    }\n    //Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha here\n    return GetCubicBezierSplineSegmentValueForAlpha(alpha, c0, c1, c2, c3);\n    // TODO: Replace the line above with your own code\n  }\n\n  /**\n   * Returns the point `progress` along the bezier spline interpolation of the control points\n   * @param progress\n   * @returns {VectorBase | Vec2}\n   */\n  getCubicBezierVelocityVector(progress) {\n    if (this.nControlPoints < 4) {\n      return this.getLinearInterpolationVelocity(progress);\n    }\n    // Hint: you probably want to use GetCubicBezierSplineSegmentDerivativeForAlpha here\n    let segment = this.continuousSegmentIndexForProgress(progress);\n    let startControlPointIndex = this.getControlPointIndexForInterpolatedPoint(Math.floor(segment));\n    let alpha = segment - Math.floor(segment);\n    let p0 = this.getControlPointLocation(startControlPointIndex);\n    let p1 = this.getControlPointLocation(startControlPointIndex + 1);\n    let p2 = this.getControlPointLocation(startControlPointIndex + 2);\n    let p3 = this.getControlPointLocation(startControlPointIndex + 3);\n    if (progress == 1.0) {\n      return p0.plus(this.getControlPointLocation(startControlPointIndex - 1).times(-1)).times(3 * alpha * alpha);\n    }\n    //Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha here\n    return GetCubicBezierSplineSegmentDerivativeForAlpha(alpha, p0, p1, p2, p3);\n    // TODO: Replace the line above with your own code\n  }\n  //</editor-fold>\n  //###############################################\\\\--Cubic Bezier--//###############################################\n\n  getPointForProgress(progress) {\n    switch (this.interpolationMode) {\n      case SplineModel.InterpolationModes.Linear:\n        return this.getLinearInterpolationPoint(progress);\n      case SplineModel.InterpolationModes.CubicBezier:\n        try {\n          return this.getCubicBezierInterpolationPoint(progress);\n        } catch (e) {\n          console.error(e);\n          return this.getLinearInterpolationPoint(progress);\n        }\n      default:\n        throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n    }\n  }\n  getDerivativeForProgress(progress) {\n    switch (this.interpolationMode) {\n      case SplineModel.InterpolationModes.Linear:\n        return this.getLinearInterpolationVelocity(progress);\n      case SplineModel.InterpolationModes.CubicBezier:\n        try {\n          return this.getCubicBezierVelocityVector(progress);\n        } catch (e) {\n          console.error(e);\n          return this.getLinearInterpolationVelocity(progress);\n        }\n      default:\n        throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n    }\n  }\n  getColorForProgress(progress) {\n    switch (this.interpolationMode) {\n      case SplineModel.InterpolationModes.Linear:\n        return this.getLinearInterpolationColor(progress);\n      case SplineModel.InterpolationModes.CubicBezier:\n        try {\n          return this.getCubicBezierInterpolatedColor(progress);\n        } catch (e) {\n          console.error(e);\n          return this.getLinearInterpolationColor(progress);\n        }\n      default:\n        throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n    }\n  }\n}, _SplineModel.InterpolationModes = CurveInterpolationModes, _SplineModel)) || _class);","map":{"version":3,"names":["ASerializable","Color","Curve2DModel","CurveInterpolationModes","V2","Vec2","GetCubicBezierSplineSegmentValueForAlpha","GetCubicBezierSplineSegmentDerivativeForAlpha","SplineModel","_dec","_class","_SplineModel","interpolationMode","value","_interpolationMode","signalGeometryUpdate","nControlPoints","verts","nVerts","getControlPointLocation","index","getPoint2DAt","getControlPointColor","color","getAt","getSegmentControlPoints","segmentIndex","startHandle","getSegmentControlPointColors","getLinearInterpolationPoint","progress","currentIndex","tfloor","Math","floor","startControlPointIndex","startControlPoint","endControlPointIndex","ceil","endControlPoint","alpha","x","y","getLinearInterpolationColor","FromString","startControlPointColor","endControlPointColor","times","plus","getLinearInterpolationVelocity","nInterpolatedControlPoints","nBezierSegments","constructor","CubicBezier","controlShapeWidth","controlShapeVisible","continuousSegmentIndexForProgress","getControlPointIndexForInterpolatedPoint","interpolatedPointIndex","getCubicBezierInterpolationPoint","segment","p0","p1","p2","p3","getCubicBezierInterpolatedColor","c0","c1","c2","c3","getCubicBezierVelocityVector","getPointForProgress","InterpolationModes","Linear","e","console","error","Error","getDerivativeForProgress","getColorForProgress"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/A1/nodes/Spline/SplineModel.ts"],"sourcesContent":["import {\n    ALineMaterialModel,\n    ANodeModel2D,\n    ASerializable,\n    Color, Curve2DModel, CurveInterpolationModes,\n    V2,\n    Vec2, Vector,\n    VectorBase,\n    VertexArray2D\n} from \"../../../anigraph\";\nimport {\n    GetCubicBezierSplineSegmentValueForAlpha,\n    GetCubicBezierSplineSegmentDerivativeForAlpha\n} from \"./CubicBezierFunctions\";\n\n\n@ASerializable(\"SplineModel\")\nexport class SplineModel extends Curve2DModel{\n\n    /**\n     * We will have two interpolation modes: Linear, and CubicBezier.\n     * These are set to the enum declared at the top of this file.\n     * @type {CurveInterpolationModes}\n     */\n    static InterpolationModes=CurveInterpolationModes;\n\n    /**\n     * Getter and setter for `interpolationMode`, which wraps the protected variable _interpolationMode holding the\n     * current interpolation mode for the spline.\n     * */\n    protected _interpolationMode:CurveInterpolationModes=CurveInterpolationModes.CubicBezier;\n    /**\n     * When the interpolation mode changes, we need to signal an update of the geometry.\n     * @param value\n     */\n    set interpolationMode(value){\n        this._interpolationMode = value;\n        this.signalGeometryUpdate();\n    }\n    get interpolationMode(){return this._interpolationMode;}\n\n    /**\n     * Width/thickness of the control shape when it is visible\n     * @type {number}\n     */\n    controlShapeWidth:number=0.003;\n    /**\n     * Whether the control shape is visible.\n     * @type {boolean}\n     */\n    controlShapeVisible:boolean=true;\n\n    /**\n     * The number of control points in our spline.\n     * This is simply the number of vertices in `this.verts`, which is a VertexArray2D inherited from `ANodeModel2D`,\n     * which is a parent class.\n     * @returns {number}\n     */\n    get nControlPoints():number{\n        return this.verts.nVerts;\n    }\n\n\n\n    getControlPointLocation(index:number):Vec2{\n        return this.verts.getPoint2DAt(index);\n    }\n\n    getControlPointColor(index:number):Color{\n        return this.verts.color.getAt(index);\n    }\n\n    /**\n     * There are 4 point in a cubic Bezier segment, and when we chain segments together we typically use the last\n     * control point of each segment as the first control point of the subsequent segment.\n     *\n     * Here we give you a function that takes a segment index and returns the 4 corresponding control points.\n     * @param segmentIndex\n     * @returns {[Vec2, Vec2, Vec2, Vec2]}\n     */\n    getSegmentControlPoints(segmentIndex:number):[Vec2, Vec2, Vec2, Vec2]{\n        let startHandle = segmentIndex*3\n        return [\n            this.verts.getPoint2DAt(startHandle),\n            this.verts.getPoint2DAt(startHandle + 1),\n            this.verts.getPoint2DAt(startHandle + 2),\n            this.verts.getPoint2DAt(startHandle + 3)\n        ]\n    }\n\n    /**\n     * Similar to `getSegmentControlPoints`, we give you a function to get the colors stored at each of the control\n     * points in the bezier segment with index `segmentIndex`.\n     * @param segmentIndex\n     * @returns {[Color, Color, Color, Color]}\n     */\n    getSegmentControlPointColors(segmentIndex:number):[Color, Color, Color, Color]{\n        let startHandle = segmentIndex*3\n        return [\n            this.verts.color.getAt(startHandle),\n            this.verts.color.getAt(startHandle + 1),\n            this.verts.color.getAt(startHandle + 2),\n            this.verts.color.getAt(startHandle + 3)\n        ]\n    }\n\n\n    //###########################################//--Linear Interpolation--\\\\###########################################\n    //<editor-fold desc=\"Linear Interpolation\">\n\n    /**\n     * Returns a point `progress` along the linear interpolation of control points.\n     * Remember, only the first and last point in each segment are interpolated!\n     * @param progress\n     * @returns {Vec2}\n     */\n    getLinearInterpolationPoint(progress:number):Vec2{\n        if(this.nControlPoints<2){\n            return V2();\n        }\n        let currentIndex = progress*(this.nControlPoints-2);\n        let tfloor = Math.floor(currentIndex);\n\n        let startControlPointIndex = tfloor;\n        let startControlPoint = this.verts.getPoint2DAt(startControlPointIndex);\n\n        let endControlPointIndex =Math.ceil(currentIndex);\n        let endControlPoint = this.verts.getPoint2DAt(endControlPointIndex);\n\n        let alpha = currentIndex-tfloor;\n\n        /**\n         * We've given you most of this function as an example of how to get control points by index.\n         * From here, you need to return a point that is interpolated `alpha` along the way from `startControlPoint` to\n         * `endControlPoint`...\n         */\n\n        return new Vec2(startControlPoint.x * (1-alpha) + alpha*endControlPoint.x, startControlPoint.y * (1 - alpha) + alpha*endControlPoint.y);\n        // TODO: Replace the line above with your own code\n    }\n\n\n    /**\n     * Colors can be represented as a vector of color channels. We can interpolate between these vectors in the same way\n     * we interpolate between the coordinate vector representations of spline control points.\n     *\n     * Hint: AniGraph's Color class represents a 4D vector with channels [red, green, blue, alpha], and is implemented\n     * as a subclass of VectorBase, which has element-wise `.plus()` and `.times()` operators, which can make\n     * implementing this function much shorter.\n     * @param progress\n     * @returns {VectorBase | Vec2}\n     */\n    getLinearInterpolationColor(progress:number):Color{\n        if(this.nControlPoints<2){\n            if(this.nControlPoints>0) {\n                return this.verts.color.getAt(0);\n            }else{\n                return Color.FromString(\"#000000\")\n            }\n        }\n\n        let currentIndex = progress*(this.nControlPoints-2);\n        let tfloor = Math.floor(currentIndex);\n\n        let startControlPointIndex = tfloor;\n        let startControlPointColor = this.getControlPointColor(startControlPointIndex);\n\n        let endControlPointIndex =Math.ceil(currentIndex);\n        let endControlPointColor = this.getControlPointColor(endControlPointIndex);\n\n        let alpha = currentIndex-tfloor;\n\n        return startControlPointColor.times(1-alpha).plus(endControlPointColor.times(alpha));\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * Returns a unit vector pointed toward the linearly interpolated shape's positive tangent `progress` along the\n     * length of the shape. Make sure you still return a unit vector at control points, though we won't test you on\n     * the direction of vectors at control points.\n     * @param progress\n     * @returns {Vec2}\n     */\n    getLinearInterpolationVelocity(progress:number):Vec2{\n        if(this.nControlPoints<2){\n            return V2();\n        }\n\n        let currentIndex = progress*(this.nControlPoints-2);\n        let tfloor = Math.floor(currentIndex);\n\n        let startControlPointIndex = tfloor;\n        let startControlPoint = this.verts.getPoint2DAt(startControlPointIndex);\n\n        let endControlPointIndex =Math.ceil(currentIndex);\n        let endControlPoint = this.verts.getPoint2DAt(endControlPointIndex);\n        return new Vec2(endControlPoint.x - startControlPoint.x, endControlPoint.y - startControlPoint.y);\n        // TODO: Replace the line above with your own code\n    }\n    //</editor-fold>\n    //###########################################\\\\--Linear Interpolation--//###########################################\n\n\n    //###############################################//--Cubic Bezier--\\\\###############################################\n    //<editor-fold desc=\"Cubic Bezier\">\n\n    /**\n     * The number of interpolated control points in the spline.\n     * Review the online documentation for the assignment to figure out how the number of interpolated control points relates to the total number of\n     * control points.\n     * @returns {number}\n     */\n    get nInterpolatedControlPoints():number{\n        return Math.ceil(this.nControlPoints/3)\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * The number of spline segments. This should also be a function of the number of control points.\n     * @returns {number}\n     */\n    get nBezierSegments():number{\n        return Math.floor(this.nControlPoints/3);\n        // TODO: Replace the line above with your own code\n    }\n\n    constructor() {\n        super();\n    }\n\n    /**\n     * Progress of 0 should map to the first interpolated point of the spline. Progress of 1 should map to the last interpolated point.\n     * A segment index of `n` where `n` is an integer should map to the first interpolated point of the nth segment.\n     * values between n and n+1 should map linearly to progress along the nth segment.\n     * @param progress\n     * @returns {number}\n     */\n    continuousSegmentIndexForProgress(progress:number):number{\n        return progress * this.nBezierSegments;\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * Should return the control point index for the kth interpolated point.\n     * Remember that not every control point is an interpolated point.\n     * @param interpolatedPointIndex\n     * @returns {number}\n     */\n    getControlPointIndexForInterpolatedPoint(interpolatedPointIndex:number):number{\n        return interpolatedPointIndex * 3;\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * Returns the point `progress` along the bezier spline interpolation of the control points\n     * @param progress\n     * @returns {VectorBase | Vec2}\n     */\n    getCubicBezierInterpolationPoint(progress:number):Vec2{\n        if(this.nControlPoints<4){\n            return this.getLinearInterpolationPoint(progress);\n        }\n\n        let segment = this.continuousSegmentIndexForProgress(progress)\n        let startControlPointIndex = this.getControlPointIndexForInterpolatedPoint(Math.floor(segment));\n        let alpha = segment - Math.floor(segment);\n        let p0 = this.getControlPointLocation(startControlPointIndex);\n        let p1 = this.getControlPointLocation(startControlPointIndex+1);\n        let p2 = this.getControlPointLocation(startControlPointIndex+2);\n        let p3 = this.getControlPointLocation(startControlPointIndex+3);\n        if (progress == 1){\n            return p0;}\n        //Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha here\n        return GetCubicBezierSplineSegmentValueForAlpha(alpha, p0, p1, p2, p3);\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * Returns the point `progress` along the bezier spline interpolation of the control points\n     * @param progress\n     * @returns {VectorBase | Vec2}\n     */\n    getCubicBezierInterpolatedColor(progress:number):Color{\n        if(this.nControlPoints<4){\n            return this.getLinearInterpolationColor(progress);\n        }\n        // Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha\n        if(this.nControlPoints<4){\n            return this.getLinearInterpolationColor(progress);\n        }\n\n\n        let segment = this.continuousSegmentIndexForProgress(progress)\n        let startControlPointIndex = this.getControlPointIndexForInterpolatedPoint(Math.floor(segment));\n        let alpha = segment - Math.floor(segment);\n        let c0 = this.getControlPointColor(startControlPointIndex);\n        let c1 = this.getControlPointColor(startControlPointIndex+1);\n        let c2 = this.getControlPointColor(startControlPointIndex+2);\n        let c3 = this.getControlPointColor(startControlPointIndex+3);\n        if (progress == 1){\n            return c0;}\n        //Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha here\n        return GetCubicBezierSplineSegmentValueForAlpha(alpha, c0, c1, c2, c3);\n        // TODO: Replace the line above with your own code\n    }\n\n    /**\n     * Returns the point `progress` along the bezier spline interpolation of the control points\n     * @param progress\n     * @returns {VectorBase | Vec2}\n     */\n    getCubicBezierVelocityVector(progress:number):Vec2{\n        if(this.nControlPoints<4){\n            return this.getLinearInterpolationVelocity(progress);\n        }\n        // Hint: you probably want to use GetCubicBezierSplineSegmentDerivativeForAlpha here\n        let segment = this.continuousSegmentIndexForProgress(progress)\n        let startControlPointIndex = this.getControlPointIndexForInterpolatedPoint(Math.floor(segment));\n        let alpha = segment - Math.floor(segment);\n        let p0 = this.getControlPointLocation(startControlPointIndex);\n        let p1 = this.getControlPointLocation(startControlPointIndex+1);\n        let p2 = this.getControlPointLocation(startControlPointIndex+2);\n        let p3 = this.getControlPointLocation(startControlPointIndex+3);\n        if (progress == 1.0){\n            return (p0.plus(this.getControlPointLocation(startControlPointIndex-1).times(-1))).times(3*alpha*alpha);\n        }\n        //Hint: you probably want to use GetCubicBezierSplineSegmentValueForAlpha here\n        return GetCubicBezierSplineSegmentDerivativeForAlpha(alpha, p0, p1, p2, p3);\n        // TODO: Replace the line above with your own code\n    }\n    //</editor-fold>\n    //###############################################\\\\--Cubic Bezier--//###############################################\n\n\n\n\n    getPointForProgress(progress:number){\n        switch (this.interpolationMode){\n            case SplineModel.InterpolationModes.Linear:\n                return this.getLinearInterpolationPoint(progress);\n            case SplineModel.InterpolationModes.CubicBezier:\n                try {\n                return this.getCubicBezierInterpolationPoint(progress);\n                }catch(e){\n                    console.error(e);\n                    return this.getLinearInterpolationPoint(progress);\n                }\n            default:\n                throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n        }\n    }\n\n    getDerivativeForProgress(progress:number){\n        switch (this.interpolationMode){\n            case SplineModel.InterpolationModes.Linear:\n                return this.getLinearInterpolationVelocity(progress);\n            case SplineModel.InterpolationModes.CubicBezier:\n                try {\n                    return this.getCubicBezierVelocityVector(progress);\n                }catch(e){\n                    console.error(e);\n                    return this.getLinearInterpolationVelocity(progress);\n                }\n            default:\n                throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n        }\n    }\n\n    getColorForProgress(progress:number){\n        switch (this.interpolationMode){\n            case SplineModel.InterpolationModes.Linear:\n                return this.getLinearInterpolationColor(progress);\n            case SplineModel.InterpolationModes.CubicBezier:\n                try {\n                return this.getCubicBezierInterpolatedColor(progress);\n                }catch(e){\n                    console.error(e);\n                    return this.getLinearInterpolationColor(progress);\n                }\n            default:\n                throw new Error(`Unknown interpolation mode ${this.interpolationMode}`);\n        }\n    }\n\n}\n"],"mappings":";AAAA,SAGIA,aAAa,EACbC,KAAK,EAAEC,YAAY,EAAEC,uBAAuB,EAC5CC,EAAE,EACFC,IAAI,QAGD,mBAAmB;AAC1B,SACIC,wCAAwC,EACxCC,6CAA6C,QAC1C,wBAAwB;AAG/B,WACaC,WAAW,IAAAC,IAAA,GADvBT,aAAa,CAAC,aAAa,CAAC,EAAAS,IAAA,CAAAC,MAAA,IAAAC,YAAA,GAA7B,MACaH,WAAW,SAASN,YAAY;EAczC;AACJ;AACA;AACA;EACI,IAAIU,iBAAiBA,CAACC,KAAK,EAAC;IACxB,IAAI,CAACC,kBAAkB,GAAGD,KAAK;IAC/B,IAAI,CAACE,oBAAoB,CAAC,CAAC;EAC/B;EACA,IAAIH,iBAAiBA,CAAA,EAAE;IAAC,OAAO,IAAI,CAACE,kBAAkB;EAAC;;EAEvD;AACJ;AACA;AACA;;EAQI;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIE,cAAcA,CAAA,EAAS;IACvB,OAAO,IAAI,CAACC,KAAK,CAACC,MAAM;EAC5B;EAIAC,uBAAuBA,CAACC,KAAY,EAAM;IACtC,OAAO,IAAI,CAACH,KAAK,CAACI,YAAY,CAACD,KAAK,CAAC;EACzC;EAEAE,oBAAoBA,CAACF,KAAY,EAAO;IACpC,OAAO,IAAI,CAACH,KAAK,CAACM,KAAK,CAACC,KAAK,CAACJ,KAAK,CAAC;EACxC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,uBAAuBA,CAACC,YAAmB,EAA0B;IACjE,IAAIC,WAAW,GAAGD,YAAY,GAAC,CAAC;IAChC,OAAO,CACH,IAAI,CAACT,KAAK,CAACI,YAAY,CAACM,WAAW,CAAC,EACpC,IAAI,CAACV,KAAK,CAACI,YAAY,CAACM,WAAW,GAAG,CAAC,CAAC,EACxC,IAAI,CAACV,KAAK,CAACI,YAAY,CAACM,WAAW,GAAG,CAAC,CAAC,EACxC,IAAI,CAACV,KAAK,CAACI,YAAY,CAACM,WAAW,GAAG,CAAC,CAAC,CAC3C;EACL;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIC,4BAA4BA,CAACF,YAAmB,EAA8B;IAC1E,IAAIC,WAAW,GAAGD,YAAY,GAAC,CAAC;IAChC,OAAO,CACH,IAAI,CAACT,KAAK,CAACM,KAAK,CAACC,KAAK,CAACG,WAAW,CAAC,EACnC,IAAI,CAACV,KAAK,CAACM,KAAK,CAACC,KAAK,CAACG,WAAW,GAAG,CAAC,CAAC,EACvC,IAAI,CAACV,KAAK,CAACM,KAAK,CAACC,KAAK,CAACG,WAAW,GAAG,CAAC,CAAC,EACvC,IAAI,CAACV,KAAK,CAACM,KAAK,CAACC,KAAK,CAACG,WAAW,GAAG,CAAC,CAAC,CAC1C;EACL;;EAGA;EACA;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIE,2BAA2BA,CAACC,QAAe,EAAM;IAC7C,IAAG,IAAI,CAACd,cAAc,GAAC,CAAC,EAAC;MACrB,OAAOZ,EAAE,CAAC,CAAC;IACf;IACA,IAAI2B,YAAY,GAAGD,QAAQ,IAAE,IAAI,CAACd,cAAc,GAAC,CAAC,CAAC;IACnD,IAAIgB,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACH,YAAY,CAAC;IAErC,IAAII,sBAAsB,GAAGH,MAAM;IACnC,IAAII,iBAAiB,GAAG,IAAI,CAACnB,KAAK,CAACI,YAAY,CAACc,sBAAsB,CAAC;IAEvE,IAAIE,oBAAoB,GAAEJ,IAAI,CAACK,IAAI,CAACP,YAAY,CAAC;IACjD,IAAIQ,eAAe,GAAG,IAAI,CAACtB,KAAK,CAACI,YAAY,CAACgB,oBAAoB,CAAC;IAEnE,IAAIG,KAAK,GAAGT,YAAY,GAACC,MAAM;;IAE/B;AACR;AACA;AACA;AACA;;IAEQ,OAAO,IAAI3B,IAAI,CAAC+B,iBAAiB,CAACK,CAAC,IAAI,CAAC,GAACD,KAAK,CAAC,GAAGA,KAAK,GAACD,eAAe,CAACE,CAAC,EAAEL,iBAAiB,CAACM,CAAC,IAAI,CAAC,GAAGF,KAAK,CAAC,GAAGA,KAAK,GAACD,eAAe,CAACG,CAAC,CAAC;IACvI;EACJ;;EAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,2BAA2BA,CAACb,QAAe,EAAO;IAC9C,IAAG,IAAI,CAACd,cAAc,GAAC,CAAC,EAAC;MACrB,IAAG,IAAI,CAACA,cAAc,GAAC,CAAC,EAAE;QACtB,OAAO,IAAI,CAACC,KAAK,CAACM,KAAK,CAACC,KAAK,CAAC,CAAC,CAAC;MACpC,CAAC,MAAI;QACD,OAAOvB,KAAK,CAAC2C,UAAU,CAAC,SAAS,CAAC;MACtC;IACJ;IAEA,IAAIb,YAAY,GAAGD,QAAQ,IAAE,IAAI,CAACd,cAAc,GAAC,CAAC,CAAC;IACnD,IAAIgB,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACH,YAAY,CAAC;IAErC,IAAII,sBAAsB,GAAGH,MAAM;IACnC,IAAIa,sBAAsB,GAAG,IAAI,CAACvB,oBAAoB,CAACa,sBAAsB,CAAC;IAE9E,IAAIE,oBAAoB,GAAEJ,IAAI,CAACK,IAAI,CAACP,YAAY,CAAC;IACjD,IAAIe,oBAAoB,GAAG,IAAI,CAACxB,oBAAoB,CAACe,oBAAoB,CAAC;IAE1E,IAAIG,KAAK,GAAGT,YAAY,GAACC,MAAM;IAE/B,OAAOa,sBAAsB,CAACE,KAAK,CAAC,CAAC,GAACP,KAAK,CAAC,CAACQ,IAAI,CAACF,oBAAoB,CAACC,KAAK,CAACP,KAAK,CAAC,CAAC;IACpF;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIS,8BAA8BA,CAACnB,QAAe,EAAM;IAChD,IAAG,IAAI,CAACd,cAAc,GAAC,CAAC,EAAC;MACrB,OAAOZ,EAAE,CAAC,CAAC;IACf;IAEA,IAAI2B,YAAY,GAAGD,QAAQ,IAAE,IAAI,CAACd,cAAc,GAAC,CAAC,CAAC;IACnD,IAAIgB,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACH,YAAY,CAAC;IAErC,IAAII,sBAAsB,GAAGH,MAAM;IACnC,IAAII,iBAAiB,GAAG,IAAI,CAACnB,KAAK,CAACI,YAAY,CAACc,sBAAsB,CAAC;IAEvE,IAAIE,oBAAoB,GAAEJ,IAAI,CAACK,IAAI,CAACP,YAAY,CAAC;IACjD,IAAIQ,eAAe,GAAG,IAAI,CAACtB,KAAK,CAACI,YAAY,CAACgB,oBAAoB,CAAC;IACnE,OAAO,IAAIhC,IAAI,CAACkC,eAAe,CAACE,CAAC,GAAGL,iBAAiB,CAACK,CAAC,EAAEF,eAAe,CAACG,CAAC,GAAGN,iBAAiB,CAACM,CAAC,CAAC;IACjG;EACJ;EACA;EACA;;EAGA;EACA;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIQ,0BAA0BA,CAAA,EAAS;IACnC,OAAOjB,IAAI,CAACK,IAAI,CAAC,IAAI,CAACtB,cAAc,GAAC,CAAC,CAAC;IACvC;EACJ;;EAEA;AACJ;AACA;AACA;EACI,IAAImC,eAAeA,CAAA,EAAS;IACxB,OAAOlB,IAAI,CAACC,KAAK,CAAC,IAAI,CAAClB,cAAc,GAAC,CAAC,CAAC;IACxC;EACJ;EAEAoC,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,CAAC;IAzMX;AACJ;AACA;AACA;IAHI,KAIUtC,kBAAkB,GAAyBX,uBAAuB,CAACkD,WAAW;IAAA,KAexFC,iBAAiB,GAAQ,KAAK;IAC9B;AACJ;AACA;AACA;IAHI,KAIAC,mBAAmB,GAAS,IAAI;EAkLhC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,iCAAiCA,CAAC1B,QAAe,EAAQ;IACrD,OAAOA,QAAQ,GAAG,IAAI,CAACqB,eAAe;IACtC;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIM,wCAAwCA,CAACC,sBAA6B,EAAQ;IAC1E,OAAOA,sBAAsB,GAAG,CAAC;IACjC;EACJ;;EAEA;AACJ;AACA;AACA;AACA;EACIC,gCAAgCA,CAAC7B,QAAe,EAAM;IAClD,IAAG,IAAI,CAACd,cAAc,GAAC,CAAC,EAAC;MACrB,OAAO,IAAI,CAACa,2BAA2B,CAACC,QAAQ,CAAC;IACrD;IAEA,IAAI8B,OAAO,GAAG,IAAI,CAACJ,iCAAiC,CAAC1B,QAAQ,CAAC;IAC9D,IAAIK,sBAAsB,GAAG,IAAI,CAACsB,wCAAwC,CAACxB,IAAI,CAACC,KAAK,CAAC0B,OAAO,CAAC,CAAC;IAC/F,IAAIpB,KAAK,GAAGoB,OAAO,GAAG3B,IAAI,CAACC,KAAK,CAAC0B,OAAO,CAAC;IACzC,IAAIC,EAAE,GAAG,IAAI,CAAC1C,uBAAuB,CAACgB,sBAAsB,CAAC;IAC7D,IAAI2B,EAAE,GAAG,IAAI,CAAC3C,uBAAuB,CAACgB,sBAAsB,GAAC,CAAC,CAAC;IAC/D,IAAI4B,EAAE,GAAG,IAAI,CAAC5C,uBAAuB,CAACgB,sBAAsB,GAAC,CAAC,CAAC;IAC/D,IAAI6B,EAAE,GAAG,IAAI,CAAC7C,uBAAuB,CAACgB,sBAAsB,GAAC,CAAC,CAAC;IAC/D,IAAIL,QAAQ,IAAI,CAAC,EAAC;MACd,OAAO+B,EAAE;IAAC;IACd;IACA,OAAOvD,wCAAwC,CAACkC,KAAK,EAAEqB,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACtE;EACJ;;EAEA;AACJ;AACA;AACA;AACA;EACIC,+BAA+BA,CAACnC,QAAe,EAAO;IAClD,IAAG,IAAI,CAACd,cAAc,GAAC,CAAC,EAAC;MACrB,OAAO,IAAI,CAAC2B,2BAA2B,CAACb,QAAQ,CAAC;IACrD;IACA;IACA,IAAG,IAAI,CAACd,cAAc,GAAC,CAAC,EAAC;MACrB,OAAO,IAAI,CAAC2B,2BAA2B,CAACb,QAAQ,CAAC;IACrD;IAGA,IAAI8B,OAAO,GAAG,IAAI,CAACJ,iCAAiC,CAAC1B,QAAQ,CAAC;IAC9D,IAAIK,sBAAsB,GAAG,IAAI,CAACsB,wCAAwC,CAACxB,IAAI,CAACC,KAAK,CAAC0B,OAAO,CAAC,CAAC;IAC/F,IAAIpB,KAAK,GAAGoB,OAAO,GAAG3B,IAAI,CAACC,KAAK,CAAC0B,OAAO,CAAC;IACzC,IAAIM,EAAE,GAAG,IAAI,CAAC5C,oBAAoB,CAACa,sBAAsB,CAAC;IAC1D,IAAIgC,EAAE,GAAG,IAAI,CAAC7C,oBAAoB,CAACa,sBAAsB,GAAC,CAAC,CAAC;IAC5D,IAAIiC,EAAE,GAAG,IAAI,CAAC9C,oBAAoB,CAACa,sBAAsB,GAAC,CAAC,CAAC;IAC5D,IAAIkC,EAAE,GAAG,IAAI,CAAC/C,oBAAoB,CAACa,sBAAsB,GAAC,CAAC,CAAC;IAC5D,IAAIL,QAAQ,IAAI,CAAC,EAAC;MACd,OAAOoC,EAAE;IAAC;IACd;IACA,OAAO5D,wCAAwC,CAACkC,KAAK,EAAE0B,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACtE;EACJ;;EAEA;AACJ;AACA;AACA;AACA;EACIC,4BAA4BA,CAACxC,QAAe,EAAM;IAC9C,IAAG,IAAI,CAACd,cAAc,GAAC,CAAC,EAAC;MACrB,OAAO,IAAI,CAACiC,8BAA8B,CAACnB,QAAQ,CAAC;IACxD;IACA;IACA,IAAI8B,OAAO,GAAG,IAAI,CAACJ,iCAAiC,CAAC1B,QAAQ,CAAC;IAC9D,IAAIK,sBAAsB,GAAG,IAAI,CAACsB,wCAAwC,CAACxB,IAAI,CAACC,KAAK,CAAC0B,OAAO,CAAC,CAAC;IAC/F,IAAIpB,KAAK,GAAGoB,OAAO,GAAG3B,IAAI,CAACC,KAAK,CAAC0B,OAAO,CAAC;IACzC,IAAIC,EAAE,GAAG,IAAI,CAAC1C,uBAAuB,CAACgB,sBAAsB,CAAC;IAC7D,IAAI2B,EAAE,GAAG,IAAI,CAAC3C,uBAAuB,CAACgB,sBAAsB,GAAC,CAAC,CAAC;IAC/D,IAAI4B,EAAE,GAAG,IAAI,CAAC5C,uBAAuB,CAACgB,sBAAsB,GAAC,CAAC,CAAC;IAC/D,IAAI6B,EAAE,GAAG,IAAI,CAAC7C,uBAAuB,CAACgB,sBAAsB,GAAC,CAAC,CAAC;IAC/D,IAAIL,QAAQ,IAAI,GAAG,EAAC;MAChB,OAAQ+B,EAAE,CAACb,IAAI,CAAC,IAAI,CAAC7B,uBAAuB,CAACgB,sBAAsB,GAAC,CAAC,CAAC,CAACY,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAEA,KAAK,CAAC,CAAC,GAACP,KAAK,GAACA,KAAK,CAAC;IAC3G;IACA;IACA,OAAOjC,6CAA6C,CAACiC,KAAK,EAAEqB,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IAC3E;EACJ;EACA;EACA;;EAKAO,mBAAmBA,CAACzC,QAAe,EAAC;IAChC,QAAQ,IAAI,CAAClB,iBAAiB;MAC1B,KAAKJ,WAAW,CAACgE,kBAAkB,CAACC,MAAM;QACtC,OAAO,IAAI,CAAC5C,2BAA2B,CAACC,QAAQ,CAAC;MACrD,KAAKtB,WAAW,CAACgE,kBAAkB,CAACnB,WAAW;QAC3C,IAAI;UACJ,OAAO,IAAI,CAACM,gCAAgC,CAAC7B,QAAQ,CAAC;QACtD,CAAC,QAAM4C,CAAC,EAAC;UACLC,OAAO,CAACC,KAAK,CAACF,CAAC,CAAC;UAChB,OAAO,IAAI,CAAC7C,2BAA2B,CAACC,QAAQ,CAAC;QACrD;MACJ;QACI,MAAM,IAAI+C,KAAK,CAAC,8BAA8B,IAAI,CAACjE,iBAAiB,EAAE,CAAC;IAC/E;EACJ;EAEAkE,wBAAwBA,CAAChD,QAAe,EAAC;IACrC,QAAQ,IAAI,CAAClB,iBAAiB;MAC1B,KAAKJ,WAAW,CAACgE,kBAAkB,CAACC,MAAM;QACtC,OAAO,IAAI,CAACxB,8BAA8B,CAACnB,QAAQ,CAAC;MACxD,KAAKtB,WAAW,CAACgE,kBAAkB,CAACnB,WAAW;QAC3C,IAAI;UACA,OAAO,IAAI,CAACiB,4BAA4B,CAACxC,QAAQ,CAAC;QACtD,CAAC,QAAM4C,CAAC,EAAC;UACLC,OAAO,CAACC,KAAK,CAACF,CAAC,CAAC;UAChB,OAAO,IAAI,CAACzB,8BAA8B,CAACnB,QAAQ,CAAC;QACxD;MACJ;QACI,MAAM,IAAI+C,KAAK,CAAC,8BAA8B,IAAI,CAACjE,iBAAiB,EAAE,CAAC;IAC/E;EACJ;EAEAmE,mBAAmBA,CAACjD,QAAe,EAAC;IAChC,QAAQ,IAAI,CAAClB,iBAAiB;MAC1B,KAAKJ,WAAW,CAACgE,kBAAkB,CAACC,MAAM;QACtC,OAAO,IAAI,CAAC9B,2BAA2B,CAACb,QAAQ,CAAC;MACrD,KAAKtB,WAAW,CAACgE,kBAAkB,CAACnB,WAAW;QAC3C,IAAI;UACJ,OAAO,IAAI,CAACY,+BAA+B,CAACnC,QAAQ,CAAC;QACrD,CAAC,QAAM4C,CAAC,EAAC;UACLC,OAAO,CAACC,KAAK,CAACF,CAAC,CAAC;UAChB,OAAO,IAAI,CAAC/B,2BAA2B,CAACb,QAAQ,CAAC;QACrD;MACJ;QACI,MAAM,IAAI+C,KAAK,CAAC,8BAA8B,IAAI,CAACjE,iBAAiB,EAAE,CAAC;IAC/E;EACJ;AAEJ,CAAC,EAAAD,YAAA,CAxWU6D,kBAAkB,GAACrE,uBAAuB,EAAAQ,YAAA,MAAAD,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}