{"ast":null,"code":"var _dec, _class, _AScenePointerLockInteractionMode;\n/**\n * Player Controls. An InteractionMode that activates interactions with a given DOM element.\n * You can create custom controls by subclassing to define your own:\n * onMouseMove: callback for mouse movement\n * onKeyDown & onKeyUp: callbacks for when keys are pressed and released\n */\n\nimport { AClickInteraction } from \"../../interaction\";\nimport { ASerializable } from \"../../base\";\nimport { ASceneInteractionMode } from \"./ASceneInteractionMode\";\nexport let PointerLockEvents = /*#__PURE__*/function (PointerLockEvents) {\n  PointerLockEvents[\"Lock\"] = \"PointerLock_Lock\";\n  PointerLockEvents[\"Unlock\"] = \"PointerLock_Unlock\";\n  return PointerLockEvents;\n}({});\nexport let AScenePointerLockInteractionMode = (_dec = ASerializable(\"AScenePointerLockInteractionMode\"), _dec(_class = (_AScenePointerLockInteractionMode = class AScenePointerLockInteractionMode extends ASceneInteractionMode {\n  constructor(...args) {\n    super(...args);\n    this.isLocked = false;\n    this._onLock = void 0;\n    this._onUnlock = void 0;\n  }\n  onLock(...args) {\n    if (this._onLock) {\n      this._onLock(...args);\n    }\n  }\n  onUnlock(...args) {\n    if (this._onUnlock) {\n      this._onUnlock(...args);\n    }\n  }\n  init(owner, ...args) {\n    super.init(owner, ...args);\n    this._initPointerLock();\n    this.onPointerlockChange = this.onPointerlockChange.bind(this);\n    this.onPointerlockError = this.onPointerlockError.bind(this);\n  }\n  _initPointerLock() {\n    const self = this;\n    this.addInteraction(AClickInteraction.Create(this.domElement, () => {\n      self.lockPointer();\n    }));\n  }\n  beforeActivate(...args) {\n    this.connect();\n  }\n  beforeDeactivate(...args) {\n    this.onUnlock();\n    this.disconnect();\n  }\n  connect() {\n    const self = this;\n    // self.domElement.ownerDocument.addEventListener( 'mousemove', self.onMouseMove );\n    self.domElement.ownerDocument.addEventListener('pointerlockchange', self.onPointerlockChange);\n    self.domElement.ownerDocument.addEventListener('pointerlockerror', self.onPointerlockError);\n  }\n  disconnect() {\n    const self = this;\n    // self.domElement.ownerDocument.removeEventListener( 'mousemove', self.onMouseMove );\n    self.domElement.ownerDocument.removeEventListener('pointerlockchange', self.onPointerlockChange);\n    self.domElement.ownerDocument.removeEventListener('pointerlockerror', self.onPointerlockError);\n  }\n  lockPointer() {\n    this.domElement.requestPointerLock();\n    this.onLock();\n  }\n  unlockPointer() {\n    this.domElement.ownerDocument.exitPointerLock();\n    this.onUnlock();\n  }\n  dispose() {\n    this.disconnect();\n  }\n  onPointerlockChange() {\n    const self = this;\n    if (self.domElement.ownerDocument.pointerLockElement === self.domElement) {\n      self.owner.signalEvent(AScenePointerLockInteractionMode.LockEvents.Lock);\n      self.isLocked = true;\n    } else {\n      self.owner.signalEvent(AScenePointerLockInteractionMode.LockEvents.Unlock);\n      self.isLocked = false;\n    }\n  }\n  onPointerlockError() {\n    console.error('Unable to use Pointer Lock API');\n  }\n  onMouseMove(event, interaction) {\n    // console.log(event);\n    if (this.isLocked === false) return;\n    let webEvent = event.DOMEvent;\n    // @ts-ignore\n    const movementX = webEvent.movementX || webEvent.mozMovementX || webEvent.webkitMovementX || 0;\n    // @ts-ignore\n    const movementY = webEvent.movementY || webEvent.mozMovementY || webEvent.webkitMovementY || 0;\n  }\n}, _AScenePointerLockInteractionMode.LockEvents = PointerLockEvents, _AScenePointerLockInteractionMode)) || _class);","map":{"version":3,"names":["AClickInteraction","ASerializable","ASceneInteractionMode","PointerLockEvents","AScenePointerLockInteractionMode","_dec","_class","_AScenePointerLockInteractionMode","constructor","args","isLocked","_onLock","_onUnlock","onLock","onUnlock","init","owner","_initPointerLock","onPointerlockChange","bind","onPointerlockError","self","addInteraction","Create","domElement","lockPointer","beforeActivate","connect","beforeDeactivate","disconnect","ownerDocument","addEventListener","removeEventListener","requestPointerLock","unlockPointer","exitPointerLock","dispose","pointerLockElement","signalEvent","LockEvents","Lock","Unlock","console","error","onMouseMove","event","interaction","webEvent","DOMEvent","movementX","mozMovementX","webkitMovementX","movementY","mozMovementY","webkitMovementY"],"sources":["/Users/twist/Documents/Books/Fall 2024/Graphics/A1-Intro-To-Graphics-FA2024/src/anigraph/starter/interactionmodes/AScenePointerLockInteractionMode.ts"],"sourcesContent":["/**\n * Player Controls. An InteractionMode that activates interactions with a given DOM element.\n * You can create custom controls by subclassing to define your own:\n * onMouseMove: callback for mouse movement\n * onKeyDown & onKeyUp: callbacks for when keys are pressed and released\n */\n\nimport {\n    ADragInteraction,\n    AKeyboardInteraction,\n    SetInteractionCallbacks,\n    AInteractionEvent,\n    AInteractionMode,\n    ADOMPointerMoveInteraction, AClickInteraction\n} from \"../../interaction\";\nimport {ACamera} from \"../../math\";\nimport {ACameraModel} from \"../../scene/camera\";\nimport {ASerializable} from \"../../base\";\nimport {Vec2, V2} from \"../../math\";\nimport {AWheelInteraction, AWheelInteractionCallback} from \"../../interaction/AWheelInteraction\";\nimport {ASceneController} from \"../../scene/ASceneController\";\nimport type {HasInteractionModeCallbacks} from \"../../interaction\";\nimport {ASceneInteractionMode} from \"./ASceneInteractionMode\";\nimport {CallbackType} from \"../../basictypes\";\n\nexport enum PointerLockEvents{\n    Lock=\"PointerLock_Lock\",\n    Unlock=\"PointerLock_Unlock\",\n}\n\n@ASerializable(\"AScenePointerLockInteractionMode\")\nexport class AScenePointerLockInteractionMode extends ASceneInteractionMode implements HasInteractionModeCallbacks {\n    isLocked: boolean=false;\n    static LockEvents=PointerLockEvents;\n    _onLock!:CallbackType;\n    _onUnlock!:CallbackType;\n    onLock(...args:any[]){if(this._onLock){this._onLock(...args);}}\n    onUnlock(...args:any[]){if(this._onUnlock){this._onUnlock(...args);}}\n\n\n    init(owner: ASceneController, ...args: any[]){\n        super.init(owner, ...args);\n        this._initPointerLock();\n        this.onPointerlockChange = this.onPointerlockChange.bind(this);\n        this.onPointerlockError = this.onPointerlockError.bind(this);\n    }\n\n    _initPointerLock(){\n        const self = this;\n        this.addInteraction(AClickInteraction.Create(this.domElement, ()=>{\n            self.lockPointer();\n        }))\n    }\n\n    beforeActivate(...args:any[]) {\n        this.connect();\n    }\n    beforeDeactivate(...args:any[]) {\n        this.onUnlock();\n        this.disconnect();\n    }\n\n    connect(){\n        const self = this;\n        // self.domElement.ownerDocument.addEventListener( 'mousemove', self.onMouseMove );\n        self.domElement.ownerDocument.addEventListener( 'pointerlockchange', self.onPointerlockChange );\n        self.domElement.ownerDocument.addEventListener( 'pointerlockerror', self.onPointerlockError );\n    }\n\n    disconnect(){\n        const self = this;\n        // self.domElement.ownerDocument.removeEventListener( 'mousemove', self.onMouseMove );\n        self.domElement.ownerDocument.removeEventListener( 'pointerlockchange', self.onPointerlockChange );\n        self.domElement.ownerDocument.removeEventListener( 'pointerlockerror', self.onPointerlockError );\n\n    }\n    lockPointer(){\n        this.domElement.requestPointerLock();\n        this.onLock();\n    }\n\n    unlockPointer(){\n        this.domElement.ownerDocument.exitPointerLock();\n        this.onUnlock();\n    }\n\n    dispose(){\n        this.disconnect();\n    };\n\n\n    onPointerlockChange() {\n        const self = this;\n        if ( self.domElement.ownerDocument.pointerLockElement === self.domElement ) {\n            self.owner.signalEvent(AScenePointerLockInteractionMode.LockEvents.Lock);\n            self.isLocked = true;\n        } else {\n            self.owner.signalEvent(AScenePointerLockInteractionMode.LockEvents.Unlock);\n            self.isLocked = false;\n        }\n    }\n\n    onPointerlockError(){\n        console.error( 'Unable to use Pointer Lock API' );\n    }\n\n    onMouseMove(event:AInteractionEvent, interaction:ADOMPointerMoveInteraction ) {\n        // console.log(event);\n        if ( this.isLocked === false ) return;\n\n        let webEvent = (event.DOMEvent as MouseEvent);\n        // @ts-ignore\n        const movementX = webEvent.movementX || webEvent.mozMovementX || webEvent.webkitMovementX || 0;\n        // @ts-ignore\n        const movementY = webEvent.movementY || webEvent.mozMovementY || webEvent.webkitMovementY || 0;\n    }\n}\n\n\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}